<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d5a097b1c17e39270ded1fa54da5b796857bcb6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37652522" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia klasę bazową, z którego są uzyskiwane klas, które reprezentują węzły drzewa wyrażeń. Zawiera ona także <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodami factory, aby utworzyć różne typy węzłów. Jest to <see langword="abstract" /> klasy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia bloku. Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> By ustawić je jako typ węzła.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> To <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Obiekt odwiedzający można znaleźć w tym węźle za pomocą.</param>
        <summary>Wysyła do konkretnej można znaleźć metody dla tego typu węzła. Na przykład <see cref="T:System.Linq.Expressions.MethodCallExpression" /> wywołania <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
        <returns>Wynik odwiedzający tego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta domyślna implementacja dla <xref:System.Linq.Expressions.ExpressionType.Extension> wywołania węzłów <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>. Przesłonić tę metodę do wywołania do bardziej szczegółowych metody w klasie pochodnej gości z <xref:System.Linq.Expressions.ExpressionVisitor> klasy. Obsługuje on jednak powinny nadal nieznany odwiedzających, wywołując <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który dodaje dwie liczby całkowite.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje wartość do zmiennej całkowitej, a następnie przypisuje wynik operacji do zmiennej.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację logiczne AND na dwóch wartości logiczne.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="true" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="true" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkową `AND` operator jest obliczane przy użyciu operatora testu koniunkcji `AND` operatora. W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, który wykonuje logicznych i operacji na jego dwóch argumentów operacji tylko wtedy, gdy pierwszy operand ma wartość `true`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy jest to pierwszy argument nie zostanie rozwiązany na wartość true. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkową `AND` operator jest obliczane przy użyciu operatora testu koniunkcji `AND` operatora. W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie, które reprezentuje tablicę wielowymiarową.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierające wyrażenia używane do indeksu tablicy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> na dostęp do tablicy wielowymiarowej.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie, które reprezentuje tablicę, można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metodę, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zmienić wartości elementu w tablicy wielowymiarowej za pomocą `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Wyrażenie reprezentujące tablicy do indeksu.</param>
        <param name="indexes">Tablica, która zawiera wyrażenia używane do indeksu tablicy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyrażenie, które reprezentuje tablicę, można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metodę, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.  
  
 Dla tablic wielowymiarowych, użyj <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zmienić wartości elementu tablicy za pomocą `ArrayAccess` metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący zastosowania operatora indeksu tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości.</param>
        <param name="indexes">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy o randze więcej niż jeden port.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element obiektu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.  
  
 Jeśli ranga `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.  
  
 Jeśli ranga `array`. Typ jest więcej niż jeden, Metoda ta zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> , który opisuje metody publiczne wystąpienia `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentująca indeksowanie w dwuwymiarowej tablicy.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie reprezentuje typ tablicy.  - lub - ranga <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="index">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zastosowania operatora indeksu tablicy do tablicy o rzędzie, jeden.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` musi reprezentować indeksu typu <xref:System.Int32>.  
  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null`, a oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa typ elementu `array`. Typ. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="index" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie reprezentuje typ tablicy.  - lub - <paramref name="array" />. Typ reprezentuje typ tablicy, w której pozycję nie jest 1.  - lub - <paramref name="index" />. Typ nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.Linq.Expressions.Expression" /> wystąpień - indeksów dla operacji indeksowania tablicy.</param>
        <param name="indexes">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowania operatora indeksu tablicy do tablicy wielowymiarowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element obiektu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.  
  
 Jeśli ranga `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.  
  
 Jeśli ranga `array`. Typ jest więcej niż jeden, Metoda ta zwraca <xref:System.Linq.Expressions.MethodCallExpression>. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> , który opisuje metody publiczne wystąpienia `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentująca indeksowanie w dwuwymiarowej tablicy.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie reprezentuje typ tablicy.  - lub - ranga <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie do uzyskania długości tablicy jednowymiarowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicowego.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> jest równa <xref:System.Int32>. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość `null`, a oba <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są ustawione na `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />. Typ nie reprezentuje typ tablicy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operatora przypisania.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Assign` Wyrażenie kopiuje wartości dla typów wartości, a następnie kopiuje odwołań dla typów odwołań.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację przypisania.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowania elementu członkowskiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie ona polem ani właściwością.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być możliwe przypisanie typu reprezentowanego przez <xref:System.Reflection.FieldInfo.FieldType%2A> lub <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.  - lub - właściwość reprezentowana przez <paramref name="member" /> nie ma <see langword="set" /> metody dostępu.  - lub - <paramref name="expression" />. Typ nie jest możliwy do przypisania do typu pola lub właściwości, <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</param>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowania elementu członkowskiego za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> właściwością <paramref name="expression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być możliwe przypisanie typu reprezentowanego przez <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwości właściwości używane w `propertyAccessor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.  - lub - właściwość uzyskują <paramref name="propertyAccessor" /> nie ma <see langword="set" /> metody dostępu.  - lub - <paramref name="expression" />. Typ nie jest możliwy do przypisania do typu pola lub właściwości, <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia bloku. Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób przekazywania parametru do wyrażenia bloku i przetwarza tego parametru, w bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający dwóch wyrażeń, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, nie ma zmiennych, a ma typ konkretnego wyniku.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, nie ma zmiennych, a ma typ konkretnego wyniku.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający trzy wyrażenia, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku bloku.</param>
        <param name="variables">Zmienne w bloku.</param>
        <param name="expressions">Wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenia w bloku.</param>
        <param name="arg3">Czwarty wyrażenia w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający cztery wyrażeń, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">Pierwsze wyrażenie w bloku.</param>
        <param name="arg1">Drugie wyrażenie w bloku.</param>
        <param name="arg2">Trzeci wyrażenia w bloku.</param>
        <param name="arg3">Czwarty wyrażenia w bloku.</param>
        <param name="arg4">Wyrażenie piątej w bloku.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający pięć wyrażeń, a nie ma zmiennych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.LoopExpression> obiektu, który używa <xref:System.Linq.Expressions.Expression.Break%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break. Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem. Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Wystąpienia dla wywołania metody wystąpienia, który określa (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która nie przyjmuje żadnych argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusty. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa zwracany typ metody reprezentowanej przez `method`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, które wywołuje metodę bez argumentów.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  - lub - <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</param>
        <param name="arguments">Kolekcja <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący argumenty wywołania.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody statyczne (Shared w języku Visual Basic).</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, która przyjmuje jeden argument.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia, który wywołuje `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, aby ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`. Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.  - lub - jedno lub więcej elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.  
  
 Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`. Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  - lub - <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.  - lub - liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.  - lub - jedno lub więcej elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Wystąpienia dla wywołania metody wystąpienia, który określa (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.  
  
 Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.  
  
 Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`. Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> jest <see langword="null" />.  - lub - <paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.  - lub - <paramref name="arguments" /> nie <see langword="null" /> i co najmniej jeden z jego elementów jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.  - lub - liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.  - lub - jedno lub więcej elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia. (przekazać wartości null do metody statycznej (Shared w języku Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę wystąpienia, która ma dwa argumenty.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> wartość właściwości ma zostać wyszukany określonej metody.</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiekty, które określają parametry typu metody ogólnej. Ten argument musi mieć wartość null, gdy methodName wskazuje metodę inną niż ogólna.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które reprezentuje argumenty do metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody za pomocą wywołania metody odpowiedniej fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę określone wystąpienie i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.  - lub - więcej niż jedną metodę, której nazwa to <paramref name="methodName" />, których parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje trzy argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który zawiera określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda.</param>
        <param name="methodName">Nazwa metody.</param>
        <param name="typeArguments">Tablica <see cref="T:System.Type" /> obiekty, które określają parametry typu metody ogólnej. Ten argument musi mieć wartość null, gdy methodName wskazuje metodę inną niż ogólna.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty do metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, przez wywołanie metody odpowiedniej fabryki.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwością <see cref="T:System.Reflection.MethodInfo" /> reprezentująca określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość jest ustawiona na określonych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="methodName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żadnej metody o nazwie <paramref name="methodName" />, której parametry typu dopasowania <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="type" /> lub jego typów podstawowych.  - lub - więcej niż jedną metodę, której nazwa to <paramref name="methodName" />, których parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="type" /> lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia. (przekazać wartości null do metody statycznej (Shared w języku Visual Basic)).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje trzy argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje cztery argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</param>
        <param name="arg0">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</param>
        <param name="arg1">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</param>
        <param name="arg2">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</param>
        <param name="arg3">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</param>
        <param name="arg4">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący piątego argumentu.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że węzeł można zmniejszyć do węzła prostsze. Jeśli zostanie zwrócona wartość true, można wywołać Reduce() powodować mniejsze formularza.</summary>
        <value>Wartość true, jeśli węzeł może zostać zmniejszona, w przeciwnym razie wartość false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch w odniesieniu do przechwyconego <see cref="T:System.Exception" /> obiekt do użycia w treści procedury obsługi.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="body">Treść instrukcji catch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> z <xref:System.Exception> wychwycony może być określony, ale brak odwołania do <xref:System.Exception> obiekt będzie dostępny do użytku w <xref:System.Linq.Expressions.CatchBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch <see cref="T:System.Exception" /> filtr i odwołania do przechwyconego <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch <see cref="T:System.Exception" /> filtru, ale brak odwołania do przechwyconego <see cref="T:System.Exception" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> czyszczenia punktu sekwencji.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> dla proces czyszczenia punktu sekwencji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null` i wartościami <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa typ wyniku operacji łączącego. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
#### <a name="result-type"></a>Typ wyniku  
 Następujące reguły określają typ wyniku:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający, typ wyniku jest odpowiednikiem dopuszcza `left`. Typ.  
  
-   W przeciwnym razie, jeśli `right`. Typ jest niejawnie konwertowany na `left`. Typ, typ wyniku jest `left`. Typ.  
  
-   W przeciwnym razie, jeśli dopuszcza wielokrotność `left`. Typ jest niejawnie konwertowany na `right`. Typ, typ wyniku jest `right`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartościowym.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie nawzajem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego, biorąc pod uwagę funkcji konwersji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null` i wartościami <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest taki sam, jak typ wyniku operacji łączącego.  
  
 Następujące reguły określają typ wyniku:  
  
-   Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający, typ wyniku jest odpowiednikiem dopuszcza `left`. Typ.  
  
-   W przeciwnym razie, jeśli `right`. Typ jest niejawnie konwertowany na `left`. Typ, typ wyniku jest `left`. Typ.  
  
-   W przeciwnym razie, jeśli dopuszcza wielokrotność `left`. Typ jest niejawnie konwertowany na `right`. Typ, typ wyniku jest `right`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie nawzajem.  - lub - <paramref name="conversion" /> nie <see langword="null" /> i <paramref name="conversion" />. Typ jest typem delegowanym, który nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartościowym.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość <paramref name="left" /> reprezentuje typ, który nie jest możliwy do przypisania do typu parametru typu delegata <paramref name="conversion" />. Typ.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość <paramref name="right" /> nie równa się typ zwracany typ delegata <paramref name="conversion" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ConditionalExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `ifTrue`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje instrukcji warunkowej. Jeśli pierwszy argument daje w wyniku `true`, drugi argument funkcji jest wykonane; w przeciwnym razie, trzeci argument jest wykonywany.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="test" /> lub <paramref name="ifTrue" /> lub <paramref name="ifFalse" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="test" />. Typ nie jest <see cref="T:System.Boolean" />.  - lub - <paramref name="ifTrue" />. Typ nie jest równa <paramref name="ifFalse" />. Typ.</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia jawne, ujednolicając naukę typ wyniku wyrażenia warunkowego, w przypadkach, gdzie typy `ifTrue` i `ifFalse` wyrażenia nie są takie same. Oba rodzaje `ifTrue` i `ifFalse` musi być niejawnie odwołania można przypisać do typu wyniku. `type` Może być <xref:System.Void>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ConstantExpression> jest taki sam, jak typ `value`. Jeśli `value` jest `null`, <xref:System.Linq.Expressions.Expression.Type%2A> jest równa <xref:System.Object>.  
  
 Do reprezentowania `null`, można również użyć <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> metoda, za pomocą którego możesz jawnie określić typ.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które reprezentuje wartość stałą.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być przydatna do reprezentowania wartości typów dopuszczających wartości null.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje stałą typu dopuszczającego wartość null i ustawić jej wartość na `null`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see langword="null" /> i <paramref name="type" /> nie jest możliwy do przypisania z typu dynamicznego <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia pętli, która używa <xref:System.Linq.Expressions.Expression.Continue%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.  
  
    -   Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` jest typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio zostało zniesione węzła.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.  
  
-   W przeciwnym razie zostało zniesione węzła.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację konwersji typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, dla którego określono implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli metoda nie jest `null`, jest to metoda implementującej. Inny niż void, musi reprezentować `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.  
  
-   W przeciwnym razie, jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.  
  
    -   Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.  
  
-   W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.  - lub - <paramref name="expression" />. Typ nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.  - lub - zwracany typ metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />.  - lub - <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości nie jest równa typu argument lub zwracany typ, odpowiednio, metody, reprezentowane przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody, który odpowiada <paramref name="method" /> znaleziono opisu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.  
  
    -   Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.  
  
-   W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony i dla którego określono implementującej metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`. W przeciwnym razie jest `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli metoda nie jest `null`, jest to metoda implementującej. Inny niż void, musi reprezentować `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.  
  
-   W przeciwnym razie, jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie:  
  
    -   Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.  
  
    -   Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.  
  
#### <a name="lifted-versus-non-lifted"></a>Podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.  
  
-   Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.  
  
-   W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.  - lub - <paramref name="expression" />. Typ nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.  - lub - zwracany typ metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />.  - lub - <paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości nie jest równa typu argument lub zwracany typ, odpowiednio, metody, reprezentowane przez <paramref name="method" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody, który odpowiada <paramref name="method" /> znaleziono opisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</param>
        <param name="startLine">Wiersz start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większa niż 0.</param>
        <param name="startColumn">Kolumna start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większa niż 0.</param>
        <param name="endLine">Wiersz końcowy <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Musi być większy lub równy niż linia rozpoczęcia.</param>
        <param name="endColumn">Kolumna zakończenia <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Jeśli wiersz końcowy jest taki sam jak początek wiersza, musi być większy lub równy niż kolumna rozpoczęcia. W każdym przypadku musi być większa niż 0.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> z określonym zakresem.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wraz z przydzielaniem wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia tego substracts 1 z danej wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wraz z przydzielaniem wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość o określonym typie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość o określonym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje vaule domyślny dla danego typu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest operator dzielenia wstępnie zdefiniowany typ wyniku.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dzielenia wstępnie zdefiniowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, która dzieli dzieli swój pierwszy argument przez drugi argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest operator dzielenia wstępnie zdefiniowany typ wyniku.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dzielenia wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="returnType">Typ wyniku wyrażenia dynamicznego.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, danego <see cref="T:System.Collections.Generic.IEnumerable`1" /> jako drugi argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> Zawierający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametru musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter). Metoda add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiedniego parametru metody add prawdopodobnie po *cytowanie*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metoda, <paramref name="addMethod" /> reprezentuje nie nosi nazwę "Add" (jest uwzględniana wielkość liter).  - lub - metody, która <paramref name="addMethod" /> reprezentuje nie jest metodą wystąpienia.  - lub - <paramref name="arguments" /> nie zawiera taką samą liczbę elementów jako liczba parametrów dla metody, <paramref name="addMethod" /> reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru metody, która <paramref name="addMethod" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, biorąc pod uwagę tablicę wartości, jako drugi argument.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.ElementInit" /> Zawierający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` Parametru musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter). Metoda add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiedniego parametru metody add prawdopodobnie po *cytowanie*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Metody, która reprezentuje addMethod jest nazwane "Add" (jest uwzględniana wielkość liter).  - lub - metoda że reprezentuje addMethod nie jest metodą wystąpienia.  - lub - argumenty nie zawierać taką samą liczbę elementów jako liczba parametrów dla metody tego addMethod reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru metody, która <paramref name="addMethod" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy puste wyrażenie, które ma <see cref="T:System.Void" /> typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puste wyrażenie może służyć w sytuacji, gdy Oczekiwano wyrażenia, ale żadna akcja jest pożądane. Na przykład służy puste wyrażenie jako ostatniego wyrażenia w wyrażeniu bloku. W tym przypadku wyrażenie bloku zwracana wartość jest typu void.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia empty i dodać go do wyrażenia bloku.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora równości <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które sprawdza, czy wartości dwóch argumentów są takie same.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora równości <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane `XOR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku jest wstępnie zdefiniowane `XOR` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację logiczną XOR.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="XOR" /> Operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybrane implementacja metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane `XOR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku jest wstępnie zdefiniowane `XOR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i <see langword="XOR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Aby uzyskać <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), <c>wyrażenie</c> musi być <see langword="null" />.</param>
        <param name="field">
          <see cref="T:System.Reflection.FieldInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość `field`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> jest <see langword="null" />.  - lub - pola, reprezentowane przez <paramref name="field" /> nie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest możliwy do przypisania do pola, reprezentowane przez typ deklarujący <paramref name="field" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera pole o nazwie <c>fieldName</c>. Może to być wartość null w przypadku pola statyczne.</param>
        <param name="fieldName">Nazwa pola można uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola, biorąc pod uwagę nazwę pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.FieldInfo" /> reprezentująca pole wskazywane przez <paramref name="fieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość <xref:System.Reflection.FieldInfo> reprezentująca pole wskazywane przez `fieldName`.  
  
 Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych dla pola, które ma nazwę `fieldName`. Pola publiczne mają pierwszeństwo nad niepublicznych pól. Jeśli zostanie znalezione pasujące pola, ta metoda przekazuje `expression` i <xref:System.Reflection.FieldInfo> reprezentująca to pole do <xref:System.Linq.Expressions.Expression.Field%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="fieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Żadne pole o nazwie <paramref name="fieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Obiekt zawierający pola. Może to być wartość null w przypadku pola statyczne.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający pola.</param>
        <param name="fieldName">Pole ma być uzyskiwany dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica do sixteen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Action" /> typ delegata.</param>
        <summary>Tworzy <see cref="T:System.Type" /> obiekt, który reprezentuje ogólnego <c>elementu System.Action</c> przekazać typ, który zawiera argumenty określonego typu.</summary>
        <returns>Typ <c>elementu System.Action</c> delegata, która przyjmuje argumenty określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, wynikowy <xref:System.Type> obiekt reprezentuje typ skonstruowanego delegata `System.Action<T1,…,Tn>` w języku C# lub `System.Action(Of T1,…,Tn)` w języku Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> zawiera więcej niż szesnastu elementy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Argumenty typu delegata.</param>
        <summary>Pobiera <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> lub <c>elementu System.Action</c> przekazać typ, który zawiera argumenty określonego typu.</summary>
        <returns>Typ delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ostatni argument typu określa zwracany typ delegata. Nie Func lub akcji jest wystarczająco duży, wygeneruje typu niestandardowego delegata.  
  
 Podobnie jak w przypadku Func, ostatni argument jest typem zwracanym. Go może być równa do elementu System.Void wywołują akcje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica jednego do siedemnastu <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Func" /> typ delegata.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> przekazać typ, który zawiera argumenty określonego typu. Ostatni argument typu określa zwracany typ delegata utworzony.</summary>
        <returns>Typ <c>System.Func</c> delegata, która przyjmuje argumenty określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` musi zawierać co najmniej jednego i co najwyżej siedemnastu elementy.  
  
 Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, wynikowy <xref:System.Type> obiekt reprezentuje typ skonstruowanego delegata `System.Func<T1,…,Tn>` w języku C# lub `System.Func(Of T1,…,Tn)` w języku Visual Basic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeArgs" /> zawiera mniej niż jeden lub więcej niż siedemnastu elementów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArgs" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość o określonej wartości i wartości null do przekazania do etykietą docelową po przeskakiwanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.GotoExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do". Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość o określonej wartości, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem. Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego za pomocą <see langword="if" /> instrukcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, właściwości ustawione do określonej wartości. <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość jest ustawiona na wyrażenie domyślne i rodzaju powstałe <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje bloku warunkowego.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</param>
        <param name="ifTrue">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</param>
        <param name="ifFalse">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego za pomocą <see langword="if" /> i <see langword="else" /> instrukcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości. Typ wyniku <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje bloku warunkowego.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększenie wartości wyrażenia o 1.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do następującej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększenie wartości wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększona wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartości obiektu, który jest przekazywany do niego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację przyrostu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do następującej.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zwiększając wartość wyrażenia o 1.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększona wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To wyrażenie będzie działać i nie zmienia wartości obiektu, który jest przekazywany do niego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda do zastosowania.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> delegat lub wyrażenie lambda która odnosi się do listy wyrażenia argumentu.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata, który jest reprezentowany przez `expression`. Typ.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeżeli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy co `arguments` , z wyjątkiem niektórych z tych <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowane*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie reprezentuje typ obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru delegata, reprezentowane przez <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> zawiera taką samą liczbę elementów jak lista parametrów dla delegata, reprezentowane przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda mają być stosowane.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> delegat lub wyrażenie lambda która odnosi się do listy wyrażenia argumentu.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata, który jest reprezentowany przez `expression`. Typ.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeżeli `arguments` jest `null`. W przeciwnym razie zawiera te same elementy co `arguments` , z wyjątkiem niektórych z tych <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowane*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` typu <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie reprezentuje typ obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru delegata, reprezentowane przez <paramref name="expression" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="arguments" /> zawiera taką samą liczbę elementów jak lista parametrów dla delegata, reprezentowane przez <paramref name="expression" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca, czy wyrażenie zwróci wartość false.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <summary>Zwraca, czy wyrażenie zwróci wartość false.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca, czy wyrażenie zwróci wartość false.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca, czy wyrażenie ma wartość true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <summary>Zwraca, czy wyrażenie ma wartość true.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca, czy wyrażenie ma wartość true.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę o typie void i bez nazwy.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.LabelTarget> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Których <see cref="T:System.Linq.Expressions.LabelExpression" /> zostaną skojarzone z.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykiety bez wartości domyślnej.</summary>
        <returns>Element <see cref="T:System.Linq.Expressions.LabelExpression" /> bez wartości domyślnej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę o typie void i podanej nazwie.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.LabelTarget> w wyrażeniu pętli.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> Których <see cref="T:System.Linq.Expressions.LabelExpression" /> zostaną skojarzone z.</param>
        <param name="defaultValue">Wartość tego <see cref="T:System.Linq.Expressions.LabelExpression" /> po osiągnięciu etykiety za pomocą regularnego kontroli przepływu.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykietę z daną wartość domyślną.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> z daną wartość domyślną.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiety.</param>
        <param name="name">Nazwa etykiety.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem i nazwą.</summary>
        <returns>Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy drzewo wyrażenia, który reprezentuje wyrażenie lambda.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` Parametru nie może mieć więcej niż szesnastu elementów.  
  
 Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.  
  
 Ta metoda konstrukcje typu odpowiedniego delegata z jednego z `System.Func` delegatów ogólnych. Następnie przekazuje typ delegata do jednego z <xref:System.Linq.Expressions.ExpressionType.Lambda> metodami factory, aby utworzyć <xref:System.Linq.Expressions.LambdaExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> zawiera więcej niż szesnastu elementy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacje debugowania.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="T:System.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata. Można używać, gdy typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, która ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ obiektu, który jest zwracany z tej funkcji to <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata, reprezentowane przez`delegateType` musi być równa długości argumentu `parameters`.  
  
 Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt jest równa `delegateType`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia, który reprezentuje wyrażenie lambda, która dodaje 1 przekazany argument.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.  - lub - <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu na typ delegata, reprezentowane przez <paramref name="delegateType" />.  - lub - <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata, reprezentowane przez <paramref name="delegateType" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedniego typu parametru na typ delegata, reprezentowane przez <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="T:System.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata. Można używać, gdy typ delegata nie jest znany w czasie kompilacji.</summary>
        <returns>Obiekt, który reprezentuje wyrażenie lambda, która ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ obiektu, który jest zwracany z tej funkcji to <xref:System.Linq.Expressions.Expression%601>. <xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.  
  
 Liczba parametrów dla typu delegata, reprezentowane przez `delegateType` musi być równa długości argumentu `parameters`.  
  
 Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt jest równa `delegateType`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.  - lub - <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu na typ delegata, reprezentowane przez <paramref name="delegateType" />.  - lub - <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata, reprezentowane przez <paramref name="delegateType" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedniego typu parametru na typ delegata, reprezentowane przez <paramref name="delegateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacje debugowania.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacje debugowania.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</param>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do emitowania informacje debugowania.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.  
  
 Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt reprezentuje typ `TDelegate`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> nie jest typem delegowanym.  - lub - <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu <paramref name="TDelegate" />.  - lub - <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla <paramref name="TDelegate" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedni typ parametru <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="parameters">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.  
  
 Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w`body`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt reprezentuje typ `TDelegate`. Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="TDelegate" /> nie jest typem delegowanym.  - lub - <paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu <paramref name="TDelegate" />.  - lub - <paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla <paramref name="TDelegate" />.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedni typ parametru <paramref name="TDelegate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do generowania informacji o debugowaniu.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">Typ delegata.</typeparam>
        <param name="body">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</param>
        <param name="name">Nazwa wyrażenia lambda. Używany do generowania informacji debugowania.</param>
        <param name="tailCall">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</param>
        <param name="parameters">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator przesunięcia w lewo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator przesunięcia w lewo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość umożliwiająca ustawienie <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest ona polem ani właściwością.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.  - lub - <see cref="P:System.Reflection.FieldInfo.FieldType" /> lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość umożliwiająca ustawienie <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest ona polem ani właściwością.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.  - lub - <see cref="P:System.Reflection.FieldInfo.FieldType" /> lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> na podstawie metody dostępu określonej właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.MemberInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.  - lub - <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> właściwości, metody reprezentowanej przez <paramref name="propertyAccessor" /> uzyskuje dostęp do nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu na podstawie określonej właściwości metody dostępu metody.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.MemberInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.  - lub - <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> właściwości, metody reprezentowanej przez <paramref name="propertyAccessor" /> uzyskuje dostęp do nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającego określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty do zainicjowania kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowego wystąpienia słownik za pomocą dwóch par klucz wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> korzystającą metodę o nazwie "Add", aby dodać elementy do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu. Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość pierwszy element `initializers`.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metodę add, które zostało wykryte na `newExpression`. Typ lub jego typ podstawowy.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda instancji o nazwie "Add" (jest uwzględniana wielkość liter) zadeklarowane w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  - lub - metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.  - lub - typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość pierwszy element <paramref name="initializers" /> nie można przypisać do typu argumentu metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  - lub - więcej niż jeden argument zgodną metodę o nazwie "Add" (bez uwzględniania wielkości liter) istnieje na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającego określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty do zainicjowania kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowego wystąpienia słownik za pomocą dwóch par klucz wartość.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> korzystającą metodę o nazwie "Add", aby dodać elementy do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu. Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość pierwszy element `initializers`.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metodę add, które zostało wykryte na `newExpression`. Typ lub jego typ podstawowy.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie istnieje metoda instancji o nazwie "Add" (jest uwzględniana wielkość liter) zadeklarowane w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  - lub - metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.  - lub - typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość pierwszy element <paramref name="initializers" /> nie można przypisać do typu argumentu metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy.  - lub - więcej niż jeden argument zgodną metodę o nazwie "Add" (bez uwzględniania wielkości liter) istnieje na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę instancji o nazwie "Add" (wielkich liter), który dodaje element do kolekcji.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> , używa określonej metody dodawania elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu. Jeśli `addMethod` nie `null`, musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), który ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  - lub - <paramref name="addMethod" /> nie <see langword="null" /> reprezentuje metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.  - lub - <paramref name="addMethod" /> nie <see langword="null" /> i typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody, <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienie nazwane "Add", która przyjmuje jeden argument zgodnego z typem istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia, która przyjmuje jeden argument, który dodaje element do kolekcji.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> , używa określonej metody dodawania elementów do kolekcji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.  
  
 Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu. Jeśli `addMethod` nie `null`, musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), który ma dokładnie jeden parametr. Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.  
  
 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`. <xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`. <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.  - lub - <paramref name="addMethod" /> nie <see langword="null" /> reprezentuje metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.  - lub - <paramref name="addMethod" /> nie <see langword="null" /> i typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody, <paramref name="addMethod" /> reprezentuje.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienie nazwane "Add", która przyjmuje jeden argument zgodnego z typem istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <param name="break">Obiekt docelowy podziału, używane w treści pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> z danym elementem docelowym treści i podziału.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia bloku, zawierającego <xref:System.Linq.Expressions.LoopExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">Treść pętli.</param>
        <param name="break">Obiekt docelowy podziału, używane w treści pętli.</param>
        <param name="continue">Obiekt docelowy Kontynuuj, używane w treści pętli.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> przez wywołanie metody odpowiedniej fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podane lewy i prawy operandów za pomocą wywołania metody odpowiedniej fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki wywołuje tę metodę. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> metodę w celu utworzenia <xref:System.Linq.Expressions.BinaryExpression> reprezentujący odejmowania jedną cyfrę z innego.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> określający implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand i implementacja metody, przez wywołanie metody odpowiedniej fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki, Metoda ta będzie wywoływać. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. `liftToNull` i `method` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</param>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> określający implementującej metody.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> reprezentujący funkcji konwersji typu. Ten parametr jest używany tylko wtedy, gdy <c>binaryType</c> jest <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> lub przydział złożony...</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand, implementacja metody i — typ funkcji konwersji, przez wywołanie metody odpowiedniej fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki, Metoda ta będzie wywoływać. Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>. `liftToNull`, `method` i `conversion` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</param>
        <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</param>
        <param name="body">Treść instrukcji catch.</param>
        <param name="filter">Treść <see cref="T:System.Exception" /> filtru.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcja catch, przy użyciu określonych elementów.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` musi być równa null i jest zgodny z typem `variable` (jeśli go podano).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i jeden argument.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arguments">Argumenty operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i dwa argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i trzy argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
        <param name="binder">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</param>
        <param name="arg0">Pierwszy argument operacji dynamicznej.</param>
        <param name="arg1">Drugi argument operacji dynamicznej.</param>
        <param name="arg2">Trzeci argument operacji dynamicznej.</param>
        <param name="arg3">Czwarty argument operacji dynamicznej.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i cztery argumenty.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind">
          <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> z <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący przeskoku określonego <see cref="T:System.Linq.Expressions.GotoExpressionKind" />. Wartość przekazana do etykiety po przeskakiwanie można również określić.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa <paramref name="kind" />, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do której należy właściwość. Powinna to być wartość null, jeśli właściwość jest <see langword="static" /> (<see langword="shared" /> w języku Visual Basic).</param>
        <param name="indexer">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujące właściwość do indeksu.</param>
        <param name="arguments">
          <c>IEnumerable&lt;wyrażenie&gt; </c> (<c>IEnumerable (programu Expression)</c> w języku Visual Basic) zawiera argumenty, które będą używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentująca dostęp do właściwości indeksowanych w obiekcie.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca obiekt, który należy do elementu członkowskiego. Może to być wartość null dla statycznych elementów członkowskich.</param>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Opisujący pola lub właściwości, które były dostępne.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola lub właściwości.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.MemberExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do tworzenia <xref:System.Linq.Expressions.MemberExpression> reprezentująca dostęp do pola lub właściwości, w zależności od typu `member`. Jeśli `member` typu <xref:System.Reflection.FieldInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Field%2A> utworzyć <xref:System.Linq.Expressions.MemberExpression>. Jeśli `member` typu <xref:System.Reflection.PropertyInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Property%2A> utworzyć <xref:System.Linq.Expressions.MemberExpression>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku wyrażenia try. Jeśli ma wartość null, bodh i całej obsługi muszą mieć identyczne typu.</param>
        <param name="body">Treści bloku try.</param>
        <param name="finally">Treści bloku finally. Należy przekazać wartość null, jeśli blok try ma nie na koniec bloku skojarzonych z nim.</param>
        <param name="fault">Treść bloku błędów. Należy przekazać wartość null, jeśli blok try ma nie bloku błędów skojarzonych z nim.</param>
        <param name="handlers">Kolekcja <see cref="T:System.Linq.Expressions.CatchBlock" />s reprezentujący instrukcji catch, który ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z określonych elementów.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> przez wywołanie metody odpowiedniej fabryki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</param>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument operacji, przez wywołanie metody odpowiedniej fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> metoda fabryki wywołuje tę metodę. Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. `type`Parametr jest ignorowany, jeśli nie ma zastosowania do metody fabryka, która jest wywoływana.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">
          <see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</param>
        <param name="operand">
          <see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</param>
        <param name="type">
          <see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument i implementacja metody, przez wywołanie metody odpowiedniej fabryki.</summary>
        <returns>
          <see cref="T:System.Linq.Expressions.UnaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> metoda fabryki wywołuje tę metodę. Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>. `type` i `method` parametry są ignorowane, jeśli nie mają zastosowania do metody fabryka, która jest wywoływana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="operand" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cyklicznego inicjowanie elementów członkowskich elementu członkowskiego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne inicjowanie elementów członkowskich pola lub właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametru musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.  - lub - <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member">
          <see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne inicjowanie elementów członkowskich pola lub właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` Parametru musi reprezentować pole lub właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="member" /> nie reprezentuje pole lub właściwość.  - lub - <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania cyklicznego elementów członkowskich elementu członkowskiego, która jest dostępna za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.  - lub - <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu właściwości używane przez metodę która <paramref name="propertyAccessor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania cyklicznego elementów członkowskich elementu członkowskiego, która jest dostępna za pomocą metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.  - lub - <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu właściwości używane przez metodę która <paramref name="propertyAccessor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="bindings">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</param>
        <summary>Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje członek typu, <paramref name="newExpression" />. Wpisz reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</param>
        <param name="bindings">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MemberInitExpression> reprezentujący inicjowania dwa elementy członkowskie nowego obiektu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje członek typu, <paramref name="newExpression" />. Wpisz reprezentuje.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator modulo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator modulo wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator modulo wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator modulo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator modulo wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator modulo wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które mnoży dwie wartości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje operację arytmetyczny negacji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  - lub - <paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  - lub - <paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określonego konstruktora, który nie przyjmuje żadnych argumentów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości wynikające <xref:System.Linq.Expressions.NewExpression> są puste kolekcje. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Konstruktor, <paramref name="constructor" /> reprezentuje ma co najmniej jeden parametr.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Element <see cref="T:System.Type" /> ma konstruktora, który nie przyjmuje żadnych argumentów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora bez parametrów dla określonego typu.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwością <see cref="T:System.Reflection.ConstructorInfo" /> reprezentujący konstruktora bez parametrów dla określonego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` Parametru musi reprezentować typ, który ma konstruktora bez parametrów.  
  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości wynikające <xref:System.Linq.Expressions.NewExpression> są puste kolekcje. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest równa `type`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.New%28System.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.NewExpression> reprezentujący tworzenia nowego wystąpienia obiektu słownika przez wywołanie konstruktora bez parametrów.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ, <paramref name="type" /> reprezentuje nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`. Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`. <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pusta kolekcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  - lub - element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`. Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`. <xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pusta kolekcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  - lub - element <paramref name="arguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="arguments" /> jest zgodna z liczbą parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <param name="members">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami. Elementy członkowskie, które uzyskują dostęp do pól Konstruktor inicjowane są określone.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`. Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.  
  
 Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją. Jeśli `members` nie `null`, musi mieć taką samą liczbę elementów jako `arguments` i każdy element nie może być `null`. Każdy element obiektu `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia typu deklarującego konstruktora, reprezentowane przez `constructor`. Jeśli termin reprezentuje właściwości, właściwość musi mieć `get` metody dostępu. Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego, który `members` element reprezentuje.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, `constructor` reprezentuje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  - lub - element <paramref name="arguments" /> jest <see langword="null" />.  - lub - element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <paramref name="members" /> parametr nie ma taką samą liczbę elementów jako <paramref name="arguments" />.  - lub - element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości, który reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego, który jest reprezentowany przez odpowiedni element <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor">
          <see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</param>
        <param name="members">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami. Elementy członkowskie, które uzyskują dostęp do pól Konstruktor inicjowane są określane jako tablica.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`. Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.  
  
 Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją. Jeśli `members` nie `null`, musi mieć taką samą liczbę elementów jako `arguments` i każdy element nie może być `null`. Każdy element obiektu `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia typu deklarującego konstruktora, reprezentowane przez `constructor`. Jeśli termin reprezentuje właściwości, właściwość musi być możliwe do pobrania wartości pól skojarzone. Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego, który `members` element reprezentuje.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, `constructor` reprezentuje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> jest <see langword="null" />.  - lub - element <paramref name="arguments" /> jest <see langword="null" />.  - lub - element <paramref name="members" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.  - lub - <paramref name="members" /> parametr nie ma taką samą liczbę elementów jako <paramref name="arguments" />.  - lub - element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości, który reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego, który jest reprezentowany przez odpowiedni element <paramref name="members" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="bounds">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, w której pozycję jest równa długości `bounds` i którego typ elementu jest `type`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi reprezentować typ całkowitoliczbowy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy ciągów, która ma pozycję 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.  - lub - element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="bounds" /> nie reprezentuje typ całkowitoliczbowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="bounds">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, w której pozycję jest równa długości `bounds` i którego typ elementu jest `type`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi reprezentować typ całkowitoliczbowy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy ciągów, która ma pozycję 2.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.  - lub - element <paramref name="bounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="bounds" /> nie reprezentuje typ całkowitoliczbowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="initializers">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typ, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jego *cytowane*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy której pozycję to 1 i którego typ elementu jest `type`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy jednowymiarowej ciąg, który jest inicjowany za pomocą listy wyrażenia ciągu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwy do przypisania do typu, <paramref name="type" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</param>
        <param name="initializers">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typ, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jego *cytowane*.  
  
> [!NOTE]
>  Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>. Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła. Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.  
  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy której pozycję to 1 i którego typ elementu jest `type`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy jednowymiarowej ciąg, który jest inicjowany za pomocą listy wyrażenia ciągu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.  - lub - element <paramref name="initializers" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwy do przypisania do typu <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ węzła <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <value>Jedną z <see cref="T:System.Linq.Expressions.ExpressionType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość zapewnia bardziej wyspecjalizowane opis <xref:System.Linq.Expressions.Expression> niż po prostu jego typu pochodnego. Na przykład <xref:System.Linq.Expressions.BinaryExpression> może służyć do reprezentowania różnego rodzaju wyrażenia binarne, takie jak operacji dzielenia lub operacją "większe niż". <xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość co opisywałoby, te wyrażenia binarne jako <xref:System.Linq.Expressions.ExpressionType.Divide> i <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, odpowiednio.  
  
 CLR typu statycznego wyrażenia, <xref:System.Linq.Expressions.Expression> reprezentuje obiekt jest reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje jednoargumentowy not operator <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typem liczbowa lub Boolean, metoda implementującej `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ niedopuszczający jest równy argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia, który reprezentuje wartość logiczna nie operacji.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego. Implementowanie metoda może być określona.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje jednoargumentowy not operator <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.  - lub - <paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`. W przeciwnym razie jest `false`. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest <xref:System.Boolean>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="liftToNull">
          <see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest <xref:System.Boolean>.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest <xref:System.Boolean>.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Zwraca wyrażenie odpowiadające te dopełnienia.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które reprezentuje operację logiczne OR.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operator daje w wyniku <see langword="false" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="false" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkową `OR` operator jest obliczane przy użyciu operatora testu koniunkcji `OR` operatora. W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, który reprezentuje wartość logiczna `OR` operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość `false`.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="false" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
    > [!NOTE]
    >  Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic. Jednak warunkową `OR` operator jest obliczane przy użyciu operatora testu koniunkcji `OR` operatora. W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   `left`. Typ i `right`. Typ są tego samego typu Boolean.  
  
-   Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.  
  
-   Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.MethodCallExpression> obiekt, który drukuje wartość <xref:System.Linq.Expressions.ParameterExpression> obiektu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <param name="name">Nazwa parametr lub zmienna, używana do debugowania lub drukowanie tylko do celów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> i <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora potęgowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie zdefiniowano operator potęgowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora potęgowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operatora potęgowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.  - lub - <paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Może to być wartość null dla właściwości statyczne.</param>
        <param name="propertyAccessor">
          <see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości przy użyciu metody dostępu właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Jeśli metoda reprezentowane przez `propertyAccessor` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="propertyAccessor" /> jest <see langword="null" />.  - lub - metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="propertyAccessor" />.  - lub - metoda który <paramref name="propertyAccessor" /> reprezentuje nie jest metoda dostępu właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości. Może to być wartość null dla właściwości statyczne.</param>
        <param name="property">
          <see cref="T:System.Reflection.PropertyInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.  
  
 Jeśli właściwość jest reprezentowane przez `property` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> jest <see langword="null" />.  - lub - właściwości, <paramref name="property" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="expression" />. Typ nie jest możliwy do przypisania do właściwości typ deklarujący, <paramref name="property" /> reprezentuje.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość o nazwie <c>propertyName</c>. Może to być <see langword="null" /> właściwości statycznej.</param>
        <param name="propertyName">Nazwa właściwości, można uzyskać dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwość oznaczona <paramref name="propertyName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Reflection.PropertyInfo> reprezentująca właściwość oznaczona `propertyName`.  
  
 Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych dla właściwości o nazwie `propertyName`. Właściwości publiczne mają pierwszeństwo nad niepublicznych właściwości. Jeśli zostanie znalezione dopasowania właściwości, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> reprezentujący tę właściwość, aby <xref:System.Linq.Expressions.Expression.Property%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do właściwości.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="propertyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie ma właściwości o nazwie <paramref name="propertyName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do której należy właściwość. Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> Reprezentująca właściwość do indeksu.</param>
        <param name="arguments">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do której należy właściwość. Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</param>
        <param name="indexer">
          <see cref="T:System.Reflection.PropertyInfo" /> Reprezentująca właściwość do indeksu.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Obiekt, do której należy właściwość. Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</param>
        <param name="propertyName">Nazwa indeksatora.</param>
        <param name="arguments">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Obiekt zawierający właściwości. Może to być wartość null dla właściwości statyczne.</param>
        <param name="type">
          <see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający właściwości.</param>
        <param name="propertyName">Właściwość, która ma być uzyskiwany dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> uzyskiwania dostępu do właściwości.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość lub pole o nazwie <c>propertyOrFieldName</c>. Może to być wartość null dla statycznych elementów członkowskich.</param>
        <param name="propertyOrFieldName">Nazwa właściwości lub pola, które ma być uzyskiwany dostęp.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości lub pola.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> lub <see cref="T:System.Reflection.FieldInfo" /> reprezentująca właściwość lub pole wskazywane przez <paramref name="propertyOrFieldName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikające <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> lub <xref:System.Reflection.FieldInfo.FieldType%2A> właściwości <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo>, odpowiednio, który reprezentuje właściwość lub pole wskazywane przez `propertyOrFieldName`.  
  
 Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych, właściwość lub pole o nazwie `propertyOrFieldName`. Właściwości publiczne i pola są podane preferencji za pośrednictwem właściwości niepubliczne i pola. Ponadto właściwości mają pierwszeństwo nad polami. Jeśli właściwość lub pole dopasowania zostanie znaleziony, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo> reprezentujący tej właściwości lub pola <xref:System.Linq.Expressions.Expression.Property%2A> lub <xref:System.Linq.Expressions.Expression.Field%2A>, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do właściwości lub pola.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="propertyOrFieldName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Nie właściwości lub pola o nazwie <paramref name="propertyOrFieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie stałej wartości typu <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> reprezentuje zbudowany typ <xref:System.Linq.Expressions.Expression%601>, gdzie argument typu jest typu reprezentowanego przez `expression`. Typ. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość `null`. Zarówno <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza tego węzła w celu prostszego wyrażenia. Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie. Ta metoda może zwrócić inny węzeł, która sama musi zostać obniżona.</summary>
        <returns>Wyrażenie mniejsze.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza tego węzła w celu prostszego wyrażenia. Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie. Ta metoda może zwrócić inny węzeł, która sama musi zostać obniżona.</summary>
        <returns>Wyrażenie mniejsze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od Reduce ta metoda sprawdza, czy niższych węźle spełnia określone invariants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmniejsza wyrażenia na typ węzła znane, (który nie jest węzłem rozszerzenia) lub po prostu zwraca wyrażenie, jeśli nie jest jeszcze znany typ.</summary>
        <returns>Wyrażenie mniejsze.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości odwołań.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie nierówności odwołań.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Nowy <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku z danym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return. Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.Expression.Return%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return z określonym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target">
          <see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</param>
        <param name="value">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</param>
        <param name="type">
          <see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return z określonym typem. Można określić wartość przekazana do etykiety na skok.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora przesunięcia w prawo, <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora przesunięcia w prawo, <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">Kolekcja <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które odejmuje argumentu z pierwszego argumentu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają wybranej metody wykonawcze dla operacji:  
  
-   Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</param>
        <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. W przeciwnym razie są `false`. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.  
  
 Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.  
  
-   W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.  
  
-   W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`:  
  
-   Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione. Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
-   Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła. Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję bez przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego przypadków, jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika bez przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="defaultBody">Wynik o przełącznikiem Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.  
  
 Jeśli `switchValue` nie pasuje do żadnego z przypadków przypadek domyślny, reprezentowane przez `defaultBody` jest uruchamiany.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika, który ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="defaultBody">Wynik o przełącznikiem Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="defaultBody">Wynik o przełącznikiem Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="defaultBody">Wynik o przełącznikiem Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ wyniku przełącznika.</param>
        <param name="switchValue">Wartość, która ma być testowana w każdym przypadku.</param>
        <param name="defaultBody">Wynik o przełącznikiem Jeśli <c>switchValue</c> nie pasuje do żadnego z przypadków.</param>
        <param name="comparison">Metoda porównania równości do użycia.</param>
        <param name="cases">Zestaw przypadków dla tego wyrażenia switch.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny...</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektów, które zostaną użyte w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Treść przypadku.</param>
        <param name="testValues">Wartości testów sprawy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektów, które zostaną użyte w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.  
  
 Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika, który ma przypadek domyślny.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treść przypadku.</param>
        <param name="testValues">Wartości testów sprawy.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> właściwość o określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> właściwości ustawione na określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> właściwości ustawione na określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</param>
        <param name="language">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</param>
        <param name="languageVendor">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</param>
        <param name="documentType">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> równa.</param>
        <summary>Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> właściwości ustawione na określoną wartość.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiektu, który używa <xref:System.Linq.Expressions.Expression.Throw%2A> metody.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Linq.Expressions.Expression" />.</param>
        <param name="type">Nowy <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek z danym typem.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</summary>
        <returns>Tekstowa reprezentacja <see cref="T:System.Linq.Expressions.Expression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treści bloku try.</param>
        <param name="handlers">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch, który ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby catch, instrukcje i ani błędów, ani bloku finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">Treści bloku try.</param>
        <param name="finally">Treści bloku finally.</param>
        <param name="handlers">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch, który ma zostać skojarzony z bloku try.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby instrukcji catch i bloku finally.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch i finally, instrukcja.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treści bloku try.</param>
        <param name="fault">Treść bloku błędów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z blokiem błędów i nie catch, instrukcje.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">Treści bloku try.</param>
        <param name="finally">Treści bloku finally.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący za pomocą bloku try finally blok i nie catch, instrukcje.</summary>
        <returns>Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica obiektów typu, które określają argumenty typu dla typu delegat elementu System.Action.</param>
        <param name="actionType">Po powrocie z tej metody zawiera typ delegat elementu System.Action ogólny, który zawiera argumenty określonego typu. Zawiera wartość null, jeśli nie ogólnego delegat elementu System.Action, który odpowiada <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typ ogólny delegat elementu System.Action, który zawiera argumenty określonego typu.</summary>
        <returns>wartość true, jeśli typ ogólny delegat elementu System.Action został utworzony dla określonej <paramref name="typeArgs" />; wartość false w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">Tablica obiektów typu, które określają argumenty typu dla typu delegata System.Func.</param>
        <param name="funcType">Po powrocie z tej metody zawiera typ delegata System.Func ogólny, który zawiera argumenty określonego typu. Zawiera wartość null, jeśli nie Delegat ogólny System.Func, który odpowiada <c>typeArgs</c>. Ten parametr jest przekazywany jako niezainicjowany.</param>
        <summary>Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typ ogólny delegata System.Func, który zawiera argumenty określonego typu. Ostatni argument typu określa zwracany typ delegata utworzony.</summary>
        <returns>wartość true, jeśli ogólny typ delegata System.Func została utworzona dla konkretnego <paramref name="typeArgs" />; wartość false w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typu statycznego wyrażenia, które to <see cref="T:System.Linq.Expressions.Expression" /> reprezentuje.</summary>
        <value>
          <see cref="T:System.Type" /> Reprezentujący typu statycznego wyrażenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A> Jest typ węzła drzewa wyrażeń, natomiast <xref:System.Linq.Expressions.Expression.Type%2A> reprezentuje wspólnego języka wspólnego (CLR) typu statycznego wyrażenia, który reprezentuje węzeł. Na przykład dwoma węzłami z różnych typów węzłów może mieć takie same <xref:System.Linq.Expressions.Expression.Type%2A>, jak pokazano w poniższym przykładzie kodu.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="type">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawnego odwołania lub konwersja boxing gdzie <see langword="null" /> jest podany, jeśli konwersja nie powiedzie się.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> jest `null`. <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> właściwości są `false`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.UnaryExpression> reprezentujący konwersja odwołania wyrażenia nieprzyjmujące wartości liczby całkowitej. typ dopuszczający wartość null liczby całkowitej.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="T:System.Linq.Expressions.Expression" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> , porównuje tożsamości typu run-time.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> i dla których <see cref="T:System.Linq.Expressions.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione do określonej wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> równa właściwości.</param>
        <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> i dla których <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione do określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> reprezentuje <xref:System.Boolean>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.TypeBinaryExpression> reprezentująca to test typ wartości ciągu przed <xref:System.Int32> typu.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje operator, plus jednoargumentowy <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jednoargumentowy operator plus nie jest zdefiniowany dla <paramref name="expression" />. Typ.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody. <xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła. Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`. Są one w przeciwnym razie wartość false.  
  
#### <a name="implementing-method"></a>Metoda implementująca  
 Następujące reguły określają implementującej metody dla operacji:  
  
-   Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.  
  
-   Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje operator, plus jednoargumentowy <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.  
  
-   W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>Typ węzła oraz węzły podniesione i niepodniesione  
 Jeśli implementującej metody nie jest `null`:  
  
-   Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione. Typ węzła jest typem zwracanym metody wykonawcze.  
  
-   Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:  
  
    -   `expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.  
  
    -   Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.  
  
 Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ. Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione. W przeciwnym razie zostało zniesione węzła.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="expression" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="method" /> jest <see langword="null" /> i Jednoargumentowy operator plus nie jest zdefiniowany dla <paramref name="expression" />. Typ.  - lub - <paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">
          <see cref="T:System.Linq.Expressions.Expression" /> Do rozpakowania.</param>
        <param name="type">Nowy <see cref="T:System.Type" /> wyrażenia.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawne rozpakowywania.</summary>
        <returns>Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ parametr lub zmienna.</param>
        <param name="name">Nazwa parametr lub zmienna. Ta nazwa jest używana do debugowania lub drukowanie tylko do celów.</param>
        <summary>Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</summary>
        <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">Wystąpienie <see cref="T:System.Func`2" />.</param>
        <summary>Zmniejsza węzeł, a następnie wywołuje delegata gości na mniejsze wyrażenia. Metoda zgłasza wyjątek, jeśli węzeł nie jest obniżaniu.</summary>
        <returns>Wyrażenie odwiedzana lub wyrażeniem, które powinny zostać użyte w drzewie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępuje tę metodę, aby zapewnić logikę, aby zapoznać się z węzłów podrzędnych. Typowa implementacja wywołuje obiekt odwiedzający. Odwiedź stronę na każdym z jego elementów podrzędnych, a ewentualne je zmienić, powinna zwrócić nową kopię sam z zmodyfikowane elementy podrzędne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="572416f2fe374dea80fd8d8d2b2642156673f844" /><Meta Name="ms.sourcegitcommit" Value="9802d4c6745a8ae514b26f144fb3969265b224ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/22/2018" /><Meta Name="ms.locfileid" Value="53751664" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="03398-101">Udostępnia klasę bazową, z którego są uzyskiwane klas, które reprezentują węzły drzewa wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="03398-101">Provides the base class from which the classes that represent expression tree nodes are derived.</span></span> <span data-ttu-id="03398-102">Zawiera ona także <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodami factory, aby utworzyć różne typy węzłów.</span><span class="sxs-lookup"><span data-stu-id="03398-102">It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types.</span></span> <span data-ttu-id="03398-103">Jest to <see langword="abstract" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="03398-103">This is an <see langword="abstract" /> class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-104">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-104">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="03398-105">Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-105">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-106">Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-106">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-107">Tworzy nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-107">Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType"><span data-ttu-id="03398-108"><see cref="T:System.Linq.Expressions.ExpressionType" /> By ustawić je jako typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-108">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</span></span></param>
        <param name="type"><span data-ttu-id="03398-109"><see cref="P:System.Linq.Expressions.Expression.Type" /> To <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-109">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="03398-110">Inicjuje nowe wystąpienie klasy <see cref="T:System.Linq.Expressions.Expression" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="03398-110">Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-111">Ten konstruktor jest wywoływana z konstruktorów w klasach pochodnych.</span><span class="sxs-lookup"><span data-stu-id="03398-111">This constructor is called from constructors in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="03398-112">Obiekt odwiedzający można znaleźć w tym węźle za pomocą.</span><span class="sxs-lookup"><span data-stu-id="03398-112">The visitor to visit this node with.</span></span></param>
        <summary><span data-ttu-id="03398-113">Wysyła do konkretnej można znaleźć metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-113">Dispatches to the specific visit method for this node type.</span></span> <span data-ttu-id="03398-114">Na przykład <see cref="T:System.Linq.Expressions.MethodCallExpression" /> wywołania <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span><span class="sxs-lookup"><span data-stu-id="03398-114">For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</span></span></summary>
        <returns><span data-ttu-id="03398-115">Wynik odwiedzający tego węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-115">The result of visiting this node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-116">Ta domyślna implementacja dla <xref:System.Linq.Expressions.ExpressionType.Extension> wywołania węzłów <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-116">This default implementation for <xref:System.Linq.Expressions.ExpressionType.Extension> nodes calls <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span> <span data-ttu-id="03398-117">Przesłonić tę metodę do wywołania do bardziej szczegółowych metody w klasie pochodnej gości z <xref:System.Linq.Expressions.ExpressionVisitor> klasy.</span><span class="sxs-lookup"><span data-stu-id="03398-117">Override this method to call into a more specific method on a derived visitor class of the <xref:System.Linq.Expressions.ExpressionVisitor> class.</span></span> <span data-ttu-id="03398-118">Obsługuje on jednak powinny nadal nieznany odwiedzających, wywołując <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-118">However, it should still support unknown visitors by calling <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-119">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-119">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-120">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-120">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-121">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-121">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-122">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-122">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-123">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-124">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-124">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-125"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-125">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-126">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-126">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-127">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-127">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-128"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-128">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-129">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-129">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-130">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-130">Implementing Method</span></span>  
 <span data-ttu-id="03398-131">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-131">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-132">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-132">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-133">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-133">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-134">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-134">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-135">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-135">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-136">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-136">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-137">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-137">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-138">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-138">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-139">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-139">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-140">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-140">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-141">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-141">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-142">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-142">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-143">Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-143">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="03398-144">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-144">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-145">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-145">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-146">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który dodaje dwie liczby całkowite.</span><span class="sxs-lookup"><span data-stu-id="03398-146">The following code example shows how to create an expression that adds two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-147"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-147"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-148">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-148">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-149">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-149">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-150">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-150">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-151">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-151">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-152">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-152">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</span></span> <span data-ttu-id="03398-153">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-153">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-154">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-155">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-155">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-156"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-156">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-157">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-157">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-158">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-158">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-159"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-159">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-160">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-160">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-161">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-161">Implementing Method</span></span>  
 <span data-ttu-id="03398-162">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-162">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-163">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-163">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-164">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-164">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-165">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-165">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-166">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-166">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-167">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-167">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-168">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-168">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-169">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-169">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-170">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-170">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-171">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-171">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-172">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-172">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-173">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-173">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-174">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-174">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-175">Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-175">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="03398-176">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-176">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-177">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-177">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-178"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-178"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-179"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-179"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-180"><paramref name="method" /> jest <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-180"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-181">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-181">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-182"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-182">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-183"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-183">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-184">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-184">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-185">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-186">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które dodaje wartość do zmiennej całkowitej, a następnie przypisuje wynik operacji do zmiennej.</span><span class="sxs-lookup"><span data-stu-id="03398-186">The following code example shows how to create an expression that adds a value to an integer variable and then assigns the result of the operation to the variable.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-187"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-187">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-188"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-188">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-189">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-189">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-190">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-190">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-191">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-192"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-192">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-193"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-193">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-194">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-194">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-195">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-196">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodatku, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-197">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-198">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-198">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-199"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-199">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-200"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-200">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-201">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-201">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-202">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-203"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-203">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-204"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-205">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-205">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-206">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-208"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-209"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-210">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-211">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-212">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania dodawania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-212">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-213">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-214">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-214">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-215">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-215">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-216">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-216">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-217">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-219">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-219">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-220"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-220">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-221">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-221">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-222">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-222">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-223"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-223">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-224">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-224">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-225">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-225">Implementing Method</span></span>  
 <span data-ttu-id="03398-226">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-226">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-227">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-227">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-228">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-228">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-229">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-229">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-230">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-230">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-231">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-231">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-232">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-232">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-233">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-233">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-234">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-234">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-235">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-235">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-236">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-236">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-237">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-237">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-238">Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-238">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="03398-239">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-239">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-240">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-240">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-241"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-241"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-242">Operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-242">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-243">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-243">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-244">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-244">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-245">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-245">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-246">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację dodawania arytmetyczne, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-246">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</span></span> <span data-ttu-id="03398-247">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-247">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-248">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-249">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-249">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-250"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-250">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-251">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-251">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-252">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-252">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-253"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-253">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-254">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-254">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-255">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-255">Implementing Method</span></span>  
 <span data-ttu-id="03398-256">Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="03398-256">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="03398-257">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-257">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-258">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora dodawania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-258">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the addition operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-259">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-259">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-260">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-260">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-261">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-261">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-262">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-262">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-263">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-263">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-264">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-264">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-265">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-265">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-266">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-266">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-267">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-267">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-268">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-268">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-269">Typ węzła jest typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-269">The type of the node is the result type of the predefined addition operator.</span></span>  
  
-   <span data-ttu-id="03398-270">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-270">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-271">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dodawania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-271">The type of the node is the nullable type that corresponds to the result type of the predefined addition operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-272"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-272"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-273"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-273"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-274"><paramref name="method" /> jest <see langword="null" /> i operator dodawania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-274"><paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-275">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-275">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-276">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-276">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-277">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-277">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-278">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-278">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span></summary>
        <returns><span data-ttu-id="03398-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-279">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-280">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-280">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-281"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-281">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-282">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-282">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-283">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-283">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-284"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-284">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-285">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-285">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-286">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-286">Implementing Method</span></span>  
 <span data-ttu-id="03398-287">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-287">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-288">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-288">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-289">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-289">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-290">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-290">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-291">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-291">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-292">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-292">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-293">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-293">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-294">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-294">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-295">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-295">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-296">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-296">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-297">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-297">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-298">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-298">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-299">Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-299">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="03398-300">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-300">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-301">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-301">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-302">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację logiczne AND na dwóch wartości logiczne.</span><span class="sxs-lookup"><span data-stu-id="03398-302">The following code example shows how to create an expression that represents a logical AND operation on two Boolean values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-303"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-303"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-304">Operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-304">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-305"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-305">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-306"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-306">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-307">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-307">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-308">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="AND" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-308">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</span></span> <span data-ttu-id="03398-309">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-309">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.And" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-310">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-311">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-311">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-312"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-312">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-313">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-313">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-314">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-314">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-315"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-315">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-316">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-316">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-317">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-317">Implementing Method</span></span>  
 <span data-ttu-id="03398-318">Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="03398-318">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="03398-319">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-319">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-320">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-320">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-321">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-321">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-322">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-322">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-323">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-323">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-324">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-324">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-325">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-325">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-326">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-326">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-327">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-327">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-328">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-328">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-329">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-329">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-330">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-330">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-331">Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-331">The type of the node is the result type of the predefined bitwise `AND` operator.</span></span>  
  
-   <span data-ttu-id="03398-332">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-332">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-333">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-333">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-334"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-334"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-335"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-335"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-336"><paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-336"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-337">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="03398-337">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-338">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-338">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-339">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-339">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-340">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="03398-340">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</span></span></summary>
        <returns><span data-ttu-id="03398-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-341">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-342">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-342">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-343"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-343">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-344">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-344">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-345">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-345">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-346"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-346">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-347">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-347">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-348">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-348">Implementing Method</span></span>  
 <span data-ttu-id="03398-349">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-349">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-350">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-350">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="03398-351">Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-351">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="03398-352">Jednak warunkową `AND` operator jest obliczane przy użyciu operatora testu koniunkcji `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-352">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="03398-353">W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-353">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="03398-354">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-354">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-355">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-355">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-356">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-356">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-357">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-357">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-358">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-358">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-359">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-359">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-360">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-360">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-361">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-361">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-362">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-362">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-363">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-363">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="03398-364">Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-364">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-365">Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-365">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="03398-366">Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-366">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="03398-367">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-367">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-368">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, który wykonuje logicznych i operacji na jego dwóch argumentów operacji tylko wtedy, gdy pierwszy operand ma wartość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-368">The following code example shows how to create an expression that performs a logical AND operation on its two operands only if the first operand evaluates to `true`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-369"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-369"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-370">Operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-370">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-371">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-371">-or-</span></span> 
 <span data-ttu-id="03398-372"><paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-372"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-373">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-373">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-374">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-374">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-375">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-375">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-376">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="AND" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy jest to pierwszy argument nie zostanie rozwiązany na wartość true.</span><span class="sxs-lookup"><span data-stu-id="03398-376">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true.</span></span> <span data-ttu-id="03398-377">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-377">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-378">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-379">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-379">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-380"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-380">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-381">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-381">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-382">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-382">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-383"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-383">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-384">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-384">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-385">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-385">Implementing Method</span></span>  
 <span data-ttu-id="03398-386">Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="03398-386">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="03398-387">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-387">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-388">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `AND` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-388">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `AND` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="03398-389">Warunkowe `AND` nie może zostać Przeciążony operator w języku C# lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-389">The conditional `AND` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="03398-390">Jednak warunkową `AND` operator jest obliczane przy użyciu operatora testu koniunkcji `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-390">However, the conditional `AND` operator is evaluated by using the bitwise `AND` operator.</span></span> <span data-ttu-id="03398-391">W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `AND` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-391">Thus, a user-defined overload of the bitwise `AND` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="03398-392">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-392">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-393">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-393">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-394">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-394">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-395">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-395">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-396">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-396">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-397">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-397">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-398">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-398">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-399">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-399">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-400">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-400">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-401">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-401">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="03398-402">Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-402">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-403">Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-403">The type of the node is the result type of the predefined conditional `AND` operator.</span></span>  
  
-   <span data-ttu-id="03398-404">Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-404">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="03398-405">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `AND` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-405">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `AND` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-406"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-406"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-407"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-407"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-408"><paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="AND" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-408"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-409">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-409">-or-</span></span> 
 <span data-ttu-id="03398-410"><paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-410"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-411">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</span><span class="sxs-lookup"><span data-stu-id="03398-411">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-412"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-412">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-413"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-413">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-414">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</span><span class="sxs-lookup"><span data-stu-id="03398-414">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-415">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-416"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-416">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-417"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-417">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-418">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-418">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-419">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</span><span class="sxs-lookup"><span data-stu-id="03398-419">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-420">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-421"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-421">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-422"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-423">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-423">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-424">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-425">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania i.</span><span class="sxs-lookup"><span data-stu-id="03398-425">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-426">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-427">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-427">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-428">Wyrażenie, które reprezentuje tablicę wielowymiarową.</span><span class="sxs-lookup"><span data-stu-id="03398-428">An expression that represents the multidimensional array.</span></span></param>
        <param name="indexes"><span data-ttu-id="03398-429"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierające wyrażenia używane do indeksu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-429">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="03398-430">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> na dostęp do tablicy wielowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="03398-430">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="03398-431">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-431">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-432">Wyrażenie, które reprezentuje tablicę, można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metodę, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-432">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-433">Poniższy przykład kodu pokazuje, jak zmienić wartości elementu w tablicy wielowymiarowej za pomocą `ArrayAccess` metody.</span><span class="sxs-lookup"><span data-stu-id="03398-433">The following code example shows how to change the value of an element in a multidimensional array by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-434">Wyrażenie reprezentujące tablicy do indeksu.</span><span class="sxs-lookup"><span data-stu-id="03398-434">An expression representing the array to index.</span></span></param>
        <param name="indexes"><span data-ttu-id="03398-435">Tablica, która zawiera wyrażenia używane do indeksu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-435">An array that contains expressions used to index the array.</span></span></param>
        <summary><span data-ttu-id="03398-436">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> dostępu do tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-436">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</span></span></summary>
        <returns><span data-ttu-id="03398-437">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-437">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-438">Wyrażenie, które reprezentuje tablicę, można uzyskać za pomocą <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> metodę, lub za pomocą <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> lub <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-438">The expression that represents the array can be obtained by using the <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> method, or through <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> or <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>.</span></span>  
  
 <span data-ttu-id="03398-439">Dla tablic wielowymiarowych, użyj <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="03398-439">For multidimensional arrays, use the <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-440">Poniższy przykład kodu pokazuje, jak zmienić wartości elementu tablicy za pomocą `ArrayAccess` metody.</span><span class="sxs-lookup"><span data-stu-id="03398-440">The following code example shows how to change a value of an array element by using the `ArrayAccess` method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-441">Tworzy <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący zastosowania operatora indeksu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-441">Creates an <see cref="T:System.Linq.Expressions.Expression" /> that represents applying an array index operator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-442"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-442">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</span></span></param>
        <param name="indexes"><span data-ttu-id="03398-443"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-443">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-444">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowanie operatora indeksu tablicy do tablicy o randze więcej niż jeden port.</span><span class="sxs-lookup"><span data-stu-id="03398-444">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</span></span></summary>
        <returns><span data-ttu-id="03398-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-445">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-446">Każdy element obiektu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="03398-446">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="03398-447"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.</span><span class="sxs-lookup"><span data-stu-id="03398-447">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="03398-448">Jeśli ranga `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-448">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="03398-449"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`.</span><span class="sxs-lookup"><span data-stu-id="03398-449">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="03398-450"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-450">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="03398-451">Jeśli ranga `array`. Typ jest więcej niż jeden, Metoda ta zwraca <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-451">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="03398-452"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> , który opisuje metody publiczne wystąpienia `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.</span><span class="sxs-lookup"><span data-stu-id="03398-452">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-453">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentująca indeksowanie w dwuwymiarowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-453">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-454"><paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-454"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-455"><paramref name="array" />. Typ nie reprezentuje typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-455"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="03398-456">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-456">-or-</span></span> 
<span data-ttu-id="03398-457">Ranga <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="03398-457">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="03398-458">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-458">-or-</span></span> 
<span data-ttu-id="03398-459"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</span><span class="sxs-lookup"><span data-stu-id="03398-459">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-460">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-460">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="index"><span data-ttu-id="03398-461">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-461">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-462">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zastosowania operatora indeksu tablicy do tablicy o rzędzie, jeden.</span><span class="sxs-lookup"><span data-stu-id="03398-462">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</span></span></summary>
        <returns><span data-ttu-id="03398-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-463">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-464">`index` musi reprezentować indeksu typu <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="03398-464">`index` must represent an index of type <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="03398-465"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null`, a oba <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-465">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null`, and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="03398-466"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-466">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the element type of `array`.Type.</span></span> <span data-ttu-id="03398-467"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-467">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-468"><paramref name="array" /> lub <paramref name="index" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-468"><paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-469"><paramref name="array" />. Typ nie reprezentuje typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-469"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="03398-470">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-470">-or-</span></span> 
 <span data-ttu-id="03398-471"><paramref name="array" />. Typ reprezentuje typ tablicy, w której pozycję nie jest 1.</span><span class="sxs-lookup"><span data-stu-id="03398-471"><paramref name="array" />.Type represents an array type whose rank is not 1.</span></span>  
  
<span data-ttu-id="03398-472">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-472">-or-</span></span> 
 <span data-ttu-id="03398-473"><paramref name="index" />. Typ nie reprezentuje <see cref="T:System.Int32" /> typu.</span><span class="sxs-lookup"><span data-stu-id="03398-473"><paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-474">Tablica <see cref="T:System.Linq.Expressions.Expression" /> wystąpień - indeksów dla operacji indeksowania tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-474">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</span></span></param>
        <param name="indexes"><span data-ttu-id="03398-475">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-475">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-476">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący zastosowania operatora indeksu tablicy do tablicy wielowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="03398-476">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</span></span></summary>
        <returns><span data-ttu-id="03398-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-477">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-478">Każdy element obiektu `indexes` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="03398-478">Each element of `indexes` must have <xref:System.Linq.Expressions.Expression.Type%2A> equal to <xref:System.Int32>.</span></span> <span data-ttu-id="03398-479"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typem tablicy, której pozycję jest zgodna z liczbą elementów w `indexes`.</span><span class="sxs-lookup"><span data-stu-id="03398-479">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type whose rank matches the number of elements in `indexes`.</span></span>  
  
 <span data-ttu-id="03398-480">Jeśli ranga `array`. Typ ma wartość 1, ta metoda zwraca <xref:System.Linq.Expressions.BinaryExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-480">If the rank of `array`.Type is 1, this method returns a <xref:System.Linq.Expressions.BinaryExpression>.</span></span> <span data-ttu-id="03398-481"><xref:System.Linq.Expressions.BinaryExpression.Left%2A> Właściwość jest ustawiona na `array` i <xref:System.Linq.Expressions.BinaryExpression.Right%2A> właściwość jest ustawiona na pojedynczy element `indexes`.</span><span class="sxs-lookup"><span data-stu-id="03398-481">The <xref:System.Linq.Expressions.BinaryExpression.Left%2A> property is set to `array` and the <xref:System.Linq.Expressions.BinaryExpression.Right%2A> property is set to the single element of `indexes`.</span></span> <span data-ttu-id="03398-482"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość <xref:System.Linq.Expressions.BinaryExpression> reprezentuje typ elementu `array`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-482">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the <xref:System.Linq.Expressions.BinaryExpression> represents the element type of `array`.Type.</span></span>  
  
 <span data-ttu-id="03398-483">Jeśli ranga `array`. Typ jest więcej niż jeden, Metoda ta zwraca <xref:System.Linq.Expressions.MethodCallExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-483">If the rank of `array`.Type is more than one, this method returns a <xref:System.Linq.Expressions.MethodCallExpression>.</span></span> <span data-ttu-id="03398-484"><xref:System.Linq.Expressions.MethodCallExpression.Method%2A> Właściwość jest ustawiona na <xref:System.Reflection.MethodInfo> , który opisuje metody publiczne wystąpienia `Get` na typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `array`.</span><span class="sxs-lookup"><span data-stu-id="03398-484">The <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> property is set to the <xref:System.Reflection.MethodInfo> that describes the public instance method `Get` on the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-485">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MethodCallExpression> reprezentująca indeksowanie w dwuwymiarowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-485">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create a <xref:System.Linq.Expressions.MethodCallExpression> that represents indexing into a two-dimensional array.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-486"><paramref name="array" /> lub <paramref name="indexes" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-486"><paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-487"><paramref name="array" />. Typ nie reprezentuje typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-487"><paramref name="array" />.Type does not represent an array type.</span></span>  
  
<span data-ttu-id="03398-488">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-488">-or-</span></span> 
<span data-ttu-id="03398-489">Ranga <paramref name="array" />. Typ jest niezgodny z liczbą elementów w <paramref name="indexes" />.</span><span class="sxs-lookup"><span data-stu-id="03398-489">The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.</span></span>  
  
<span data-ttu-id="03398-490">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-490">-or-</span></span> 
<span data-ttu-id="03398-491"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="indexes" /> nie reprezentuje <see cref="T:System.Int32" /> typu.</span><span class="sxs-lookup"><span data-stu-id="03398-491">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="03398-492"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-492">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-493">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie do uzyskania długości tablicy jednowymiarowej.</span><span class="sxs-lookup"><span data-stu-id="03398-493">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="03398-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="03398-494">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-495"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `array` musi reprezentować typu tablicowego.</span><span class="sxs-lookup"><span data-stu-id="03398-495">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `array` must represent an array type.</span></span>  
  
 <span data-ttu-id="03398-496"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> jest równa <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="03398-496">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is equal to <xref:System.Int32>.</span></span> <span data-ttu-id="03398-497"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość `null`, a oba <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-497">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`, and both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-498"><paramref name="array" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-498"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-499"><paramref name="array" />. Typ nie reprezentuje typ tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-499"><paramref name="array" />.Type does not represent an array type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-500"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-501"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-502">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operatora przypisania.</span><span class="sxs-lookup"><span data-stu-id="03398-502">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-503">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-504">`Assign` Wyrażenie kopiuje wartości dla typów wartości, a następnie kopiuje odwołań dla typów odwołań.</span><span class="sxs-lookup"><span data-stu-id="03398-504">The `Assign` expression copies a value for value types, and it copies a reference for reference types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-505">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację przypisania.</span><span class="sxs-lookup"><span data-stu-id="03398-505">The following code example shows how to create an expression that represents an assignment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-506">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowania elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="03398-506">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="03398-507">A <see cref="T:System.Reflection.MemberInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-507">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="expression"><span data-ttu-id="03398-508"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-509">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowanie ona polem ani właściwością.</span><span class="sxs-lookup"><span data-stu-id="03398-509">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</span></span></summary>
        <returns><span data-ttu-id="03398-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-510">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-511"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być możliwe przypisanie typu reprezentowanego przez <xref:System.Reflection.FieldInfo.FieldType%2A> lub <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość `member`.</span><span class="sxs-lookup"><span data-stu-id="03398-511">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.FieldInfo.FieldType%2A> or <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of `member`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-512"><paramref name="member" /> lub <paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-512"><paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-513"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-513"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="03398-514">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-514">-or-</span></span> 
<span data-ttu-id="03398-515">Właściwość reprezentowana przez <paramref name="member" /> nie ma <see langword="set" /> metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="03398-515">The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="03398-516">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-516">-or-</span></span> 
 <span data-ttu-id="03398-517"><paramref name="expression" />. Typ nie jest możliwy do przypisania do typu pola lub właściwości, <paramref name="member" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-517"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="03398-518">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-518">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="expression"><span data-ttu-id="03398-519"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-520">Tworzy <see cref="T:System.Linq.Expressions.MemberAssignment" /> reprezentujący inicjowania elementu członkowskiego za pomocą metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-520">Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />i <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> właściwością <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-521">A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-522"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `expression` musi być możliwe przypisanie typu reprezentowanego przez <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwości właściwości używane w `propertyAccessor`.</span><span class="sxs-lookup"><span data-stu-id="03398-522">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `expression` must be assignable to the type represented by the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the property accessed in `propertyAccessor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-523"><paramref name="propertyAccessor" /> lub <paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-523"><paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-524"><paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-524"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="03398-525">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-525">-or-</span></span> 
<span data-ttu-id="03398-526">Właściwość uzyskują <paramref name="propertyAccessor" /> nie ma <see langword="set" /> metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="03398-526">The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.</span></span>  
  
<span data-ttu-id="03398-527">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-527">-or-</span></span> 
 <span data-ttu-id="03398-528"><paramref name="expression" />. Typ nie jest możliwy do przypisania do typu pola lub właściwości, <paramref name="member" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-528"><paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-529">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-529">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="03398-530">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-530">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-531">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-531">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-532">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-532">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-533">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-533">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions"><span data-ttu-id="03398-534">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-534">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-535">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-535">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-536">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-536">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-537">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-537">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-538">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-538">The following code example shows how to create a block expression.</span></span> <span data-ttu-id="03398-539">Wyrażenie bloku składa się z dwóch <xref:System.Linq.Expressions.MethodCallExpression> obiektów i jeden <xref:System.Linq.Expressions.ConstantExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-539">The block expression consists of two <xref:System.Linq.Expressions.MethodCallExpression> objects and one <xref:System.Linq.Expressions.ConstantExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="03398-540">Zmienne w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-540">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-541">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-541">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-542">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="03398-542">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-543">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-543">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-544">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-544">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-545">Poniższy przykład kodu pokazuje sposób przekazywania parametru do wyrażenia bloku i przetwarza tego parametru, w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-545">The following code example shows how to pass a parameter to a block expression and process this parameter within a block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="03398-546">Zmienne w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-546">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-547">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-547">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-548">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="03398-548">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-549">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-549">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-550">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-550">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="03398-551">Pierwsze wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-551">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-552">Drugie wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-552">The second expression in the block.</span></span></param>
        <summary><span data-ttu-id="03398-553">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający dwóch wyrażeń, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-553">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-554">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-554">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-555">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-555">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-556">Typ wyniku bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-556">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-557">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-557">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-558">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, nie ma zmiennych, a ma typ konkretnego wyniku.</span><span class="sxs-lookup"><span data-stu-id="03398-558">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="03398-559">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-559">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-560">Typ wyniku bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-560">The result type of the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-561">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-561">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-562">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający danego wyrażenia, nie ma zmiennych, a ma typ konkretnego wyniku.</span><span class="sxs-lookup"><span data-stu-id="03398-562">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</span></span></summary>
        <returns><span data-ttu-id="03398-563">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-563">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="03398-564">Pierwsze wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-564">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-565">Drugie wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-565">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-566">Trzeci wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-566">The third expression in the block.</span></span></param>
        <summary><span data-ttu-id="03398-567">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający trzy wyrażenia, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-567">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-568">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-568">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-569">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-569">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-570">Typ wyniku bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-570">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="03398-571">Zmienne w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-571">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-572">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-572">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-573">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="03398-573">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-574">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-574">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-575">Typ wyniku bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-575">The result type of the block.</span></span></param>
        <param name="variables"><span data-ttu-id="03398-576">Zmienne w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-576">The variables in the block.</span></span></param>
        <param name="expressions"><span data-ttu-id="03398-577">Wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-577">The expressions in the block.</span></span></param>
        <summary><span data-ttu-id="03398-578">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> zawierający dany zmiennych i wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="03398-578">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-579">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-579">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="03398-580">Pierwsze wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-580">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-581">Drugie wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-581">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-582">Trzeci wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-582">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-583">Czwarty wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-583">The fourth expression in the block.</span></span></param>
        <summary><span data-ttu-id="03398-584">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający cztery wyrażeń, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-584">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-585">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-585">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-586">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-586">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="03398-587">Pierwsze wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-587">The first expression in the block.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-588">Drugie wyrażenie w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-588">The second expression in the block.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-589">Trzeci wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-589">The third expression in the block.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-590">Czwarty wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-590">The fourth expression in the block.</span></span></param>
        <param name="arg4"><span data-ttu-id="03398-591">Wyrażenie piątej w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-591">The fifth expression in the block.</span></span></param>
        <summary><span data-ttu-id="03398-592">Tworzy <see cref="T:System.Linq.Expressions.BlockExpression" /> , zawierający pięć wyrażeń, a nie ma zmiennych.</span><span class="sxs-lookup"><span data-stu-id="03398-592">Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</span></span></summary>
        <returns><span data-ttu-id="03398-593">Utworzony <see cref="T:System.Linq.Expressions.BlockExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-593">The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-594">Po wykonaniu bloku wyrażenie zwraca wartość ostatniego wyrażenia w bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-594">When the block expression is executed, it returns the value of the last expression in the block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-595">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span><span class="sxs-lookup"><span data-stu-id="03398-595">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-596"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-596">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="03398-597">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span><span class="sxs-lookup"><span data-stu-id="03398-597">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span></summary>
        <returns><span data-ttu-id="03398-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-598">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-599">Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.LoopExpression> obiektu, który używa <xref:System.Linq.Expressions.Expression.Break%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="03398-599">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LoopExpression> object that uses the <xref:System.Linq.Expressions.Expression.Break%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-600"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-600">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-601">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-601">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="03398-602">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break.</span><span class="sxs-lookup"><span data-stu-id="03398-602">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</span></span> <span data-ttu-id="03398-603">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-603">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-604">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-605"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-605">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-606"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-606">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-607">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-607">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-608">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-609"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-609">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-610">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-610">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="03398-611"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-611">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-612">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji break z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-612">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</span></span> <span data-ttu-id="03398-613">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-613">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równy podział <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-614">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-615">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-615">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-616"><see cref="T:System.Linq.Expressions.Expression" /> Wystąpienia dla wywołania metody wystąpienia, który określa (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</span><span class="sxs-lookup"><span data-stu-id="03398-616">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="03398-617">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-617">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-618">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która nie przyjmuje żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-618">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-619">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-620">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-620">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method.</span></span>  
  
 <span data-ttu-id="03398-621">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-621">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="03398-622"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusty.</span><span class="sxs-lookup"><span data-stu-id="03398-622">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty.</span></span> <span data-ttu-id="03398-623"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa zwracany typ metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-623">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the return type of the method represented by `method`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-624">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, które wywołuje metodę bez argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-624">The following code example shows how to create an expression that calls a method without arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-625"><paramref name="method" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-625"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-626">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-626">-or-</span></span> 
 <span data-ttu-id="03398-627"><paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-627"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-628"><paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-628"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-629"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</span><span class="sxs-lookup"><span data-stu-id="03398-629">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-630">Kolekcja <see cref="T:System.Linq.Expressions.Expression" /> reprezentujący argumenty wywołania.</span><span class="sxs-lookup"><span data-stu-id="03398-630">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</span></span></param>
        <summary><span data-ttu-id="03398-631">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody statyczne (Shared w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="03398-631">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</span></span></summary>
        <returns><span data-ttu-id="03398-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-632">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-633">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-633">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-634"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-634">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <summary><span data-ttu-id="03398-635">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="03398-635">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</span></span></summary>
        <returns><span data-ttu-id="03398-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-636">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-637">Poniższy przykład przedstawia sposób tworzenia wyrażenia, który wywołuje `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="03398-637">The following example demonstrates how to create an expression that calls a `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-638"><paramref name="method" /> ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="03398-638"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-639">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metodę, aby ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-639">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-640">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-640">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-641">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, która przyjmuje argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-641">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-642">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-643">Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-643">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="03398-644">Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.</span><span class="sxs-lookup"><span data-stu-id="03398-644">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-645">Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-645">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-646">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-646">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-647">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-647">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="03398-648"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-648">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="03398-649">W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.</span><span class="sxs-lookup"><span data-stu-id="03398-649">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="03398-650"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-650">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span> <span data-ttu-id="03398-651"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-651">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-652"><paramref name="method" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-652"><paramref name="method" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-653">Liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-653">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-654">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-654">-or-</span></span> 
<span data-ttu-id="03398-655">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-655">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-656"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</span><span class="sxs-lookup"><span data-stu-id="03398-656">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="03398-657">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-657">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-658"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-659">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-659">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-660">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-661">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="03398-661">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="03398-662">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-662">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="03398-663">Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-663">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="03398-664">Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.</span><span class="sxs-lookup"><span data-stu-id="03398-664">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-665">Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-665">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-666">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-666">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-667">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-667">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="03398-668"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-668">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="03398-669">W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.</span><span class="sxs-lookup"><span data-stu-id="03398-669">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="03398-670"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-670">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-671"><paramref name="method" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-671"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-672">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-672">-or-</span></span> 
 <span data-ttu-id="03398-673"><paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-673"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-674"><paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-674"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-675">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-675">-or-</span></span> 
<span data-ttu-id="03398-676">Liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-676">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-677">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-677">-or-</span></span> 
<span data-ttu-id="03398-678">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-678">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-679"><see cref="T:System.Linq.Expressions.Expression" /> Wystąpienia dla wywołania metody wystąpienia, który określa (przekazać <see langword="null" /> dla <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda).</span><span class="sxs-lookup"><span data-stu-id="03398-679">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="03398-680">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-680">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-681">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-681">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-682">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-682">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-683">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-684">Do reprezentowania wywołanie `static` (`Shared` w języku Visual Basic) metoda, Przekaż `null` dla `instance` parametru, jeśli chcesz wywołać tę metodę, lub zadzwoń <xref:System.Linq.Expressions.Expression.Call%2A> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="03398-684">To represent a call to a `static` (`Shared` in Visual Basic) method, pass in `null` for the `instance` parameter when you call this method, or call <xref:System.Linq.Expressions.Expression.Call%2A> instead.</span></span>  
  
 <span data-ttu-id="03398-685">Jeśli `method` reprezentuje metodę wystąpienia <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `instance` musi być możliwy do przypisania do metody reprezentowanej przez typ deklarujący `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-685">If `method` represents an instance method, the <xref:System.Linq.Expressions.Expression.Type%2A> property of `instance` must be assignable to the declaring type of the method represented by `method`.</span></span>  
  
 <span data-ttu-id="03398-686">Jeśli `arguments` nie `null`, musi mieć taką samą liczbę elementów jako liczba parametrów dla metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-686">If `arguments` is not `null`, it must have the same number of elements as the number of parameters for the method represented by `method`.</span></span> <span data-ttu-id="03398-687">Każdy element w `arguments` nie może być `null` i musi być możliwy do przypisania do odpowiedniego parametru `method`, prawdopodobnie po *cytowanie*.</span><span class="sxs-lookup"><span data-stu-id="03398-687">Each element in `arguments` must not be `null` and must be assignable to the corresponding parameter of `method`, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-688">Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-688">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-689">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-689">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-690">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-690">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
 <span data-ttu-id="03398-691"><xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest pusta Jeżeli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-691">The <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="03398-692">W przeciwnym razie zawiera te same elementy co `arguments`, z których część może być ujmowane w cudzysłów.</span><span class="sxs-lookup"><span data-stu-id="03398-692">Otherwise, it contains the same elements as `arguments`, some of which may be quoted.</span></span>  
  
 <span data-ttu-id="03398-693"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam, jak zwracany typ metody reprezentowanej przez `method`.</span><span class="sxs-lookup"><span data-stu-id="03398-693">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method represented by `method`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-694"><paramref name="method" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-694"><paramref name="method" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-695">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-695">-or-</span></span> 
 <span data-ttu-id="03398-696"><paramref name="instance" /> jest <see langword="null" /> i <paramref name="method" /> reprezentuje metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-696"><paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</span></span>  
  
<span data-ttu-id="03398-697">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-697">-or-</span></span> 
 <span data-ttu-id="03398-698"><paramref name="arguments" /> nie jest <see langword="null" /> i co najmniej jeden z jego elementów jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-698"><paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-699"><paramref name="instance" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-699"><paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-700">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-700">-or-</span></span> 
<span data-ttu-id="03398-701">Liczba elementów w <paramref name="arguments" /> nie równa się liczba parametrów dla metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-701">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-702">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-702">-or-</span></span> 
<span data-ttu-id="03398-703">Co najmniej jeden z elementów <paramref name="arguments" /> nie jest możliwy do przypisania do odpowiedniego parametru do metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-703">One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-704">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-704">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-705"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-705">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-706"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-706">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="03398-707">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje dwa argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-707">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-708">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-709"><paramref name="method" /> ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="03398-709"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-710"><see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-710">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="03398-711">(przekazać wartości null do metody statycznej (Shared w języku Visual Basic)).</span><span class="sxs-lookup"><span data-stu-id="03398-711">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="03398-712"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</span><span class="sxs-lookup"><span data-stu-id="03398-712">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-713"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-713">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-714"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-714">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <summary><span data-ttu-id="03398-715">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody, która przyjmuje dwa argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-715">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-716">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-717">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które wywołuje metodę wystąpienia, która ma dwa argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-717">The following code example shows how to create an expression that calls an instance method that has two arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-718"><see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> wartość właściwości ma zostać wyszukany określonej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-718">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</span></span></param>
        <param name="methodName"><span data-ttu-id="03398-719">Nazwa metody.</span><span class="sxs-lookup"><span data-stu-id="03398-719">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="03398-720">Tablica <see cref="T:System.Type" /> obiekty, które określają parametry typu metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="03398-720">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="03398-721">Ten argument musi mieć wartość null, gdy methodName wskazuje metodę inną niż ogólna.</span><span class="sxs-lookup"><span data-stu-id="03398-721">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-722">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, które reprezentuje argumenty do metody.</span><span class="sxs-lookup"><span data-stu-id="03398-722">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="03398-723">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie do metody za pomocą wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-723">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> równa właściwości <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę określone wystąpienie i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> równa określonych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-724">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-725"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.</span><span class="sxs-lookup"><span data-stu-id="03398-725">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-726"><paramref name="instance" /> lub <paramref name="methodName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-726"><paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-727">Brak metody o nazwie <paramref name="methodName" />, którego parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-727">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span>  
  
<span data-ttu-id="03398-728">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-728">-or-</span></span> 
<span data-ttu-id="03398-729">Więcej niż jedną metodę, której nazwa to <paramref name="methodName" />, których parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="instance" />. Typ lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-729">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-730">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-730">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-731"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-731">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-732"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-732">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-733"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span><span class="sxs-lookup"><span data-stu-id="03398-733">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="03398-734">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje trzy argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-734">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-735">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-736"><paramref name="method" /> ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="03398-736"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-737">Typ, który zawiera określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda.</span><span class="sxs-lookup"><span data-stu-id="03398-737">The type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</span></span></param>
        <param name="methodName"><span data-ttu-id="03398-738">Nazwa metody.</span><span class="sxs-lookup"><span data-stu-id="03398-738">The name of the method.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="03398-739">Tablica <see cref="T:System.Type" /> obiekty, które określają parametry typu metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="03398-739">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method.</span></span> <span data-ttu-id="03398-740">Ten argument musi mieć wartość null, gdy methodName wskazuje metodę inną niż ogólna.</span><span class="sxs-lookup"><span data-stu-id="03398-740">This argument should be null when methodName specifies a non-generic method.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-741">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty do metody.</span><span class="sxs-lookup"><span data-stu-id="03398-741">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</span></span></param>
        <summary><span data-ttu-id="03398-742">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda, przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-742">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> właściwością <see cref="T:System.Reflection.MethodInfo" /> reprezentująca określony <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) metoda i <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> Właściwość jest ustawiona na określonych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-743">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-744"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MethodCallExpression> jest taki sam zwracany typ metody wskazywane przez `methodName`.</span><span class="sxs-lookup"><span data-stu-id="03398-744">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MethodCallExpression> is equal to the return type of the method denoted by `methodName`.</span></span> <span data-ttu-id="03398-745"><xref:System.Linq.Expressions.MethodCallExpression.Object%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-745">The <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> property is `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-746"><paramref name="type" /> lub <paramref name="methodName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-746"><paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-747">Żadnej metody o nazwie <paramref name="methodName" />, której parametry typu dopasowania <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="type" /> lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-747">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span>  
  
<span data-ttu-id="03398-748">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-748">-or-</span></span> 
<span data-ttu-id="03398-749">Więcej niż jedną metodę, której nazwa to <paramref name="methodName" />, których parametry typu są zgodne <paramref name="typeArguments" />, i której parametr typy dopasowanie <paramref name="arguments" /> znajduje się w <paramref name="type" /> lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-749">More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-750"><see cref="T:System.Linq.Expressions.Expression" /> , Który określa wystąpienie dla wywołania wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-750">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call.</span></span> <span data-ttu-id="03398-751">(przekazać wartości null do metody statycznej (Shared w języku Visual Basic)).</span><span class="sxs-lookup"><span data-stu-id="03398-751">(pass null for a static (Shared in Visual Basic) method).</span></span></param>
        <param name="method"><span data-ttu-id="03398-752"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metodę docelową.</span><span class="sxs-lookup"><span data-stu-id="03398-752">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-753"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-753">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-754"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-754">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-755"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span><span class="sxs-lookup"><span data-stu-id="03398-755">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <summary><span data-ttu-id="03398-756">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody, która przyjmuje trzy argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-756">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-757">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-758">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-758">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-759"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-759">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-760"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-760">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-761"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span><span class="sxs-lookup"><span data-stu-id="03398-761">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-762"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</span><span class="sxs-lookup"><span data-stu-id="03398-762">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <summary><span data-ttu-id="03398-763">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje cztery argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-763">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-764">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-765"><paramref name="method" /> ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="03398-765"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="03398-766">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-766">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-767"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="03398-767">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-768"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-768">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-769"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący trzeci argument.</span><span class="sxs-lookup"><span data-stu-id="03398-769">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-770"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący czwarty argument.</span><span class="sxs-lookup"><span data-stu-id="03398-770">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</span></span></param>
        <param name="arg4"><span data-ttu-id="03398-771"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący piątego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-771">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</span></span></param>
        <summary><span data-ttu-id="03398-772">Tworzy <see cref="T:System.Linq.Expressions.MethodCallExpression" /> reprezentujący wywołanie metody statycznej, która przyjmuje argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-772">Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> i <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-773">A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-774"><paramref name="method" /> ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="03398-774"><paramref name="method" /> is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="03398-775">Wskazuje, że węzeł można zmniejszyć do węzła prostsze.</span><span class="sxs-lookup"><span data-stu-id="03398-775">Indicates that the node can be reduced to a simpler node.</span></span> <span data-ttu-id="03398-776">Jeśli zostanie zwrócona wartość true, można wywołać Reduce() powodować mniejsze formularza.</span><span class="sxs-lookup"><span data-stu-id="03398-776">If this returns true, Reduce() can be called to produce the reduced form.</span></span></summary>
        <value><span data-ttu-id="03398-777"><see langword="true" /> Jeśli węzeł można zmniejszyć; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-777"><see langword="true" /> if the node can be reduced; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-778">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</span><span class="sxs-lookup"><span data-stu-id="03398-778">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="03398-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span><span class="sxs-lookup"><span data-stu-id="03398-779">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="03398-780">Treść instrukcji catch.</span><span class="sxs-lookup"><span data-stu-id="03398-780">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="03398-781">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch w odniesieniu do przechwyconego <see cref="T:System.Exception" /> obiekt do użycia w treści procedury obsługi.</span><span class="sxs-lookup"><span data-stu-id="03398-781">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</span></span></summary>
        <returns><span data-ttu-id="03398-782">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span><span class="sxs-lookup"><span data-stu-id="03398-782">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-783"><see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span><span class="sxs-lookup"><span data-stu-id="03398-783">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="03398-784">Treść instrukcji catch.</span><span class="sxs-lookup"><span data-stu-id="03398-784">The body of the catch statement.</span></span></param>
        <summary><span data-ttu-id="03398-785">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch.</span><span class="sxs-lookup"><span data-stu-id="03398-785">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</span></span></summary>
        <returns><span data-ttu-id="03398-786">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span><span class="sxs-lookup"><span data-stu-id="03398-786">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-787"><xref:System.Linq.Expressions.Expression.Type%2A> z <xref:System.Exception> wychwycony może być określony, ale brak odwołania do <xref:System.Exception> obiekt będzie dostępny do użytku w <xref:System.Linq.Expressions.CatchBlock>.</span><span class="sxs-lookup"><span data-stu-id="03398-787">The <xref:System.Linq.Expressions.Expression.Type%2A> of <xref:System.Exception> to be caught can be specified but no reference to the <xref:System.Exception> object will be available for use in the <xref:System.Linq.Expressions.CatchBlock>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable"><span data-ttu-id="03398-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span><span class="sxs-lookup"><span data-stu-id="03398-788">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="03398-789">Treść instrukcji catch.</span><span class="sxs-lookup"><span data-stu-id="03398-789">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="03398-790">Treść <see cref="T:System.Exception" /> filtru.</span><span class="sxs-lookup"><span data-stu-id="03398-790">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="03398-791">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch <see cref="T:System.Exception" /> filtr i odwołania do przechwyconego <see cref="T:System.Exception" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-791">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="03398-792">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span><span class="sxs-lookup"><span data-stu-id="03398-792">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-793"><see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span><span class="sxs-lookup"><span data-stu-id="03398-793">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="body"><span data-ttu-id="03398-794">Treść instrukcji catch.</span><span class="sxs-lookup"><span data-stu-id="03398-794">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="03398-795">Treść <see cref="T:System.Exception" /> filtru.</span><span class="sxs-lookup"><span data-stu-id="03398-795">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="03398-796">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcję catch <see cref="T:System.Exception" /> filtru, ale brak odwołania do przechwyconego <see cref="T:System.Exception" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-796">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</span></span></summary>
        <returns><span data-ttu-id="03398-797">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span><span class="sxs-lookup"><span data-stu-id="03398-797">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="03398-798"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</span><span class="sxs-lookup"><span data-stu-id="03398-798">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <summary><span data-ttu-id="03398-799">Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> czyszczenia punktu sekwencji.</span><span class="sxs-lookup"><span data-stu-id="03398-799">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</span></span></summary>
        <returns><span data-ttu-id="03398-800">Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> dla proces czyszczenia punktu sekwencji.</span><span class="sxs-lookup"><span data-stu-id="03398-800">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-801">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego.</span><span class="sxs-lookup"><span data-stu-id="03398-801">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-802"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-802">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-803"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-803">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-804">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego.</span><span class="sxs-lookup"><span data-stu-id="03398-804">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</span></span></summary>
        <returns><span data-ttu-id="03398-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-805">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-806"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null` i wartościami <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-806">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span> <span data-ttu-id="03398-807"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest równa typ wyniku operacji łączącego.</span><span class="sxs-lookup"><span data-stu-id="03398-807">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to the result type of the coalescing operation.</span></span> <span data-ttu-id="03398-808"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-808">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
#### <a name="result-type"></a><span data-ttu-id="03398-809">Typ wyniku</span><span class="sxs-lookup"><span data-stu-id="03398-809">Result Type</span></span>  
 <span data-ttu-id="03398-810">Następujące reguły określają typ wyniku:</span><span class="sxs-lookup"><span data-stu-id="03398-810">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="03398-811">Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający, typ wyniku jest odpowiednikiem dopuszcza `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-811">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="03398-812">W przeciwnym razie, jeśli `right`. Typ jest niejawnie konwertowany na `left`. Typ, typ wyniku jest `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-812">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="03398-813">W przeciwnym razie, jeśli dopuszcza wielokrotność `left`. Typ jest niejawnie konwertowany na `right`. Typ, typ wyniku jest `right`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-813">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-814"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-814"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-815"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartościowym.</span><span class="sxs-lookup"><span data-stu-id="03398-815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-816"><paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="03398-816"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132"><span data-ttu-id="03398-817">??</span><span class="sxs-lookup"><span data-stu-id="03398-817">??</span></span> <span data-ttu-id="03398-818">Operator (odwołanie w C#)</span><span class="sxs-lookup"><span data-stu-id="03398-818">Operator (C# Reference)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-819"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-819">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-820"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-820">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-821">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-822">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację łączącego, biorąc pod uwagę funkcji konwersji.</span><span class="sxs-lookup"><span data-stu-id="03398-822">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</span></span></summary>
        <returns><span data-ttu-id="03398-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-823">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-824"><xref:System.Linq.Expressions.BinaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest `null` i wartościami <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> są ustawione na `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-824">The <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is `null` and both <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> are set to `false`.</span></span>  
  
 <span data-ttu-id="03398-825"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.BinaryExpression> jest taki sam, jak typ wyniku operacji łączącego.</span><span class="sxs-lookup"><span data-stu-id="03398-825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.BinaryExpression> is equal to the result type of the coalescing operation.</span></span>  
  
 <span data-ttu-id="03398-826">Następujące reguły określają typ wyniku:</span><span class="sxs-lookup"><span data-stu-id="03398-826">The following rules determine the result type:</span></span>  
  
-   <span data-ttu-id="03398-827">Jeśli `left`. Typ reprezentuje typ dopuszczający wartość null i `right`. Typ jest niejawnie konwertowany na odpowiedni typ niedopuszczający, typ wyniku jest odpowiednikiem dopuszcza `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-827">If `left`.Type represents a nullable type and `right`.Type is implicitly convertible to the corresponding non-nullable type, the result type is the non-nullable equivalent of `left`.Type.</span></span>  
  
-   <span data-ttu-id="03398-828">W przeciwnym razie, jeśli `right`. Typ jest niejawnie konwertowany na `left`. Typ, typ wyniku jest `left`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-828">Otherwise, if `right`.Type is implicitly convertible to `left`.Type, the result type is `left`.Type.</span></span>  
  
-   <span data-ttu-id="03398-829">W przeciwnym razie, jeśli dopuszcza wielokrotność `left`. Typ jest niejawnie konwertowany na `right`. Typ, typ wyniku jest `right`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-829">Otherwise, if the non-nullable equivalent of `left`.Type is implicitly convertible to `right`.Type, the result type is `right`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-830"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-830"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-831"><paramref name="left" />. Typ i <paramref name="right" />. Typ nie są konwertowane na siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="03398-831"><paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</span></span>  
  
<span data-ttu-id="03398-832">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-832">-or-</span></span> 
 <span data-ttu-id="03398-833"><paramref name="conversion" /> nie jest <see langword="null" /> i <paramref name="conversion" />. Typ jest typem delegowanym, który nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-833"><paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-834"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> nie reprezentuje typem referencyjnym lub typem wartościowym.</span><span class="sxs-lookup"><span data-stu-id="03398-834">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</span></span>  
  
<span data-ttu-id="03398-835">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-835">-or-</span></span> 
<span data-ttu-id="03398-836"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="left" /> reprezentuje typ, który nie jest możliwy do przypisania do typu parametru typu delegata <paramref name="conversion" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-836">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.</span></span>  
  
<span data-ttu-id="03398-837">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-837">-or-</span></span> 
<span data-ttu-id="03398-838"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość <paramref name="right" /> nie równa się typ zwracany typ delegata <paramref name="conversion" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-838">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-839">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span><span class="sxs-lookup"><span data-stu-id="03398-839">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="03398-840"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-840">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="03398-841"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-841">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="03398-842"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-842">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-843">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span><span class="sxs-lookup"><span data-stu-id="03398-843">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="03398-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-844">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-845"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ConditionalExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `ifTrue`.</span><span class="sxs-lookup"><span data-stu-id="03398-845">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConditionalExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `ifTrue`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-846">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje instrukcji warunkowej.</span><span class="sxs-lookup"><span data-stu-id="03398-846">The following code example shows how to create an expression that represents a conditional statement.</span></span> <span data-ttu-id="03398-847">Jeśli pierwszy argument daje w wyniku `true`, drugi argument funkcji jest wykonane; w przeciwnym razie, trzeci argument jest wykonywany.</span><span class="sxs-lookup"><span data-stu-id="03398-847">If the first argument evaluates to `true`, the second argument is executed; otherwise, the third argument is executed.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-848"><paramref name="test" /> lub <paramref name="ifTrue" /> lub <paramref name="ifFalse" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-848"><paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-849"><paramref name="test" />. Typ nie jest <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="03398-849"><paramref name="test" />.Type is not <see cref="T:System.Boolean" />.</span></span>  
  
<span data-ttu-id="03398-850">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-850">-or-</span></span> 
 <span data-ttu-id="03398-851"><paramref name="ifTrue" />. Typ nie jest równa <paramref name="ifFalse" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-851"><paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</span></span></exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="03398-852"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="03398-853"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-853">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="03398-854"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-854">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-855">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-856">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący instrukcji warunkowej.</span><span class="sxs-lookup"><span data-stu-id="03398-856">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</span></span></summary>
        <returns><span data-ttu-id="03398-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-857">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-858">Ta metoda umożliwia jawne, ujednolicając naukę typ wyniku wyrażenia warunkowego, w przypadkach, gdzie typy `ifTrue` i `ifFalse` wyrażenia nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="03398-858">This method allows explicitly unifying the result type of the conditional expression in cases where the types of `ifTrue` and `ifFalse` expressions are not equal.</span></span> <span data-ttu-id="03398-859">Oba rodzaje `ifTrue` i `ifFalse` musi być niejawnie odwołania można przypisać do typu wyniku.</span><span class="sxs-lookup"><span data-stu-id="03398-859">Types of both `ifTrue` and `ifFalse` must be implicitly reference assignable to the result type.</span></span> <span data-ttu-id="03398-860">`type` Może być <xref:System.Void>.</span><span class="sxs-lookup"><span data-stu-id="03398-860">The `type` is allowed to be <xref:System.Void>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-861">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-861">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="03398-862"><see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-862">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-863">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-863">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></summary>
        <returns><span data-ttu-id="03398-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-864">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-865"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ConstantExpression> jest taki sam, jak typ `value`.</span><span class="sxs-lookup"><span data-stu-id="03398-865">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ConstantExpression> is equal to the type of `value`.</span></span> <span data-ttu-id="03398-866">Jeśli `value` jest `null`, <xref:System.Linq.Expressions.Expression.Type%2A> jest równa <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="03398-866">If `value` is `null`, <xref:System.Linq.Expressions.Expression.Type%2A> is equal to <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="03398-867">Do reprezentowania `null`, można również użyć <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> metoda, za pomocą którego możesz jawnie określić typ.</span><span class="sxs-lookup"><span data-stu-id="03398-867">To represent `null`, you can also use the <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> method, with which you can explicitly specify the type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-868">W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które reprezentuje wartość stałą.</span><span class="sxs-lookup"><span data-stu-id="03398-868">The following code example shows how to create an expression that represents a constant value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="03398-869"><see cref="T:System.Object" /> Można ustawić <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-869">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-870">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-870">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-871">Tworzy <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-871">Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></summary>
        <returns><span data-ttu-id="03398-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> i <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-872">A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-873">Ta metoda może być przydatna do reprezentowania wartości typów dopuszczających wartości null.</span><span class="sxs-lookup"><span data-stu-id="03398-873">This method can be useful for representing values of nullable types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-874">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje stałą typu dopuszczającego wartość null i ustawić jej wartość na `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-874">The following code example shows how to create an expression that represents a constant of the nullable type and set its value to `null`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-875"><paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-875"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-876"><paramref name="value" /> nie jest <see langword="null" /> i <paramref name="type" /> nie jest możliwy do przypisania z typu dynamicznego <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="03398-876"><paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-877">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</span><span class="sxs-lookup"><span data-stu-id="03398-877">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-878"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-878">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="03398-879">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue.</span><span class="sxs-lookup"><span data-stu-id="03398-879">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</span></span></summary>
        <returns><span data-ttu-id="03398-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-880">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-881">Poniższy przykład przedstawia sposób tworzenia wyrażenia pętli, która używa <xref:System.Linq.Expressions.Expression.Continue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="03398-881">The following example demonstrates how to create a loop expression that uses the <xref:System.Linq.Expressions.Expression.Continue%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-882"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-882">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-883"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-883">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-884">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji continue z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-884">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-885">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-886">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</span><span class="sxs-lookup"><span data-stu-id="03398-886">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-887"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-887">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-888">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-888">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-889">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji typu.</span><span class="sxs-lookup"><span data-stu-id="03398-889">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</span></span></summary>
        <returns><span data-ttu-id="03398-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-890">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-891"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-891">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-892"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-892">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="03398-893">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-893">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="03398-894">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-894">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-895">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-895">Implementing Method</span></span>  
 <span data-ttu-id="03398-896">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-896">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-897">Jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-897">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-898">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="03398-898">Otherwise:</span></span>  
  
    -   <span data-ttu-id="03398-899">Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-899">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="03398-900">Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-900">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="03398-901">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-901">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-902">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-902">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-903">Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-903">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-904">Jeśli jeden lub oba z `expression`. Typ lub `type` jest typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-904">If one or both of `expression`.Type or `type` is a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="03398-905">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-905">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-906">Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-906">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-907">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-907">Otherwise the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-908">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację konwersji typu.</span><span class="sxs-lookup"><span data-stu-id="03398-908">The following code example shows how to create an expression that represents a type convertion operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-909"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-909"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-910">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-910">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-911"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-911">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-912">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-912">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-913">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-913">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-914">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, dla którego określono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-914">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="03398-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-915">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-916"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-916">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-917"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-917">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="03398-918">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-918">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="03398-919">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-919">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-920">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-920">Implementing Method</span></span>  
 <span data-ttu-id="03398-921">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-921">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-922">Jeśli metoda nie jest `null`, jest to metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-922">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="03398-923">Inny niż void, musi reprezentować `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="03398-923">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="03398-924">W przeciwnym razie, jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-924">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-925">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="03398-925">Otherwise:</span></span>  
  
    -   <span data-ttu-id="03398-926">Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-926">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="03398-927">Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-927">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="03398-928">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-928">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-929">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-929">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-930">Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-930">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-931">Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-931">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="03398-932">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-932">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-933">Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-933">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-934">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-934">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-935"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-935"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-936"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-936"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-937">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-937">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="03398-938">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-938">-or-</span></span> 
 <span data-ttu-id="03398-939"><paramref name="expression" />. Typ nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-939"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-940">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-940">-or-</span></span> 
<span data-ttu-id="03398-941">Zwracany typ metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-941">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="03398-942">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-942">-or-</span></span> 
 <span data-ttu-id="03398-943"><paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości nie jest równa typu argument lub zwracany typ, odpowiednio, metody, reprezentowane przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-943"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="03398-944">Więcej niż jednej metody, który odpowiada <paramref name="method" /> znaleziono opisu.</span><span class="sxs-lookup"><span data-stu-id="03398-944">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-945">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony.</span><span class="sxs-lookup"><span data-stu-id="03398-945">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-946"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-947">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-947">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-948">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony.</span><span class="sxs-lookup"><span data-stu-id="03398-948">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</span></span></summary>
        <returns><span data-ttu-id="03398-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-949">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-950"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-950">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-951"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-951">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="03398-952">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-952">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="03398-953">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-953">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-954">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-954">Implementing Method</span></span>  
 <span data-ttu-id="03398-955">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-955">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-956">Jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-956">If either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-957">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="03398-957">Otherwise:</span></span>  
  
    -   <span data-ttu-id="03398-958">Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-958">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="03398-959">Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-959">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="03398-960">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-960">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-961">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-962">Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-962">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-963">Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-963">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="03398-964">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-964">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-965">Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-965">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-966">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-966">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-967"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-967"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-968">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-968">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-969"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-969">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-970">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-970">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-971">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-971">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-972">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację konwersji, która zgłosiła wyjątek, jeśli typ docelowy jest przepełniony i dla którego określono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-972">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</span></span></summary>
        <returns><span data-ttu-id="03398-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-973">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-974"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-974">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-975"><xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-975">The <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> property is `false`.</span></span> <span data-ttu-id="03398-976">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-976">If the node is lifted, <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> is `true`.</span></span> <span data-ttu-id="03398-977">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-977">Otherwise, it is `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-978">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-978">Implementing Method</span></span>  
 <span data-ttu-id="03398-979">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-979">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-980">Jeśli metoda nie jest `null`, jest to metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-980">If method is not `null`, it is the implementing method.</span></span> <span data-ttu-id="03398-981">Inny niż void, musi reprezentować `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument.</span><span class="sxs-lookup"><span data-stu-id="03398-981">It must represent a non-void, `static` (`Shared` in Visual Basic) method that takes one argument.</span></span>  
  
-   <span data-ttu-id="03398-982">W przeciwnym razie, jeśli `expression`. Typ lub `type` jest typ zdefiniowany przez użytkownika, który definiuje operator jawnych lub niejawnych konwersji <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-982">Otherwise, if either `expression`.Type or `type` is a user-defined type that defines an implicit or explicit conversion operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-983">W przeciwnym razie:</span><span class="sxs-lookup"><span data-stu-id="03398-983">Otherwise:</span></span>  
  
    -   <span data-ttu-id="03398-984">Jeśli oba `expression`. Typ i `type` reprezentują typy liczbowa lub Boolean lub Typy wyliczeniowe dopuszczającego wartość null lub wartość null, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-984">If both `expression`.Type and `type` represent numeric or Boolean types, or nullable or non-nullable enumeration types, the implementing method is `null`.</span></span>  
  
    -   <span data-ttu-id="03398-985">Jeśli `expression`. Typ lub `type` jest typem odwołania i jawne pakowanie, rozpakowywanie lub istnieje konwersja odwołania z `expression`. Wpisz, aby `type`, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-985">If either `expression`.Type or `type` is a reference type and an explicit boxing, unboxing, or reference conversion exists from `expression`.Type to `type`, the implementing method is `null`.</span></span>  
  
#### <a name="lifted-versus-non-lifted"></a><span data-ttu-id="03398-986">Podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-986">Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-987">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-987">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-988">Jeśli `expression`. Typ jest można przypisać do typu argumentu metody wykonawcze i typ zwracany metody wykonawcze to można przypisać do `type`, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-988">If `expression`.Type is assignable to the argument type of the implementing method and the return type of the implementing method is assignable to `type`, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-989">Jeśli jeden lub oba z `expression`. Typ lub `type` będące typem wartościowym i odpowiednie typy wartości nie przyjmujące wartości są równe typ argumentu oraz zwracany typ metody wykonawcze odpowiednio, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-989">If either or both of `expression`.Type or `type` are a nullable value type and the corresponding non-nullable value types are equal to the argument type and the return type of the implementing method respectively, the node is lifted.</span></span>  
  
 <span data-ttu-id="03398-990">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-990">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-991">Jeśli oba `expression`. Typ i `type` czy innych niż null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-991">If both `expression`.Type and `type` are non-nullable, the node is not lifted.</span></span>  
  
-   <span data-ttu-id="03398-992">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-992">Otherwise the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-993"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-993"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-994"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-994"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-995">Żaden operator konwersji jest zdefiniowane między <paramref name="expression" />. Typ i <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-995">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</span></span>  
  
<span data-ttu-id="03398-996">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-996">-or-</span></span> 
 <span data-ttu-id="03398-997"><paramref name="expression" />. Typ nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-997"><paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span>  
  
<span data-ttu-id="03398-998">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-998">-or-</span></span> 
<span data-ttu-id="03398-999">Zwracany typ metody reprezentowanej przez <paramref name="method" /> nie można przypisać do <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-999">The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.</span></span>  
  
<span data-ttu-id="03398-1000">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1000">-or-</span></span> 
 <span data-ttu-id="03398-1001"><paramref name="expression" />. Typ lub <paramref name="type" /> jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości nie jest równa typu argument lub zwracany typ, odpowiednio, metody, reprezentowane przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1001"><paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="03398-1002">Więcej niż jednej metody, który odpowiada <paramref name="method" /> znaleziono opisu.</span><span class="sxs-lookup"><span data-stu-id="03398-1002">More than one method that matches the <paramref name="method" /> description was found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="03398-1003"><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> Reprezentujący plik źródłowy.</span><span class="sxs-lookup"><span data-stu-id="03398-1003">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</span></span></param>
        <param name="startLine"><span data-ttu-id="03398-1004">Wiersz start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1004">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="03398-1005">Musi być większa niż 0.</span><span class="sxs-lookup"><span data-stu-id="03398-1005">Must be greater than 0.</span></span></param>
        <param name="startColumn"><span data-ttu-id="03398-1006">Kolumna start <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1006">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="03398-1007">Musi być większa niż 0.</span><span class="sxs-lookup"><span data-stu-id="03398-1007">Must be greater than 0.</span></span></param>
        <param name="endLine"><span data-ttu-id="03398-1008">Wiersz końcowy <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1008">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="03398-1009">Musi być większy lub równy niż linia rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="03398-1009">Must be greater or equal than the start line.</span></span></param>
        <param name="endColumn"><span data-ttu-id="03398-1010">Kolumna zakończenia <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1010">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span> <span data-ttu-id="03398-1011">Jeśli wiersz końcowy jest taki sam jak początek wiersza, musi być większy lub równy niż kolumna rozpoczęcia.</span><span class="sxs-lookup"><span data-stu-id="03398-1011">If the end line is the same as the start line, it must be greater or equal than the start column.</span></span> <span data-ttu-id="03398-1012">W każdym przypadku musi być większa niż 0.</span><span class="sxs-lookup"><span data-stu-id="03398-1012">In any case, must be greater than 0.</span></span></param>
        <summary><span data-ttu-id="03398-1013">Tworzy <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> z określonym zakresem.</span><span class="sxs-lookup"><span data-stu-id="03398-1013">Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</span></span></summary>
        <returns><span data-ttu-id="03398-1014">Wystąpienie <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1014">An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1015">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1015">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1016"><see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</span><span class="sxs-lookup"><span data-stu-id="03398-1016">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <summary><span data-ttu-id="03398-1017">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1017">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="03398-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wraz z przydzielaniem wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1018">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1019">To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.</span><span class="sxs-lookup"><span data-stu-id="03398-1019">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1020">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia tego substracts 1 z danej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1020">The following code example shows how to create an expression that substracts 1 from a given value.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1021"><see cref="T:System.Linq.Expressions.Expression" /> Zmniejszyć.</span><span class="sxs-lookup"><span data-stu-id="03398-1021">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1022">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1022">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-1023">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zmniejszanie wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1023">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="03398-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wraz z przydzielaniem wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1024">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1025">To wyrażenie będzie działać i nie zmienia wartość przekazany obiekt.</span><span class="sxs-lookup"><span data-stu-id="03398-1025">This expression is functional and does not change the value of the object passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-1026">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1026">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1027">Tworzy <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość o określonym typie.</span><span class="sxs-lookup"><span data-stu-id="03398-1027">Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość o określonym typie.</span><span class="sxs-lookup"><span data-stu-id="03398-1028">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1029">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje vaule domyślny dla danego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1029">The following code example shows how to create an expression that represents a default vaule for a given type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1030">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1030">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1031"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1031">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1032"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1032">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</span></span></param>
        <summary><span data-ttu-id="03398-1033">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1033">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1034">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1035">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1035">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1036"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1036">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1037">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1037">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1038">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1038">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1039"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1039">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1040">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1040">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1041">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1041">Implementing Method</span></span>  
 <span data-ttu-id="03398-1042">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1042">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1043">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1043">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1044">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1044">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1045">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1045">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1046">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1046">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1047">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1047">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1048">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1048">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1049">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1049">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1050">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1050">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1051">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1051">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1052">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1052">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1053">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1053">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1054">Typ węzła jest operator dzielenia wstępnie zdefiniowany typ wyniku.</span><span class="sxs-lookup"><span data-stu-id="03398-1054">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="03398-1055">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1055">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1056">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dzielenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-1056">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1057">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, która dzieli dzieli swój pierwszy argument przez drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-1057">The following code example shows how to create an expression that divides divides its first argument by its second argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1058"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1058"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1059">Nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1059">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1060"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1060">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1061"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1061">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1062">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1062">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1063">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetycznego dzielenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1063">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</span></span> <span data-ttu-id="03398-1064">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-1064">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1065">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1066">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1066">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1067"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1067">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1068">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1068">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1069">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1069">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1070"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1070">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1071">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1071">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1072">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1072">Implementing Method</span></span>  
 <span data-ttu-id="03398-1073">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1073">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1074">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1074">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-1075">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator dzielenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1075">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the division operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1076">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1076">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1077">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1077">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1078">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1078">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1079">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1079">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1080">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1080">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1081">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1081">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1082">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1082">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1083">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1083">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1084">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1084">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1085">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1085">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1086">Typ węzła jest operator dzielenia wstępnie zdefiniowany typ wyniku.</span><span class="sxs-lookup"><span data-stu-id="03398-1086">The type of the node is the result type of the predefined division operator.</span></span>  
  
-   <span data-ttu-id="03398-1087">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1087">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1088">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator dzielenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-1088">The type of the node is the nullable type that corresponds to the result type of the predefined division operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1089"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1089"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1090"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1090"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1091"><paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator dzielenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1091"><paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1092">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1092">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1093"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1093">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1094"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1094">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1095">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1095">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1096">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1097"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1097">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1098"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1098">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1099">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1099">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1100">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1100">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1101">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1102"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1102">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1103"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1103">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1104">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1104">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1105">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1106">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisanie dzielenia, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1106">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1107">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1108">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</span><span class="sxs-lookup"><span data-stu-id="03398-1108">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1109">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1109">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1110">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1110">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1111">Argumenty operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1111">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1112">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1112">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1113">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1114"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1114">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1115">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1115">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1116">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1116">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-1117">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1117">The first argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1118">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1118">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1119">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1120"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1120">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1121">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1121">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1122">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1122">The result type of the dynamic expression.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1123">Argumenty operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1123">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1124">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1124">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1125">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1126"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1126">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1127">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1127">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1128">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1128">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-1129">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1129">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-1130">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1130">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1131">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1131">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1132">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1133"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1133">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1134">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1134">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1135">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1135">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-1136">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1136">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-1137">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1137">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-1138">Trzeci argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1138">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1139">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1139">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1140">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1141"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1141">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder"><span data-ttu-id="03398-1142">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1142">The runtime binder for the dynamic operation.</span></span></param>
        <param name="returnType"><span data-ttu-id="03398-1143">Typ wyniku wyrażenia dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="03398-1143">The result type of the dynamic expression.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-1144">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1144">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-1145">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1145">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-1146">Trzeci argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1146">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-1147">Czwarty argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-1147">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-1148">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1148">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1149">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1150"><xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> Właściwości wyniku zostanie wywnioskowany z typami argumentów i określony typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="03398-1150">The <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> property of the result will be inferred from the types of the arguments and the specified return type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1151">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1151">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="03398-1152">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1152">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1153"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1153">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1154">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, danego <see cref="T:System.Collections.Generic.IEnumerable`1" /> jako drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-1154">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</span></span></summary>
        <returns><span data-ttu-id="03398-1155"><see cref="T:System.Linq.Expressions.ElementInit" /> Zawierający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1155">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1156">`addMethod` Parametru musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter).</span><span class="sxs-lookup"><span data-stu-id="03398-1156">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="03398-1157">Metoda add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1157">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="03398-1158"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiedniego parametru metody add prawdopodobnie po *cytowanie*.</span><span class="sxs-lookup"><span data-stu-id="03398-1158">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-1159">Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-1159">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-1160">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1160">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-1161">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1161">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1162">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1162">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1163"><paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1163"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1164">Metoda, <paramref name="addMethod" /> reprezentuje nie nosi nazwę "Add" (jest uwzględniana wielkość liter).</span><span class="sxs-lookup"><span data-stu-id="03398-1164">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="03398-1165">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1165">-or-</span></span> 
<span data-ttu-id="03398-1166">Metoda, <paramref name="addMethod" /> reprezentuje nie jest metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1166">The method that <paramref name="addMethod" /> represents is not an instance method.</span></span>  
  
<span data-ttu-id="03398-1167">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1167">-or-</span></span> 
 <span data-ttu-id="03398-1168"><paramref name="arguments" /> nie zawiera taką samą liczbę elementów jako liczba parametrów dla metody, <paramref name="addMethod" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-1168"><paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.</span></span>  
  
<span data-ttu-id="03398-1169">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1169">-or-</span></span> 
<span data-ttu-id="03398-1170"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru metody, która <paramref name="addMethod" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-1170">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><span data-ttu-id="03398-1171">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1171">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1172">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiektów, aby ustawić <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1172">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1173">Tworzy <see cref="T:System.Linq.Expressions.ElementInit" />, biorąc pod uwagę tablicę wartości, jako drugi argument.</span><span class="sxs-lookup"><span data-stu-id="03398-1173">Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</span></span></summary>
        <returns><span data-ttu-id="03398-1174"><see cref="T:System.Linq.Expressions.ElementInit" /> Zawierający <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> i <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1174">An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1175">`addMethod` Parametru musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter).</span><span class="sxs-lookup"><span data-stu-id="03398-1175">The `addMethod` parameter must represent an instance method named "Add" (case insensitive).</span></span> <span data-ttu-id="03398-1176">Metoda add musi mieć taką samą liczbę parametrów jak liczba elementów w `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1176">The add method must have the same number of parameters as the number of elements in `arguments`.</span></span> <span data-ttu-id="03398-1177"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu w `arguments` musi być można przypisać do typu odpowiedniego parametru metody add prawdopodobnie po *cytowanie*.</span><span class="sxs-lookup"><span data-stu-id="03398-1177">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element in `arguments` must be assignable to the type of the corresponding parameter of the add method, possibly after *quoting*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-1178">Element będzie można podać tylko wtedy, gdy z odpowiadającym mu parametrem metody typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-1178">An element will be quoted only if the corresponding method parameter is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-1179">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1179">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-1180">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1180">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1181">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ElementInit> reprezentujący wywołanie <xref:System.Collections.Generic.Dictionary%602.Add%2A> metodę, aby zainicjować element kolekcji słownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.ElementInit> that represents calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to initialize an element of a dictionary collection.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1182"><paramref name="addMethod" /> lub <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1182"><paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1183">Metody, która reprezentuje addMethod jest nazwane "Add" (jest uwzględniana wielkość liter).</span><span class="sxs-lookup"><span data-stu-id="03398-1183">The method that addMethod represents is not named "Add" (case insensitive).</span></span>  
  
<span data-ttu-id="03398-1184">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1184">-or-</span></span> 
<span data-ttu-id="03398-1185">Metoda że reprezentuje addMethod nie jest metodą wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="03398-1185">The method that addMethod represents is not an instance method.</span></span>  
  
<span data-ttu-id="03398-1186">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1186">-or-</span></span> 
<span data-ttu-id="03398-1187">argumenty nie zawierać taką samą liczbę elementów jako liczba parametrów dla metody tego addMethod reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-1187">arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.</span></span>  
  
<span data-ttu-id="03398-1188">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1188">-or-</span></span> 
<span data-ttu-id="03398-1189"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwości jednego lub więcej elementów <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru metody, która <paramref name="addMethod" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-1189">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-1190">Tworzy puste wyrażenie, które ma <see cref="T:System.Void" /> typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1190">Creates an empty expression that has <see cref="T:System.Void" /> type.</span></span></summary>
        <returns><span data-ttu-id="03398-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1191">A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1192">Puste wyrażenie może służyć w sytuacji, gdy Oczekiwano wyrażenia, ale żadna akcja jest pożądane.</span><span class="sxs-lookup"><span data-stu-id="03398-1192">An empty expression can be used where an expression is expected but no action is desired.</span></span> <span data-ttu-id="03398-1193">Na przykład służy puste wyrażenie jako ostatniego wyrażenia w wyrażeniu bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-1193">For example, you can use an empty expression as the last expression in a block expression.</span></span> <span data-ttu-id="03398-1194">W tym przypadku wyrażenie bloku zwracana wartość jest typu void.</span><span class="sxs-lookup"><span data-stu-id="03398-1194">In this case, the block expression's return value is void.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1195">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia empty i dodać go do wyrażenia bloku.</span><span class="sxs-lookup"><span data-stu-id="03398-1195">The following code example shows how to create an empty expression and add it to a block expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1196">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span><span class="sxs-lookup"><span data-stu-id="03398-1196">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1197"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1197">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1198"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1198">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1199">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span><span class="sxs-lookup"><span data-stu-id="03398-1199">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1200">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1201">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1201">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1202"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1202">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1203">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1203">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-1204">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1204">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-1205"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1205">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-1206">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1206">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1207">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1207">Implementing Method</span></span>  
 <span data-ttu-id="03398-1208">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1208">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1209">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora równości <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1209">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1210">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1210">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1211">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1211">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1212">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1212">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1213">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1213">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1214">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1214">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1215">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-1215">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-1216">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1216">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1217">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1217">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1218">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1218">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1219">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1219">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1220">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1220">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1221">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1221">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1222">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1222">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1223">W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które sprawdza, czy wartości dwóch argumentów są takie same.</span><span class="sxs-lookup"><span data-stu-id="03398-1223">The following code example shows how to create an expression that checks whether the values of its two arguments are equal.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1224"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1224"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1225">Nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1225">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1226"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1226">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1227"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1227">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-1228"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1228"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1229">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1229">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1230">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości.</span><span class="sxs-lookup"><span data-stu-id="03398-1230">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</span></span> <span data-ttu-id="03398-1231">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-1231">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1232">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1233">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1233">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1234"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1234">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1235">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-1235">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-1236">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1236">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-1237">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1237">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1238">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1238">Implementing Method</span></span>  
 <span data-ttu-id="03398-1239">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1239">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1240">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1240">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1241">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora równości <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1241">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the equality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1242">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1242">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1243">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1243">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1244">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1244">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1245">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1245">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1246">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1246">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1247">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-1247">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-1248">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1248">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1249">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1249">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1250">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1250">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1251">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1251">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1252">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1252">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1253">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1253">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1254">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1254">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1255"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1255"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1256"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1256"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1257"><paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator równości dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1257"><paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1258">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1258">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1259"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1259">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1260"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1260">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1261">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1261">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="03398-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1262">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1263">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1263">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1264"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1264">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1265">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1265">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1266">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1266">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1267"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1267">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1268">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1268">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1269">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1269">Implementing Method</span></span>  
 <span data-ttu-id="03398-1270">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1270">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1271">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1271">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1272">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1272">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1273">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1273">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1274">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1274">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1275">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1275">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1276">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1276">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1277">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1277">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1278">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1278">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1279">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1279">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1280">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1280">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1281">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1281">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1282">Typ węzła jest typ wyniku jest wstępnie zdefiniowane `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-1282">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="03398-1283">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1283">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1284">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku jest wstępnie zdefiniowane `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-1284">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1285">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację logiczną XOR.</span><span class="sxs-lookup"><span data-stu-id="03398-1285">The following code example shows how to create an expression that represents the logical XOR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1286"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1286"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1287"><see langword="XOR" /> Operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1287">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1288"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1288">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1289"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1289">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1290">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1290">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1291">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="XOR" /> operacji przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1291">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span> <span data-ttu-id="03398-1292">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-1292">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1293">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1294">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1294">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1295"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1295">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1296">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1296">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1297">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1297">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1298"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1298">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1299">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1299">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1300">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1300">Implementing Method</span></span>  
 <span data-ttu-id="03398-1301">Następujące reguły określają wybrane implementacja metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1301">The following rules determine the chosen implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1302">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1302">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1303">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia `XOR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1303">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the `XOR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1304">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1304">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1305">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1305">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1306">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1306">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1307">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1307">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1308">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1308">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1309">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1309">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1310">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1310">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1311">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1311">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1312">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1312">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1313">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1313">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1314">Typ węzła jest typ wyniku jest wstępnie zdefiniowane `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-1314">The type of the node is the result type of the predefined `XOR` operator.</span></span>  
  
-   <span data-ttu-id="03398-1315">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1315">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1316">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku jest wstępnie zdefiniowane `XOR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-1316">The type of the node is the nullable type that corresponds to the result type of the predefined `XOR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1317"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1317"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1318"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1318"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1319"><paramref name="method" /> jest <see langword="null" /> i <see langword="XOR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1319"><paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1320">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR.</span><span class="sxs-lookup"><span data-stu-id="03398-1320">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1321"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1321">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1322"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1322">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1323">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1323">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="03398-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1324">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1325"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1325">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1326"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1326">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1327">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1327">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1328">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1328">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="03398-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1329">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1330"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1330">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1331"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1332">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1332">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1333">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1334">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania bitowe XOR przy użyciu <c>op_exclusiveor —</c> dla typów zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="03398-1334">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using <c>op_ExclusiveOr</c> for user-defined types.</span></span></summary>
        <returns><span data-ttu-id="03398-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1335">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1336">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1336">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1337"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1337">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="03398-1338">Aby uzyskać <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), <paramref name="expression" /> musi być <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1338">For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</span></span></param>
        <param name="field"><span data-ttu-id="03398-1339"><see cref="T:System.Reflection.FieldInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1339">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1340">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1340">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="03398-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1341">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1342"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość `field`.</span><span class="sxs-lookup"><span data-stu-id="03398-1342">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of `field`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1343"><paramref name="field" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1343"><paramref name="field" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1344">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1344">-or-</span></span> 
<span data-ttu-id="03398-1345">Pola, reprezentowane przez <paramref name="field" /> nie <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1345">The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1346"><paramref name="expression" />. Typ nie jest możliwy do przypisania do pola, reprezentowane przez typ deklarujący <paramref name="field" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1346"><paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1347"><see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera pole o nazwie <paramref name="fieldName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1347">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />.</span></span> <span data-ttu-id="03398-1348">Może to być wartość null w przypadku pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1348">This can be null for static fields.</span></span></param>
        <param name="fieldName"><span data-ttu-id="03398-1349">Nazwa pola można uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="03398-1349">The name of a field to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-1350">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola, biorąc pod uwagę nazwę pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1350">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</span></span></summary>
        <returns><span data-ttu-id="03398-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.FieldInfo" /> reprezentująca pole wskazywane przez <paramref name="fieldName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1351">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1352"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.FieldInfo.FieldType%2A> właściwość <xref:System.Reflection.FieldInfo> reprezentująca pole wskazywane przez `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="03398-1352">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.FieldInfo.FieldType%2A> property of the <xref:System.Reflection.FieldInfo> that represents the field denoted by `fieldName`.</span></span>  
  
 <span data-ttu-id="03398-1353">Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych dla pola, które ma nazwę `fieldName`.</span><span class="sxs-lookup"><span data-stu-id="03398-1353">This method searches `expression`.Type and its base types for a field that has the name `fieldName`.</span></span> <span data-ttu-id="03398-1354">Pola publiczne mają pierwszeństwo nad niepublicznych pól.</span><span class="sxs-lookup"><span data-stu-id="03398-1354">Public fields are given preference over non-public fields.</span></span> <span data-ttu-id="03398-1355">Jeśli zostanie znalezione pasujące pola, ta metoda przekazuje `expression` i <xref:System.Reflection.FieldInfo> reprezentująca to pole do <xref:System.Linq.Expressions.Expression.Field%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-1355">If a matching field is found, this method passes `expression` and the <xref:System.Reflection.FieldInfo> that represents that field to <xref:System.Linq.Expressions.Expression.Field%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1356">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1356">The following code example shows how to create an expression that represents accessing a field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1357"><paramref name="expression" /> lub <paramref name="fieldName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1357"><paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1358">Żadne pole o nazwie <paramref name="fieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-1358">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1359">Obiekt zawierający pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1359">The containing object of the field.</span></span> <span data-ttu-id="03398-1360">Może to być wartość null w przypadku pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1360">This can be null for static fields.</span></span></param>
        <param name="type"><span data-ttu-id="03398-1361"><see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1361">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</span></span></param>
        <param name="fieldName"><span data-ttu-id="03398-1362">Pole ma być uzyskiwany dostęp.</span><span class="sxs-lookup"><span data-stu-id="03398-1362">The field to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-1363">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola.</span><span class="sxs-lookup"><span data-stu-id="03398-1363">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</span></span></summary>
        <returns><span data-ttu-id="03398-1364">Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1364">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="03398-1365">Tablica do sixteen <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Action" /> typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1365">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="03398-1366">Tworzy <see cref="T:System.Type" /> obiekt, który reprezentuje ogólnego <c>elementu System.Action</c> przekazać typ, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1366">Creates a <see cref="T:System.Type" /> object that represents a generic <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-1367">Typ <c>elementu System.Action</c> delegata, która przyjmuje argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1367">The type of a <c>System.Action</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1368">Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, wynikowy <xref:System.Type> obiekt reprezentuje typ skonstruowanego delegata `System.Action<T1,…,Tn>` w języku C# lub `System.Action(Of T1,…,Tn)` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-1368">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Action<T1,…,Tn>` in C# or `System.Action(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1369"><paramref name="typeArgs" /> zawiera więcej niż szesnastu elementy.</span><span class="sxs-lookup"><span data-stu-id="03398-1369"><paramref name="typeArgs" /> contains more than sixteen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1370"><paramref name="typeArgs" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1370"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="03398-1371">Argumenty typu delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1371">The type arguments of the delegate.</span></span></param>
        <summary><span data-ttu-id="03398-1372">Pobiera <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> lub <c>elementu System.Action</c> przekazać typ, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1372">Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> or <c>System.Action</c> delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-1373">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1373">The delegate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1374">Ostatni argument typu określa zwracany typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1374">The last type argument determines the return type of the delegate.</span></span> <span data-ttu-id="03398-1375">Nie Func lub akcji jest wystarczająco duży, wygeneruje typu niestandardowego delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1375">If no Func or Action is large enough, it will generate a custom delegate type.</span></span>  
  
 <span data-ttu-id="03398-1376">Podobnie jak w przypadku Func, ostatni argument jest typem zwracanym.</span><span class="sxs-lookup"><span data-stu-id="03398-1376">As with Func, the last argument is the return type.</span></span> <span data-ttu-id="03398-1377">Go może być równa do elementu System.Void wywołują akcje.</span><span class="sxs-lookup"><span data-stu-id="03398-1377">It can be set to System.Void to produce an Action.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="03398-1378">Tablica jednego do siedemnastu <see cref="T:System.Type" /> obiektów, które określają argumentów typu dla <see langword="System.Func" /> typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1378">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</span></span></param>
        <summary><span data-ttu-id="03398-1379">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje ogólnego <c>System.Func</c> przekazać typ, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1379">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic <c>System.Func</c> delegate type that has specific type arguments.</span></span> <span data-ttu-id="03398-1380">Ostatni argument typu określa zwracany typ delegata utworzony.</span><span class="sxs-lookup"><span data-stu-id="03398-1380">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="03398-1381">Typ <c>System.Func</c> delegata, która przyjmuje argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-1381">The type of a <c>System.Func</c> delegate that has the specified type arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1382">`typeArgs` musi zawierać co najmniej jednego i co najwyżej siedemnastu elementy.</span><span class="sxs-lookup"><span data-stu-id="03398-1382">`typeArgs` must contain at least one and at most seventeen elements.</span></span>  
  
 <span data-ttu-id="03398-1383">Na przykład jeśli elementy `typeArgs` reprezentują typy `T1…Tn`, wynikowy <xref:System.Type> obiekt reprezentuje typ skonstruowanego delegata `System.Func<T1,…,Tn>` w języku C# lub `System.Func(Of T1,…,Tn)` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-1383">As an example, if the elements of `typeArgs` represent the types `T1…Tn`, the resulting <xref:System.Type> object represents the constructed delegate type `System.Func<T1,…,Tn>` in C# or `System.Func(Of T1,…,Tn)` in Visual Basic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1384"><paramref name="typeArgs" /> zawiera mniej niż jeden lub więcej niż siedemnastu elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-1384"><paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1385"><paramref name="typeArgs" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1385"><paramref name="typeArgs" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1386">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span><span class="sxs-lookup"><span data-stu-id="03398-1386">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1387"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-1387">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="03398-1388">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span><span class="sxs-lookup"><span data-stu-id="03398-1388">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span></summary>
        <returns><span data-ttu-id="03398-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość o określonej wartości i wartości null do przekazania do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1389">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1390">Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.GotoExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-1390">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.GotoExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1391"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-1391">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-1392">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1392">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="03398-1393">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do".</span><span class="sxs-lookup"><span data-stu-id="03398-1393">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</span></span> <span data-ttu-id="03398-1394">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-1394">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1395">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1396"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-1396">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-1397"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1397">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1398">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-1398">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwość o określonej wartości, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1399">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1400"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-1400">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-1401">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1401">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="03398-1402"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1402">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1403">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję "Przejdź do" z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-1403">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</span></span> <span data-ttu-id="03398-1404">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-1404">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Goto, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-1405">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1406">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1406">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1407"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1407">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1408"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1408">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1409">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1409">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1410">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1411">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1411">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1412"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1412">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1413">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1413">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-1414">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1414">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-1415"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1415">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-1416"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1416">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1417">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1417">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1418">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1418">Implementing Method</span></span>  
 <span data-ttu-id="03398-1419">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1419">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1420">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1420">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1421">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1421">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1422">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1422">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1423">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1423">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1424">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1424">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1425">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1425">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1426">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-1426">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-1427">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1427">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1428">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1428">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1429">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1429">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1430">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1430">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1431">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1431">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1432">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1432">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1433">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1433">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1434">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="03398-1434">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1435"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1435"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1436">Operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1436">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1437"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1437">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1438"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-1439"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1439"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1440">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1440">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1441">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe niż" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1441">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</span></span> <span data-ttu-id="03398-1442">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-1442">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1443">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1444">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1444">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1445"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1445">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1446">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-1446">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-1447">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1447">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-1448"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1448">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1449">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1449">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1450">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1450">Implementing Method</span></span>  
 <span data-ttu-id="03398-1451">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1451">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="03398-1452">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1452">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1453">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1453">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1454">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1454">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1455">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1455">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1456">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1456">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1457">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1457">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1458">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1458">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1459">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-1459">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-1460">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1460">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1461">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1461">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1462">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1462">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1463">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1463">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1464">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1464">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1465">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1465">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1466">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1466">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1467"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1467"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1468"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1468"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1469"><paramref name="method" /> jest <see langword="null" /> i operator "większe niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1469"><paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1470">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1471"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1471">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1472"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1472">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1473">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1473">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1474">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1475">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1475">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1476"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1476">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1477">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1477">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-1478">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1478">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-1479"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1479">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-1480"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1480">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1481">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1481">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1482">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1482">Implementing Method</span></span>  
 <span data-ttu-id="03398-1483">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1483">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1484">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1484">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1485">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1485">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1486">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1486">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1487">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1487">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1488">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1488">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1489">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1489">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1490">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-1490">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-1491">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1491">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1492">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1492">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1493">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1493">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1494">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1494">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1495">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1495">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1496">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1496">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1497">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1497">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1498">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="03398-1498">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1499"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1499"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1500">Operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1500">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1501"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1501">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1502"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1502">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-1503"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1503"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1504">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1504">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1505">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "większe lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1506">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1507">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1507">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1508"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1508">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1509">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-1509">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-1510">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1510">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-1511"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1511">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1512">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1512">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1513">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1513">Implementing Method</span></span>  
 <span data-ttu-id="03398-1514">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1514">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1515">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1515">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1516">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora "większe lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1516">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "greater than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1517">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1517">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1518">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1518">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1519">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1519">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1520">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1520">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1521">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1521">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1522">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-1522">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-1523">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1523">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1524">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1524">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1525">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1525">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1526">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1526">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1527">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1527">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1528">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1528">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1529">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1529">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1530"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1530"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1531"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1531"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1532"><paramref name="method" /> jest <see langword="null" /> i operator "większe lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1532"><paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="03398-1533"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1533">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="03398-1534"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1534">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1535">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego za pomocą <see langword="if" /> instrukcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1535">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</span></span></summary>
        <returns><span data-ttu-id="03398-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, właściwości ustawione do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1536">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values.</span></span> <span data-ttu-id="03398-1537"><see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> Właściwość jest ustawiona na wyrażenie domyślne i rodzaju powstałe <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1537">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1538">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje bloku warunkowego.</span><span class="sxs-lookup"><span data-stu-id="03398-1538">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><span data-ttu-id="03398-1539"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1539">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</span></span></param>
        <param name="ifTrue"><span data-ttu-id="03398-1540"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1540">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</span></span></param>
        <param name="ifFalse"><span data-ttu-id="03398-1541"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1541">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1542">Tworzy <see cref="T:System.Linq.Expressions.ConditionalExpression" /> reprezentujący bloku warunkowego za pomocą <see langword="if" /> i <see langword="else" /> instrukcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1542">Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</span></span></summary>
        <returns><span data-ttu-id="03398-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> i <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, i <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1543">A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</span></span> <span data-ttu-id="03398-1544">Typ wyniku <see cref="T:System.Linq.Expressions.ConditionalExpression" /> zwracanego przez tę metodę jest <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1544">The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1545">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który reprezentuje bloku warunkowego.</span><span class="sxs-lookup"><span data-stu-id="03398-1545">The following code example shows how to create an expression that represents a conditional block.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1546">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększenie wartości wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1546">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1547"><see cref="T:System.Linq.Expressions.Expression" /> Do następującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1547">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <summary><span data-ttu-id="03398-1548">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększenie wartości wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1548">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</span></span></summary>
        <returns><span data-ttu-id="03398-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększona wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1549">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1550">To wyrażenie będzie działać i nie zmienia wartości obiektu, który jest przekazywany do niego.</span><span class="sxs-lookup"><span data-stu-id="03398-1550">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1551">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które reprezentuje operację przyrostu.</span><span class="sxs-lookup"><span data-stu-id="03398-1551">The following code example shows how to create an expression that represents an increment operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1552"><see cref="T:System.Linq.Expressions.Expression" /> Do następującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1552">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1553">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1553">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-1554">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zwiększając wartość wyrażenia o 1.</span><span class="sxs-lookup"><span data-stu-id="03398-1554">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</span></span></summary>
        <returns><span data-ttu-id="03398-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący zwiększona wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-1555">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1556">To wyrażenie będzie działać i nie zmienia wartości obiektu, który jest przekazywany do niego.</span><span class="sxs-lookup"><span data-stu-id="03398-1556">This expression is functional and does not change the value of the object that is passed to it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1557">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1557">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1558"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda do zastosowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1558">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1559"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</span><span class="sxs-lookup"><span data-stu-id="03398-1559">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="03398-1560">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> delegat lub wyrażenie lambda która odnosi się do listy wyrażenia argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-1560">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-1561"><see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1561">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1562"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata, który jest reprezentowany przez `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1562">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="03398-1563"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeżeli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1563">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="03398-1564">W przeciwnym razie zawiera te same elementy co `arguments` , z wyjątkiem niektórych z tych <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowane*.</span><span class="sxs-lookup"><span data-stu-id="03398-1564">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-1565">Element będzie można podać tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-1565">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-1566">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1566">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-1567">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1567">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1568">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-1568">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1569"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1569"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1570"><paramref name="expression" />. Typ nie reprezentuje typ obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1570"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="03398-1571">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1571">-or-</span></span> 
<span data-ttu-id="03398-1572"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru delegata, reprezentowane przez <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1572">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1573"><paramref name="arguments" /> zawiera taką samą liczbę elementów jak lista parametrów dla delegata, reprezentowane przez <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1573"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1574"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący delegat lub wyrażenie lambda mają być stosowane.</span><span class="sxs-lookup"><span data-stu-id="03398-1574">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-1575">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty reprezentujące argumenty, które delegat lub wyrażenie lambda jest stosowany do.</span><span class="sxs-lookup"><span data-stu-id="03398-1575">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</span></span></param>
        <summary><span data-ttu-id="03398-1576">Tworzy <see cref="T:System.Linq.Expressions.InvocationExpression" /> delegat lub wyrażenie lambda która odnosi się do listy wyrażenia argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-1576">Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</span></span></summary>
        <returns><span data-ttu-id="03398-1577"><see cref="T:System.Linq.Expressions.InvocationExpression" /> Dotyczący określonej delegat lub wyrażenie lambda do podanych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1577">An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1578"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> reprezentuje zwracany typ delegata, który jest reprezentowany przez `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1578">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> represents the return type of the delegate that is represented by `expression`.Type.</span></span>  
  
 <span data-ttu-id="03398-1579"><xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> Właściwość wynikowy <xref:System.Linq.Expressions.InvocationExpression> jest pusta Jeżeli `arguments` jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1579">The <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.InvocationExpression> is empty if `arguments` is `null`.</span></span> <span data-ttu-id="03398-1580">W przeciwnym razie zawiera te same elementy co `arguments` , z wyjątkiem niektórych z tych <xref:System.Linq.Expressions.Expression> obiekty mogą być *cytowane*.</span><span class="sxs-lookup"><span data-stu-id="03398-1580">Otherwise, it contains the same elements as `arguments` except that some of these <xref:System.Linq.Expressions.Expression> objects may be *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-1581">Element będzie można podać tylko wtedy, gdy odpowiedni parametr delegata reprezentowany przez `expression` typu <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-1581">An element will be quoted only if the corresponding parameter of the delegate represented by `expression` is of type <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-1582">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1582">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-1583">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `arguments`.</span><span class="sxs-lookup"><span data-stu-id="03398-1583">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `arguments`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1584">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.InvocationExpression> reprezentujący wywołanie wyrażenia lambda z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-1584">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> method to create an <xref:System.Linq.Expressions.InvocationExpression> that represents the invocation of a lambda expression with specified arguments.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1585"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1585"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1586"><paramref name="expression" />. Typ nie reprezentuje typ obiektu delegowanego lub <see cref="T:System.Linq.Expressions.Expression`1" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1586"><paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.</span></span>  
  
<span data-ttu-id="03398-1587">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1587">-or-</span></span> 
<span data-ttu-id="03398-1588"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru delegata, reprezentowane przez <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1588">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1589"><paramref name="arguments" /> zawiera taką samą liczbę elementów jak lista parametrów dla delegata, reprezentowane przez <paramref name="expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1589"><paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1590">Zwraca, czy wyrażenie zwróci wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-1590">Returns whether the expression evaluates to false.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1591"><see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span><span class="sxs-lookup"><span data-stu-id="03398-1591">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="03398-1592">Zwraca, czy wyrażenie zwróci wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-1592">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="03398-1593">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1593">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1594"><see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span><span class="sxs-lookup"><span data-stu-id="03398-1594">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1595">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1595">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-1596">Zwraca, czy wyrażenie zwróci wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-1596">Returns whether the expression evaluates to false.</span></span></summary>
        <returns><span data-ttu-id="03398-1597">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1597">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1598">Zwraca, czy wyrażenie ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="03398-1598">Returns whether the expression evaluates to true.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1599"><see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span><span class="sxs-lookup"><span data-stu-id="03398-1599">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <summary><span data-ttu-id="03398-1600">Zwraca, czy wyrażenie ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="03398-1600">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="03398-1601">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1601">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-1602"><see cref="T:System.Linq.Expressions.Expression" /> Do oceny.</span><span class="sxs-lookup"><span data-stu-id="03398-1602">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1603">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1603">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-1604">Zwraca, czy wyrażenie ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="03398-1604">Returns whether the expression evaluates to true.</span></span></summary>
        <returns><span data-ttu-id="03398-1605">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1605">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1606">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę.</span><span class="sxs-lookup"><span data-stu-id="03398-1606">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-1607">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę o typie void i bez nazwy.</span><span class="sxs-lookup"><span data-stu-id="03398-1607">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</span></span></summary>
        <returns><span data-ttu-id="03398-1608">Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1608">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1609">Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.LabelTarget> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-1609">The following example demonstrates how to create an expression that contains a <xref:System.Linq.Expressions.LabelTarget> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1610"><see cref="T:System.Linq.Expressions.LabelTarget" /> Których <see cref="T:System.Linq.Expressions.LabelExpression" /> zostaną skojarzone z.</span><span class="sxs-lookup"><span data-stu-id="03398-1610">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <summary><span data-ttu-id="03398-1611">Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykiety bez wartości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="03398-1611">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</span></span></summary>
        <returns><span data-ttu-id="03398-1612">Element <see cref="T:System.Linq.Expressions.LabelExpression" /> bez wartości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="03398-1612">A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="03398-1613">Nazwa etykiety.</span><span class="sxs-lookup"><span data-stu-id="03398-1613">The name of the label.</span></span></param>
        <summary><span data-ttu-id="03398-1614">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykietę o typie void i podanej nazwie.</span><span class="sxs-lookup"><span data-stu-id="03398-1614">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</span></span></summary>
        <returns><span data-ttu-id="03398-1615">Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1615">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-1616">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiety.</span><span class="sxs-lookup"><span data-stu-id="03398-1616">The type of value that is passed when jumping to the label.</span></span></param>
        <summary><span data-ttu-id="03398-1617">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-1617">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</span></span></summary>
        <returns><span data-ttu-id="03398-1618">Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1618">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-1619">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.LabelTarget> w wyrażeniu pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-1619">The following example demonstrates how to use a <xref:System.Linq.Expressions.LabelTarget> object in a loop expression.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-1620"><see cref="T:System.Linq.Expressions.LabelTarget" /> Których <see cref="T:System.Linq.Expressions.LabelExpression" /> zostaną skojarzone z.</span><span class="sxs-lookup"><span data-stu-id="03398-1620">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="03398-1621">Wartość tego <see cref="T:System.Linq.Expressions.LabelExpression" /> po osiągnięciu etykiety za pomocą regularnego kontroli przepływu.</span><span class="sxs-lookup"><span data-stu-id="03398-1621">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</span></span></param>
        <summary><span data-ttu-id="03398-1622">Tworzy <see cref="T:System.Linq.Expressions.LabelExpression" /> reprezentujący etykietę z daną wartość domyślną.</span><span class="sxs-lookup"><span data-stu-id="03398-1622">Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</span></span></summary>
        <returns><span data-ttu-id="03398-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> z daną wartość domyślną.</span><span class="sxs-lookup"><span data-stu-id="03398-1623">A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-1624">Typ wartości, który jest przekazywany, gdy przeskakiwanie do etykiety.</span><span class="sxs-lookup"><span data-stu-id="03398-1624">The type of value that is passed when jumping to the label.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1625">Nazwa etykiety.</span><span class="sxs-lookup"><span data-stu-id="03398-1625">The name of the label.</span></span></param>
        <summary><span data-ttu-id="03398-1626">Tworzy <see cref="T:System.Linq.Expressions.LabelTarget" /> reprezentujący etykiety z danym typem i nazwą.</span><span class="sxs-lookup"><span data-stu-id="03398-1626">Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</span></span></summary>
        <returns><span data-ttu-id="03398-1627">Nowy <see cref="T:System.Linq.Expressions.LabelTarget" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1627">The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1628">Tworzy drzewo wyrażenia, który reprezentuje wyrażenie lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1628">Creates an expression tree that represents a lambda expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1629"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1629">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1630"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1630">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1631">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1631">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1632">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1632">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1633"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1633">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1634">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1634">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1635">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1635">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1636">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1636">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1637">`parameters` Parametru nie może mieć więcej niż szesnastu elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-1637">The `parameters` parameter must not have more than sixteen elements.</span></span>  
  
 <span data-ttu-id="03398-1638">Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.</span><span class="sxs-lookup"><span data-stu-id="03398-1638">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="03398-1639">Ta metoda konstrukcje typu odpowiedniego delegata z jednego z `System.Func` delegatów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="03398-1639">This method constructs an appropriate delegate type from one of the `System.Func` generic delegates.</span></span> <span data-ttu-id="03398-1640">Następnie przekazuje typ delegata do jednego z <xref:System.Linq.Expressions.ExpressionType.Lambda> metodami factory, aby utworzyć <xref:System.Linq.Expressions.LambdaExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-1640">It then passes the delegate type to one of the <xref:System.Linq.Expressions.ExpressionType.Lambda> factory methods to create a <xref:System.Linq.Expressions.LambdaExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1641"><paramref name="body" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1641"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1642">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1642">-or-</span></span> 
<span data-ttu-id="03398-1643">Jeden lub więcej elementów <paramref name="parameters" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1643">One or more elements of <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1644"><paramref name="parameters" /> zawiera więcej niż szesnastu elementy.</span><span class="sxs-lookup"><span data-stu-id="03398-1644"><paramref name="parameters" /> contains more than sixteen elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1645"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1645">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1646">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1646">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1647"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1647">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1648">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1648">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1649">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1649">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1650"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1650">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1651">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1651">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1652">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1652">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1653">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1653">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1654">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1654">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1655"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1655">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1656">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1656">The name for the lambda.</span></span> <span data-ttu-id="03398-1657">Używany do emitowania informacje debugowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1657">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1658"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1658">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1659">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1659">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1660">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1660">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1661">A <see cref="T:System.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1661">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1662"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1662">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1663"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1663">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1664">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1664">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="03398-1665">Można używać, gdy typ delegata nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1665">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1666">Obiekt, który reprezentuje wyrażenie lambda, która ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1666">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1667">Typ obiektu, który jest zwracany z tej funkcji to <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="03398-1667">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="03398-1668"><xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1668">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="03398-1669">Liczba parametrów dla typu delegata, reprezentowane przez`delegateType` musi być równa długości argumentu `parameters`.</span><span class="sxs-lookup"><span data-stu-id="03398-1669">The number of parameters for the delegate type represented by`delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="03398-1670">Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.</span><span class="sxs-lookup"><span data-stu-id="03398-1670">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="03398-1671"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt jest równa `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="03398-1671">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="03398-1672">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-1672">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1673">Poniższy przykład przedstawia sposób tworzenia wyrażenia, który reprezentuje wyrażenie lambda, która dodaje 1 przekazany argument.</span><span class="sxs-lookup"><span data-stu-id="03398-1673">The following example demonstrates how to create an expression that represents a lambda expression that adds 1 to the passed argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1674"><paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1674"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1675">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1675">-or-</span></span> 
<span data-ttu-id="03398-1676">Jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1676">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1677"><paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.</span><span class="sxs-lookup"><span data-stu-id="03398-1677"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="03398-1678">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1678">-or-</span></span> 
 <span data-ttu-id="03398-1679"><paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu na typ delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1679"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="03398-1680">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1680">-or-</span></span> 
 <span data-ttu-id="03398-1681"><paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1681"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="03398-1682">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1682">-or-</span></span> 
<span data-ttu-id="03398-1683"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedniego typu parametru na typ delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1683">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1684">A <see cref="T:System.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1684">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1685"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1685">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1686">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1686">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1687">Tworzy <see cref="T:System.Linq.Expressions.LambdaExpression" /> przy pierwszym konstruowanie typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1687">Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</span></span> <span data-ttu-id="03398-1688">Można używać, gdy typ delegata nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1688">It can be used when the delegate type is not known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1689">Obiekt, który reprezentuje wyrażenie lambda, która ma <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1689">An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1690">Typ obiektu, który jest zwracany z tej funkcji to <xref:System.Linq.Expressions.Expression%601>.</span><span class="sxs-lookup"><span data-stu-id="03398-1690">The object that is returned from this function is of type <xref:System.Linq.Expressions.Expression%601>.</span></span> <span data-ttu-id="03398-1691"><xref:System.Linq.Expressions.LambdaExpression> Typ jest używany do reprezentowania zwróconego obiektu, ponieważ konkretnego typu wyrażenia lambda nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1691">The <xref:System.Linq.Expressions.LambdaExpression> type is used to represent the returned object because the concrete type of the lambda expression is not known at compile time.</span></span>  
  
 <span data-ttu-id="03398-1692">Liczba parametrów dla typu delegata, reprezentowane przez `delegateType` musi być równa długości argumentu `parameters`.</span><span class="sxs-lookup"><span data-stu-id="03398-1692">The number of parameters for the delegate type represented by `delegateType` must equal the length of `parameters`.</span></span>  
  
 <span data-ttu-id="03398-1693">Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.</span><span class="sxs-lookup"><span data-stu-id="03398-1693">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="03398-1694"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt jest równa `delegateType`.</span><span class="sxs-lookup"><span data-stu-id="03398-1694">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object is equal to `delegateType`.</span></span> <span data-ttu-id="03398-1695">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-1695">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1696"><paramref name="delegateType" /> lub <paramref name="body" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1696"><paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1697">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1697">-or-</span></span> 
<span data-ttu-id="03398-1698">Jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1698">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1699"><paramref name="delegateType" /> reprezentuje typ obiektu delegowanego.</span><span class="sxs-lookup"><span data-stu-id="03398-1699"><paramref name="delegateType" /> does not represent a delegate type.</span></span>  
  
<span data-ttu-id="03398-1700">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1700">-or-</span></span> 
 <span data-ttu-id="03398-1701"><paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu na typ delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1701"><paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="03398-1702">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1702">-or-</span></span> 
 <span data-ttu-id="03398-1703"><paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla typu delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1703"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.</span></span>  
  
<span data-ttu-id="03398-1704">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1704">-or-</span></span> 
<span data-ttu-id="03398-1705"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedniego typu parametru na typ delegata, reprezentowane przez <paramref name="delegateType" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1705">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-1706"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1706">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1707">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1707">The name for the lambda.</span></span> <span data-ttu-id="03398-1708">Używany do emitowania informacje debugowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1708">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1709">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1709">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1710"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1710">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1711">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1711">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1712">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1712">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1713">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1713">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1714"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1714">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1715">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1715">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1716"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1716">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1717">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1717">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1718">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1718">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1719">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1719">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1720"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1720">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1721">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1721">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1722">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1722">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1723">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1723">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1724">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1724">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1725">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1725">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1726"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1726">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1727">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1727">The name for the lambda.</span></span> <span data-ttu-id="03398-1728">Używany do emitowania informacje debugowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1728">Used for emitting debug information.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1729"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1729">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1730">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1730">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1731">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1731">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-1732">A <see cref="P:System.Linq.Expressions.Expression.Type" /> reprezentujący podpis delegata dla wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1732">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</span></span></param>
        <param name="body"><span data-ttu-id="03398-1733"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1733">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1734">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1734">The name for the lambda.</span></span> <span data-ttu-id="03398-1735">Używany do emitowania informacje debugowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1735">Used for emitting debug information.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1736">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1736">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1737"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1737">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1738">Tworzy Wyrażenielambda, tworząc pierwszy typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1738">Creates a LambdaExpression by first constructing a delegate type.</span></span></summary>
        <returns><span data-ttu-id="03398-1739">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> właściwość równa Lambda i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1739">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1740">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1740">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1741"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1741">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1742"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1743">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1743">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1744"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1744">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1745">Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.</span><span class="sxs-lookup"><span data-stu-id="03398-1745">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="03398-1746">Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w `body`.</span><span class="sxs-lookup"><span data-stu-id="03398-1746">The elements of `parameters` must be reference equal to the parameter expressions in `body`.</span></span>  
  
 <span data-ttu-id="03398-1747"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt reprezentuje typ `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="03398-1747">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="03398-1748">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-1748">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1749"><paramref name="body" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1749"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1750">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1750">-or-</span></span> 
<span data-ttu-id="03398-1751">Jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1751">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1752"><paramref name="TDelegate" /> nie jest typem delegowanym.</span><span class="sxs-lookup"><span data-stu-id="03398-1752"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="03398-1753">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1753">-or-</span></span> 
 <span data-ttu-id="03398-1754"><paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1754"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="03398-1755">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1755">-or-</span></span> 
 <span data-ttu-id="03398-1756"><paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1756"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="03398-1757">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1757">-or-</span></span> 
<span data-ttu-id="03398-1758"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedni typ parametru <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1758">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1759">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1759">A delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1760"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1761">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1761">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1762">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1762">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1763"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1763">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1764">Liczba parametrów dla typu delegata `TDelegate` musi być równa liczbie elementów w `parameters`.</span><span class="sxs-lookup"><span data-stu-id="03398-1764">The number of parameters for the delegate type `TDelegate` must equal the number of elements in `parameters`.</span></span>  
  
 <span data-ttu-id="03398-1765">Elementy `parameters` odwołania musi być równa w wyrażeniach parametrów w`body`.</span><span class="sxs-lookup"><span data-stu-id="03398-1765">The elements of `parameters` must be reference equal to the parameter expressions in`body`.</span></span>  
  
 <span data-ttu-id="03398-1766"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy obiekt reprezentuje typ `TDelegate`.</span><span class="sxs-lookup"><span data-stu-id="03398-1766">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting object represents the type `TDelegate`.</span></span> <span data-ttu-id="03398-1767">Jeśli `parameters` jest `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> właściwość wynikowy obiekt jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-1767">If `parameters` is `null`, the <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> property of the resulting object is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1768"><paramref name="body" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1768"><paramref name="body" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-1769">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1769">-or-</span></span> 
<span data-ttu-id="03398-1770">Jeden lub więcej elementów w <paramref name="parameters" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1770">One or more elements in <paramref name="parameters" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1771"><paramref name="TDelegate" /> nie jest typem delegowanym.</span><span class="sxs-lookup"><span data-stu-id="03398-1771"><paramref name="TDelegate" /> is not a delegate type.</span></span>  
  
<span data-ttu-id="03398-1772">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1772">-or-</span></span> 
 <span data-ttu-id="03398-1773"><paramref name="body" />. Typ reprezentuje typ, który nie jest możliwy do przypisania do zwracanego typu <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1773"><paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="03398-1774">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1774">-or-</span></span> 
 <span data-ttu-id="03398-1775"><paramref name="parameters" /> nie zawiera taką samą liczbę elementów jak lista parametrów dla <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1775"><paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.</span></span>  
  
<span data-ttu-id="03398-1776">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-1776">-or-</span></span> 
<span data-ttu-id="03398-1777"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="parameters" /> nie jest możliwy do przypisania z typu odpowiedni typ parametru <paramref name="TDelegate" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1777">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1778">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1778">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1779"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1779">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1780">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1780">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1781"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1781">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1782">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1782">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1783"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1783">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1784">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1784">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1785"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1785">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1786">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1786">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1787">Tablica zawierająca <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1787">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1788">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1788">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1789"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1789">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1790">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1790">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1791"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1791">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1792">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1792">The name of the lambda.</span></span> <span data-ttu-id="03398-1793">Używany do generowania informacji o debugowaniu.</span><span class="sxs-lookup"><span data-stu-id="03398-1793">Used for generating debugging information.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1794"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1794">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1795">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1795">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1796"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1796">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate"><span data-ttu-id="03398-1797">Typ delegata.</span><span class="sxs-lookup"><span data-stu-id="03398-1797">The delegate type.</span></span></typeparam>
        <param name="body"><span data-ttu-id="03398-1798"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1798">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</span></span></param>
        <param name="name"><span data-ttu-id="03398-1799">Nazwa wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="03398-1799">The name of the lambda.</span></span> <span data-ttu-id="03398-1800">Używany do generowania informacji debugowania.</span><span class="sxs-lookup"><span data-stu-id="03398-1800">Used for generating debugging info.</span></span></param>
        <param name="tailCall"><span data-ttu-id="03398-1801">A <see cref="T:System.Boolean" /> oznacza, że jeśli optymalizację wywołania tail będą stosowane podczas kompilowania wyrażenia utworzone.</span><span class="sxs-lookup"><span data-stu-id="03398-1801">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</span></span></param>
        <param name="parameters"><span data-ttu-id="03398-1802"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-1802">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-1803">Tworzy <see cref="T:System.Linq.Expressions.Expression`1" /> której typ delegata jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="03398-1803">Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</span></span></summary>
        <returns><span data-ttu-id="03398-1804"><see cref="T:System.Linq.Expressions.Expression`1" /> Zawierający <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> i <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1804">An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1805">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1805">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1806"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1806">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1807"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1807">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1808">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1808">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1809">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1809">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1810">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1810">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1811"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1811">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1812">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1812">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1813">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1813">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1814"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1814">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1815">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1815">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1816">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1816">Implementing Method</span></span>  
 <span data-ttu-id="03398-1817">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1817">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1818">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator przesunięcia w lewo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1818">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1819">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1819">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1820">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1820">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1821">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1821">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1822">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1822">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1823">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1823">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1824">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1824">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1825">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1825">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1826">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1826">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1827">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1827">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1828">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1828">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1829">Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1829">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="03398-1830">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1830">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1831">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1831">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1832"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1832"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1833">Operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1833">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1834"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1834">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1835"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1835">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1836">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1836">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1837">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1837">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1838">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1838">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1839">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1839">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1840"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1840">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1841">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1841">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-1842">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1842">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-1843"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1843">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1844">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1844">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1845">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1845">Implementing Method</span></span>  
 <span data-ttu-id="03398-1846">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1846">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1847">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1847">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-1848">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator przesunięcia w lewo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1848">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the left-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1849">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1849">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1850">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1850">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1851">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1851">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1852">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1852">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1853">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1853">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1854">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-1854">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-1855">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1855">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1856">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-1856">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-1857">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1857">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1858">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1858">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1859">Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1859">The type of the node is the result type of the predefined left-shift operator.</span></span>  
  
-   <span data-ttu-id="03398-1860">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1860">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1861">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1861">The type of the node is the nullable type that corresponds to the result type of the predefined left-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1862"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1862"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1863"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1863"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1864"><paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w lewo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1864"><paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1865">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1865">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1866"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1866">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1867"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1867">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1868">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1868">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1869">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1869">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1870"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1870">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1871"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1871">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1872">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1872">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1873">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1873">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1874">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1874">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1875"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1875">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1876"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1877">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-1878">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1878">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1879">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w lewo.</span><span class="sxs-lookup"><span data-stu-id="03398-1879">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-1880">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1880">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1881">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1881">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1882"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1882">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1883"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1883">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1884">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1884">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1885">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1885">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1886">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1886">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1887"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1887">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1888">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1888">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-1889">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1889">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-1890"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1890">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-1891"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1891">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1892">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1892">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1893">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1893">Implementing Method</span></span>  
 <span data-ttu-id="03398-1894">Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="03398-1894">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="03398-1895">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1895">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1896">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1896">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1897">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1897">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1898">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1898">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1899">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1899">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1900">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1900">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1901">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-1901">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-1902">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1902">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1903">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1903">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1904">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1904">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1905">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1905">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1906">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1906">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1907">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1907">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1908">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1908">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1909">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="03398-1909">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1910"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1910"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1911">Operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1911">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1912"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1912">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1913"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1913">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-1914"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1914"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1915">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1915">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1916">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "poniżej" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1916">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1917">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1917">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1918">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1918">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1919"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1919">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1920">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-1920">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-1921">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1921">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-1922"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1922">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1923">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1923">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1924">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1924">Implementing Method</span></span>  
 <span data-ttu-id="03398-1925">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1925">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1926">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1926">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1927">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1927">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1928">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1928">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1929">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1929">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1930">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1930">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1931">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1931">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1932">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1932">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1933">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-1933">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-1934">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1934">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1935">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1935">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1936">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1936">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1937">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1937">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1938">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1938">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1939">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1939">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1940">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1940">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1941"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1941"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-1942"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-1942"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1943"><paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1943"><paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-1944">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1944">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1945"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1945">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1946"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1946">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1947">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1947">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1948">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1948">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1949">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1949">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1950"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1950">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1951">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-1951">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-1952">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1952">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-1953"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1953">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-1954"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1954">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1955">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1955">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1956">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1956">Implementing Method</span></span>  
 <span data-ttu-id="03398-1957">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1957">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1958">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1958">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1959">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1959">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1960">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1960">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1961">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1961">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1962">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1962">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1963">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1963">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1964">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-1964">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-1965">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1965">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1966">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1966">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1967">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1967">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-1968">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1968">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-1969">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1969">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-1970">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1970">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-1971">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1971">The type of the node is <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-1972">Poniższy przykład kodu pokazuje sposób tworzenia wyrażenia, który porównuje dwóch liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="03398-1972">The following code example shows how to create an expression that compares two integers.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-1973"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1973"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-1974">Operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-1974">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-1975"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1975">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-1976"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-1977"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-1977"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-1978">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1978">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-1979">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący "mniejsze niż lub równe" porównanie numeryczne.</span><span class="sxs-lookup"><span data-stu-id="03398-1979">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-1980">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-1980">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-1981">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-1981">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-1982"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1982">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-1983">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-1983">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-1984">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-1984">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-1985"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1985">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-1986">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-1986">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-1987">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-1987">Implementing Method</span></span>  
 <span data-ttu-id="03398-1988">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-1988">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-1989">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1989">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1990">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator "mniejsze niż lub równe" <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-1990">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the "less than or equal" operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1991">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-1991">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-1992">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-1992">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-1993">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1993">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-1994">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-1994">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-1995">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1995">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-1996">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-1996">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-1997">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-1997">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-1998">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-1998">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-1999">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-1999">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2000">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2000">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2001">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2001">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-2002">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2002">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2003">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2003">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2004"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2004"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2005"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2005"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2006"><paramref name="method" /> jest <see langword="null" /> i operator "mniejsze niż lub równe" nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2006"><paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2007">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2007">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="03398-2008">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość umożliwiająca ustawienie <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2008">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2009"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2009">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2010">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest ona polem ani właściwością.</span><span class="sxs-lookup"><span data-stu-id="03398-2010">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="03398-2011">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2011">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2012"><paramref name="member" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2012"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2013">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2013">-or-</span></span> 
<span data-ttu-id="03398-2014">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2014">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2015"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2015"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="03398-2016">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2016">-or-</span></span> 
<span data-ttu-id="03398-2017"><see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2017">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="03398-2018">A <see cref="T:System.Reflection.MemberInfo" /> reprezentująca pole lub właściwość umożliwiająca ustawienie <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2018">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2019">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2019">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2020">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> gdzie element członkowski jest ona polem ani właściwością.</span><span class="sxs-lookup"><span data-stu-id="03398-2020">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</span></span></summary>
        <returns><span data-ttu-id="03398-2021">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2021">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2022"><paramref name="member" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2022"><paramref name="member" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2023">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2023">-or-</span></span> 
<span data-ttu-id="03398-2024">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2024">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2025"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2025"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="03398-2026">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2026">-or-</span></span> 
<span data-ttu-id="03398-2027"><see cref="P:System.Reflection.FieldInfo.FieldType" /> Lub <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> pola lub właściwości, które <paramref name="member" /> reprezentuje nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2027">The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="03398-2028">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2028">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2029"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2029">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2030">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> na podstawie metody dostępu określonej właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2030">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-2031">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.MemberInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2031">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2032"><paramref name="propertyAccessor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2032"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2033">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2033">-or-</span></span> 
<span data-ttu-id="03398-2034">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2034">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2035"><paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2035"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="03398-2036">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2036">-or-</span></span> 
<span data-ttu-id="03398-2037"><see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, metody reprezentowanej przez <paramref name="propertyAccessor" /> uzyskuje dostęp do nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2037">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="03398-2038">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2038">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2039">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2039">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2040">Tworzy <see cref="T:System.Linq.Expressions.MemberListBinding" /> obiektu na podstawie określonej właściwości metody dostępu metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2040">Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-2041">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.MemberInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> wypełniane przy użyciu elementów <paramref name="initializers" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2041">A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2042"><paramref name="propertyAccessor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2042"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2043">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2043">-or-</span></span> 
<span data-ttu-id="03398-2044">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2044">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2045"><paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2045"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="03398-2046">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2046">-or-</span></span> 
<span data-ttu-id="03398-2047"><see cref="P:System.Reflection.PropertyInfo.PropertyType" /> Właściwości, metody reprezentowanej przez <paramref name="propertyAccessor" /> uzyskuje dostęp do nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2047">The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2048">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2048">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2049">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2049">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2050"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2050">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2051">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającego określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty do zainicjowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2051">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2052">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2052">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2053"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2053">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2054"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2054">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2055">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowego wystąpienia słownik za pomocą dwóch par klucz wartość.</span><span class="sxs-lookup"><span data-stu-id="03398-2055">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2056"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2056"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2057">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2057">-or-</span></span> 
<span data-ttu-id="03398-2058">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2058">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2059"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2059"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2060">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2060">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2061"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2061">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2062">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> korzystającą metodę o nazwie "Add", aby dodać elementy do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2062">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2063">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2063">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2064"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2064">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2065">Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2065">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="03398-2066">Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość pierwszy element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2066">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="03398-2067"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2067">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="03398-2068"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2068">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="03398-2069"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metodę add, które zostało wykryte na `newExpression`. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2069">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="03398-2070"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2070">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2071"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2071"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2072">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2072">-or-</span></span> 
<span data-ttu-id="03398-2073">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2073">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2074"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2074"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2075">Nie istnieje metoda instancji o nazwie "Add" (jest uwzględniana wielkość liter) zadeklarowane w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2075">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="03398-2076">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2076">-or-</span></span> 
<span data-ttu-id="03398-2077">Dodaj metodę na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2077">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="03398-2078">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2078">-or-</span></span> 
<span data-ttu-id="03398-2079">Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość pierwszy element <paramref name="initializers" /> nie można przypisać do typu argumentu metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2079">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="03398-2080">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2080">-or-</span></span> 
<span data-ttu-id="03398-2081">Istnieje więcej niż jednej metody zgodnym z argumentem o nazwie "Add" (bez uwzględniania wielkości liter), na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2081">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2082">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2082">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2083">Tablica <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2083">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2084">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> używającego określony <see cref="T:System.Linq.Expressions.ElementInit" /> obiekty do zainicjowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2084">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2085">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2085">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2086"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2086">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2087"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2087">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2088">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.ListInitExpression> reprezentujący inicjowania nowego wystąpienia słownik za pomocą dwóch par klucz wartość.</span><span class="sxs-lookup"><span data-stu-id="03398-2088">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> method to create a <xref:System.Linq.Expressions.ListInitExpression> that represents the initialization of a new dictionary instance with two key-value pairs.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2089"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2089"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2090">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2090">-or-</span></span> 
<span data-ttu-id="03398-2091">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2091">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2092"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2092"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2093">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2093">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2094">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2094">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2095">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> korzystającą metodę o nazwie "Add", aby dodać elementy do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2095">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2096">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2096">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2097"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2097">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2098">Aby można było używać tego przeciążenia <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2098">In order to use this overload of <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="03398-2099">Typ argumentu musi być możliwy do przypisania z typu reprezentowanego przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwość pierwszy element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2099">The type of the argument must be assignable from the type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of the first element of `initializers`.</span></span>  
  
 <span data-ttu-id="03398-2100"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2100">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="03398-2101"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2101">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="03398-2102"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> reprezentuje metodę add, które zostało wykryte na `newExpression`. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2102">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> represents the add method that was discovered on `newExpression`.Type or its base type.</span></span>  
  
 <span data-ttu-id="03398-2103"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2103">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2104"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2104"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2105">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2105">-or-</span></span> 
<span data-ttu-id="03398-2106">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2106">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2107"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2107"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2108">Nie istnieje metoda instancji o nazwie "Add" (jest uwzględniana wielkość liter) zadeklarowane w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2108">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="03398-2109">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2109">-or-</span></span> 
<span data-ttu-id="03398-2110">Dodaj metodę na <paramref name="newExpression" />. Typ lub jego typ podstawowy nie przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2110">The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.</span></span>  
  
<span data-ttu-id="03398-2111">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2111">-or-</span></span> 
<span data-ttu-id="03398-2112">Typ reprezentowany przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwość pierwszy element <paramref name="initializers" /> nie można przypisać do typu argumentu metody add w <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2112">The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.</span></span>  
  
<span data-ttu-id="03398-2113">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2113">-or-</span></span> 
<span data-ttu-id="03398-2114">Istnieje więcej niż jednej metody zgodnym z argumentem o nazwie "Add" (bez uwzględniania wielkości liter), na <paramref name="newExpression" />. Typ i/lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2114">More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2115">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2115">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="03398-2116">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę instancji o nazwie "Add" (wielkich liter), który dodaje element do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2116">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2117"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2117">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2118">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> , używa określonej metody dodawania elementów do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2118">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2119">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2119">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2120"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2120">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2121">Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2121">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="03398-2122">Jeśli `addMethod` nie `null`, musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), który ma dokładnie jeden parametr.</span><span class="sxs-lookup"><span data-stu-id="03398-2122">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="03398-2123">Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.</span><span class="sxs-lookup"><span data-stu-id="03398-2123">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="03398-2124"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2124">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="03398-2125"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2125">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="03398-2126"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="03398-2126">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="03398-2127"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2127">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2128"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2128"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2129">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2129">-or-</span></span> 
<span data-ttu-id="03398-2130">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2130">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2131"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2131"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="03398-2132">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2132">-or-</span></span> 
 <span data-ttu-id="03398-2133"><paramref name="addMethod" /> nie jest <see langword="null" /> reprezentuje metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2133"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="03398-2134">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2134">-or-</span></span> 
 <span data-ttu-id="03398-2135"><paramref name="addMethod" /> nie jest <see langword="null" /> i typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody, <paramref name="addMethod" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2135"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2136"><paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienie nazwane "Add", która przyjmuje jeden argument zgodnego z typem istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2136"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2137">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2137">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="addMethod"><span data-ttu-id="03398-2138">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący metodę wystąpienia, która przyjmuje jeden argument, który dodaje element do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2138">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2139">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2139">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2140">Tworzy <see cref="T:System.Linq.Expressions.ListInitExpression" /> , używa określonej metody dodawania elementów do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2140">Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</span></span></summary>
        <returns><span data-ttu-id="03398-2141">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> i <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2141">A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2142"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość `newExpression` musi reprezentować typ, który implementuje <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="03398-2142">The <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression` must represent a type that implements <xref:System.Collections.IEnumerable>.</span></span>  
  
 <span data-ttu-id="03398-2143">Jeśli `addMethod` jest `null`, `newExpression`. Typ lub jego typ podstawowy musi deklarować pojedynczą metodę o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2143">If `addMethod` is `null`, `newExpression`.Type or its base type must declare a single method named "Add" (case insensitive) that takes exactly one argument.</span></span> <span data-ttu-id="03398-2144">Jeśli `addMethod` nie `null`, musi reprezentować metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), który ma dokładnie jeden parametr.</span><span class="sxs-lookup"><span data-stu-id="03398-2144">If `addMethod` is not `null`, it must represent an instance method named "Add" (case insensitive) that has exactly one parameter.</span></span> <span data-ttu-id="03398-2145">Typ reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości każdego elementu `initializers` musi być można przypisać do typu argumentu metody add.</span><span class="sxs-lookup"><span data-stu-id="03398-2145">The type represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must be assignable to the argument type of the add method.</span></span>  
  
 <span data-ttu-id="03398-2146"><xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> Właściwości zwracanego <xref:System.Linq.Expressions.ListInitExpression> zawiera jeden element typu <xref:System.Linq.Expressions.ElementInit> dla każdego elementu `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2146">The <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> property of the returned <xref:System.Linq.Expressions.ListInitExpression> contains one element of type <xref:System.Linq.Expressions.ElementInit> for each element of `initializers`.</span></span> <span data-ttu-id="03398-2147"><xref:System.Linq.Expressions.ElementInit.Arguments%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest kolekcją singleton, zawierający odpowiedni element `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2147">The <xref:System.Linq.Expressions.ElementInit.Arguments%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is a singleton collection that contains the corresponding element of `initializers`.</span></span> <span data-ttu-id="03398-2148"><xref:System.Linq.Expressions.ElementInit.AddMethod%2A> Właściwości każdego elementu <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> jest równa `addMethod`.</span><span class="sxs-lookup"><span data-stu-id="03398-2148">The <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> property of each element of <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> is equal to `addMethod`.</span></span>  
  
 <span data-ttu-id="03398-2149"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.ListInitExpression> jest równa `newExpression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2149">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.ListInitExpression> is equal to `newExpression`.Type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2150"><paramref name="newExpression" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2150"><paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2151">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2151">-or-</span></span> 
<span data-ttu-id="03398-2152">Jeden lub więcej elementów <paramref name="initializers" /> są <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2152">One or more elements of <paramref name="initializers" /> are <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2153"><paramref name="newExpression" />. Typ nie implementuje <see cref="T:System.Collections.IEnumerable" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2153"><paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</span></span>  
  
<span data-ttu-id="03398-2154">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2154">-or-</span></span> 
 <span data-ttu-id="03398-2155"><paramref name="addMethod" /> nie jest <see langword="null" /> reprezentuje metodę instancji o nazwie "Add" (jest uwzględniana wielkość liter), która przyjmuje dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2155"><paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.</span></span>  
  
<span data-ttu-id="03398-2156">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2156">-or-</span></span> 
 <span data-ttu-id="03398-2157"><paramref name="addMethod" /> nie jest <see langword="null" /> i typu reprezentowanego przez <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości jednego lub więcej elementów <paramref name="initializers" /> nie można przypisać do typu argumentu metody, <paramref name="addMethod" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2157"><paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2158"><paramref name="addMethod" /> jest <see langword="null" /> i nie wystąpienie nazwane "Add", która przyjmuje jeden argument zgodnego z typem istnieje metoda na <paramref name="newExpression" />. Typ lub jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2158"><paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2159">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2159">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-2160">Treść pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2160">The body of the loop.</span></span></param>
        <summary><span data-ttu-id="03398-2161">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</span><span class="sxs-lookup"><span data-stu-id="03398-2161">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="03398-2162">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2162">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-2163">Treść pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2163">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="03398-2164">Obiekt docelowy podziału, używane w treści pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2164">The break target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="03398-2165">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> z danym elementem docelowym treści i podziału.</span><span class="sxs-lookup"><span data-stu-id="03398-2165">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</span></span></summary>
        <returns><span data-ttu-id="03398-2166">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2166">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-2167">Poniższy przykład przedstawia sposób tworzenia wyrażenia bloku, zawierającego <xref:System.Linq.Expressions.LoopExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2167">The following example demonstrates how to create a block expression that contains a <xref:System.Linq.Expressions.LoopExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-2168">Treść pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2168">The body of the loop.</span></span></param>
        <param name="break"><span data-ttu-id="03398-2169">Obiekt docelowy podziału, używane w treści pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2169">The break target used by the loop body.</span></span></param>
        <param name="continue"><span data-ttu-id="03398-2170">Obiekt docelowy Kontynuuj, używane w treści pętli.</span><span class="sxs-lookup"><span data-stu-id="03398-2170">The continue target used by the loop body.</span></span></param>
        <summary><span data-ttu-id="03398-2171">Tworzy <see cref="T:System.Linq.Expressions.LoopExpression" /> danej jednostki.</span><span class="sxs-lookup"><span data-stu-id="03398-2171">Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</span></span></summary>
        <returns><span data-ttu-id="03398-2172">Utworzony <see cref="T:System.Linq.Expressions.LoopExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2172">The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2173">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2173">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="03398-2174"><see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</span><span class="sxs-lookup"><span data-stu-id="03398-2174">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="03398-2175"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2175">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2176"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2176">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <summary><span data-ttu-id="03398-2177">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />, podane lewy i prawy operandów za pomocą wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2177">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-2178"><see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2178">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2179">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki wywołuje tę metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2179">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method calls.</span></span> <span data-ttu-id="03398-2180">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-2180">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2181">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> metodę w celu utworzenia <xref:System.Linq.Expressions.BinaryExpression> reprezentujący odejmowania jedną cyfrę z innego.</span><span class="sxs-lookup"><span data-stu-id="03398-2181">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> method to create a <xref:System.Linq.Expressions.BinaryExpression> that represents the subtraction of one number from another.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2182"><paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</span><span class="sxs-lookup"><span data-stu-id="03398-2182"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2183"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2183"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="03398-2184"><see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</span><span class="sxs-lookup"><span data-stu-id="03398-2184">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="03398-2185"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2185">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2186"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2186">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-2187"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2187"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2188">A <see cref="T:System.Reflection.MethodInfo" /> określający implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2188">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-2189">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand i implementacja metody, przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2189">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-2190"><see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2190">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2191">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki, Metoda ta będzie wywoływać.</span><span class="sxs-lookup"><span data-stu-id="03398-2191">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="03398-2192">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-2192">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="03398-2193">`liftToNull` i `method` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.</span><span class="sxs-lookup"><span data-stu-id="03398-2193">The `liftToNull` and `method` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2194"><paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</span><span class="sxs-lookup"><span data-stu-id="03398-2194"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2195"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2195"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType"><span data-ttu-id="03398-2196"><see cref="T:System.Linq.Expressions.ExpressionType" /> , Który określa rodzaj operacji binarnej.</span><span class="sxs-lookup"><span data-stu-id="03398-2196">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</span></span></param>
        <param name="left"><span data-ttu-id="03398-2197"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący lewy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2197">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2198"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący prawy operand.</span><span class="sxs-lookup"><span data-stu-id="03398-2198">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-2199"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2199"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2200">A <see cref="T:System.Reflection.MethodInfo" /> określający implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2200">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-2201">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> reprezentujący funkcji konwersji typu.</span><span class="sxs-lookup"><span data-stu-id="03398-2201">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</span></span> <span data-ttu-id="03398-2202">Ten parametr jest używany tylko wtedy, gdy <paramref name="binaryType" /> jest <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> lub przydział złożony.</span><span class="sxs-lookup"><span data-stu-id="03398-2202">This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment.</span></span></param>
        <summary><span data-ttu-id="03398-2203">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" />podany argument po lewej stronie, kliknij prawym przyciskiem myszy operand, implementacja metody i — typ funkcji konwersji, przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-2204"><see cref="T:System.Linq.Expressions.BinaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2204">The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2205">`binaryType` Określa parametr, który <xref:System.Linq.Expressions.BinaryExpression> metoda fabryki, Metoda ta będzie wywoływać.</span><span class="sxs-lookup"><span data-stu-id="03398-2205">The `binaryType` parameter determines which <xref:System.Linq.Expressions.BinaryExpression> factory method this method will call.</span></span> <span data-ttu-id="03398-2206">Na przykład jeśli `binaryType` jest <xref:System.Linq.Expressions.ExpressionType.Subtract>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-2206">For example, if `binaryType` is <xref:System.Linq.Expressions.ExpressionType.Subtract>, this method invokes <xref:System.Linq.Expressions.Expression.Subtract%2A>.</span></span> <span data-ttu-id="03398-2207">`liftToNull`, `method` i `conversion` parametry są ignorowane, jeśli metoda odpowiednie fabryki nie ma odpowiadającego mu parametru.</span><span class="sxs-lookup"><span data-stu-id="03398-2207">The `liftToNull`, `method` and `conversion` parameters are ignored if the appropriate factory method does not have a corresponding parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2208"><paramref name="binaryType" /> nie odnoszą się do węzła wyrażenia binarnego.</span><span class="sxs-lookup"><span data-stu-id="03398-2208"><paramref name="binaryType" /> does not correspond to a binary expression node.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2209"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2209"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2210"><see cref="P:System.Linq.Expressions.Expression.Type" /> z <see cref="T:System.Exception" /> to <see cref="T:System.Linq.Expressions.CatchBlock" /> będzie obsługiwać.</span><span class="sxs-lookup"><span data-stu-id="03398-2210">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</span></span></param>
        <param name="variable"><span data-ttu-id="03398-2211">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> reprezentujący odwołania do <see cref="T:System.Exception" /> obiektu przechwycony przez ten program obsługi.</span><span class="sxs-lookup"><span data-stu-id="03398-2211">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</span></span></param>
        <param name="body"><span data-ttu-id="03398-2212">Treść instrukcji catch.</span><span class="sxs-lookup"><span data-stu-id="03398-2212">The body of the catch statement.</span></span></param>
        <param name="filter"><span data-ttu-id="03398-2213">Treść <see cref="T:System.Exception" /> filtru.</span><span class="sxs-lookup"><span data-stu-id="03398-2213">The body of the <see cref="T:System.Exception" /> filter.</span></span></param>
        <summary><span data-ttu-id="03398-2214">Tworzy <see cref="T:System.Linq.Expressions.CatchBlock" /> reprezentujący instrukcja catch, przy użyciu określonych elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-2214">Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="03398-2215">Utworzony <see cref="T:System.Linq.Expressions.CatchBlock" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2215">The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2216">`type` musi być równa null i jest zgodny z typem `variable` (jeśli go podano).</span><span class="sxs-lookup"><span data-stu-id="03398-2216">`type` must be non-null and match the type of `variable` (if it is supplied).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2217">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną.</span><span class="sxs-lookup"><span data-stu-id="03398-2217">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2218">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2218">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2219">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2219">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2220">Argumenty operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2220">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2221">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2221">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-2222">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2222">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2223">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2223">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2224">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2224">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-2225">Argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2225">The argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2226">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i jeden argument.</span><span class="sxs-lookup"><span data-stu-id="03398-2226">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</span></span></summary>
        <returns><span data-ttu-id="03398-2227">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2227">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2228">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2228">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2229">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2229">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2230">Argumenty operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2230">The arguments to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2231">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2231">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</span></span></summary>
        <returns><span data-ttu-id="03398-2232">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2232">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2233">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2233">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2234">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2234">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-2235">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2235">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-2236">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2236">The second argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2237">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i dwa argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-2237">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2238">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2238">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2239">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2239">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2240">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2240">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-2241">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2241">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-2242">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2242">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-2243">Trzeci argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2243">The third argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2244">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i trzy argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-2244">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2245">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2245">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="03398-2246">Typ delegata używany przez <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2246">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</span></span></param>
        <param name="binder"><span data-ttu-id="03398-2247">Obiekt wiążący środowiska uruchomieniowego dla operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2247">The runtime binder for the dynamic operation.</span></span></param>
        <param name="arg0"><span data-ttu-id="03398-2248">Pierwszy argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2248">The first argument to the dynamic operation.</span></span></param>
        <param name="arg1"><span data-ttu-id="03398-2249">Drugi argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2249">The second argument to the dynamic operation.</span></span></param>
        <param name="arg2"><span data-ttu-id="03398-2250">Trzeci argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2250">The third argument to the dynamic operation.</span></span></param>
        <param name="arg3"><span data-ttu-id="03398-2251">Czwarty argument operacji dynamicznej.</span><span class="sxs-lookup"><span data-stu-id="03398-2251">The fourth argument to the dynamic operation.</span></span></param>
        <summary><span data-ttu-id="03398-2252">Tworzy <see cref="T:System.Linq.Expressions.DynamicExpression" /> reprezentujący operację dynamiczną przez podany <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> i cztery argumenty.</span><span class="sxs-lookup"><span data-stu-id="03398-2252">Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2253">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> i ma <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, i <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> równa określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2253">A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><span data-ttu-id="03398-2254"><see cref="T:System.Linq.Expressions.GotoExpressionKind" /> z <see cref="T:System.Linq.Expressions.GotoExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2254">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</span></span></param>
        <param name="target"><span data-ttu-id="03398-2255"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-2255">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-2256">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-2256">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="03398-2257"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2257">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2258">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący przeskoku określonego <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2258">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />.</span></span> <span data-ttu-id="03398-2259">Wartość przekazana do etykiety po przeskakiwanie można również określić.</span><span class="sxs-lookup"><span data-stu-id="03398-2259">The value passed to the label upon jumping can also be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-2260">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa <paramref name="kind" />, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-2260">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-2261">Obiekt, do której należy właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2261">The object to which the property belongs.</span></span> <span data-ttu-id="03398-2262">Powinna to być wartość null, jeśli właściwość jest <see langword="static" /> (<see langword="shared" /> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="03398-2262">It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</span></span></param>
        <param name="indexer"><span data-ttu-id="03398-2263"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujące właściwość do indeksu.</span><span class="sxs-lookup"><span data-stu-id="03398-2263">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2264"><c>IEnumerable&lt;wyrażenie&gt;</c> (<c>IEnumerable (programu Expression)</c> w języku Visual Basic) zawiera argumenty, które będą używane do indeksowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2264">An <c>IEnumerable&lt;Expression&gt;</c> (<c>IEnumerable (Of Expression)</c> in Visual Basic) that contains the arguments that will be used to index the property.</span></span></param>
        <summary><span data-ttu-id="03398-2265">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentująca dostęp do właściwości indeksowanych w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="03398-2265">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</span></span></summary>
        <returns><span data-ttu-id="03398-2266">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2266">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2267"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentująca obiekt, który należy do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="03398-2267">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to.</span></span> <span data-ttu-id="03398-2268">Może to być wartość null dla statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="03398-2268">This can be null for static members.</span></span></param>
        <param name="member"><span data-ttu-id="03398-2269"><see cref="T:System.Reflection.MemberInfo" /> Opisujący pola lub właściwości, które były dostępne.</span><span class="sxs-lookup"><span data-stu-id="03398-2269">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-2270">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2270">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</span></span></summary>
        <returns><span data-ttu-id="03398-2271"><see cref="T:System.Linq.Expressions.MemberExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2271">The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2272">Ta metoda może służyć do tworzenia <xref:System.Linq.Expressions.MemberExpression> reprezentująca dostęp do pola lub właściwości, w zależności od typu `member`.</span><span class="sxs-lookup"><span data-stu-id="03398-2272">This method can be used to create a <xref:System.Linq.Expressions.MemberExpression> that represents accessing either a field or a property, depending on the type of `member`.</span></span> <span data-ttu-id="03398-2273">Jeśli `member` typu <xref:System.Reflection.FieldInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Field%2A> utworzyć <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-2273">If `member` is of type <xref:System.Reflection.FieldInfo>, this method calls <xref:System.Linq.Expressions.Expression.Field%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span> <span data-ttu-id="03398-2274">Jeśli `member` typu <xref:System.Reflection.PropertyInfo>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Property%2A> utworzyć <xref:System.Linq.Expressions.MemberExpression>.</span><span class="sxs-lookup"><span data-stu-id="03398-2274">If `member` is of type <xref:System.Reflection.PropertyInfo>, this method calls <xref:System.Linq.Expressions.Expression.Property%2A> to create the <xref:System.Linq.Expressions.MemberExpression>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2275"><paramref name="member" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2275"><paramref name="member" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2276"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2276"><paramref name="member" /> does not represent a field or property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2277">Typ wyniku wyrażenia try.</span><span class="sxs-lookup"><span data-stu-id="03398-2277">The result type of the try expression.</span></span> <span data-ttu-id="03398-2278">Jeśli ma wartość null, bodh i całej obsługi muszą mieć identyczne typu.</span><span class="sxs-lookup"><span data-stu-id="03398-2278">If null, bodh and all handlers must have identical type.</span></span></param>
        <param name="body"><span data-ttu-id="03398-2279">Treści bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-2279">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="03398-2280">Treści bloku finally.</span><span class="sxs-lookup"><span data-stu-id="03398-2280">The body of the finally block.</span></span> <span data-ttu-id="03398-2281">Należy przekazać wartość null, jeśli blok try ma nie na koniec bloku skojarzonych z nim.</span><span class="sxs-lookup"><span data-stu-id="03398-2281">Pass null if the try block has no finally block associated with it.</span></span></param>
        <param name="fault"><span data-ttu-id="03398-2282">Treść bloku błędów.</span><span class="sxs-lookup"><span data-stu-id="03398-2282">The body of the fault block.</span></span> <span data-ttu-id="03398-2283">Należy przekazać wartość null, jeśli blok try ma nie bloku błędów skojarzonych z nim.</span><span class="sxs-lookup"><span data-stu-id="03398-2283">Pass null if the try block has no fault block associated with it.</span></span></param>
        <param name="handlers"><span data-ttu-id="03398-2284">Kolekcja <see cref="T:System.Linq.Expressions.CatchBlock" />s reprezentujący instrukcji catch, który ma zostać skojarzony z bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-2284">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="03398-2285">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z określonych elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-2285">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</span></span></summary>
        <returns><span data-ttu-id="03398-2286">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2286">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2287">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2287">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> by calling the appropriate factory method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="03398-2288"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</span><span class="sxs-lookup"><span data-stu-id="03398-2288">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="03398-2289"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</span><span class="sxs-lookup"><span data-stu-id="03398-2289">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="03398-2290"><see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</span><span class="sxs-lookup"><span data-stu-id="03398-2290">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <summary><span data-ttu-id="03398-2291">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument operacji, przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2291">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-2292"><see cref="T:System.Linq.Expressions.UnaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2292">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2293">`unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> metoda fabryki wywołuje tę metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2293">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="03398-2294">Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-2294">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="03398-2295">`type`Parametr jest ignorowany, jeśli nie ma zastosowania do metody fabryka, która jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="03398-2295">The `type`parameter is ignored if it does not apply to the factory method that is called.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2296"><paramref name="operand" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2296"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2297"><paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</span><span class="sxs-lookup"><span data-stu-id="03398-2297"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType"><span data-ttu-id="03398-2298"><see cref="T:System.Linq.Expressions.ExpressionType" /> Określająca typ operację jednoargumentową.</span><span class="sxs-lookup"><span data-stu-id="03398-2298">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</span></span></param>
        <param name="operand"><span data-ttu-id="03398-2299"><see cref="T:System.Linq.Expressions.Expression" /> Reprezentujący argument.</span><span class="sxs-lookup"><span data-stu-id="03398-2299">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</span></span></param>
        <param name="type"><span data-ttu-id="03398-2300"><see cref="T:System.Type" /> , Który określa typ, który ma zostać przekonwertowane na (przekazać <see langword="null" /> Jeśli nie ma to zastosowanie).</span><span class="sxs-lookup"><span data-stu-id="03398-2300">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</span></span></param>
        <param name="method"><span data-ttu-id="03398-2301"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2301">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-2302">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" />, podany argument i implementacja metody, przez wywołanie metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2302">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</span></span></summary>
        <returns><span data-ttu-id="03398-2303"><see cref="T:System.Linq.Expressions.UnaryExpression" /> , Wynika z wywołania metody odpowiedniej fabryki.</span><span class="sxs-lookup"><span data-stu-id="03398-2303">The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2304">`unaryType` Określa parametr, który <xref:System.Linq.Expressions.UnaryExpression> metoda fabryki wywołuje tę metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2304">The `unaryType` parameter determines which <xref:System.Linq.Expressions.UnaryExpression> factory method this method calls.</span></span> <span data-ttu-id="03398-2305">Na przykład jeśli `unaryType` jest równa <xref:System.Linq.Expressions.ExpressionType.Convert>, ta metoda wywołuje <xref:System.Linq.Expressions.Expression.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-2305">For example, if `unaryType` is equal to <xref:System.Linq.Expressions.ExpressionType.Convert>, this method invokes <xref:System.Linq.Expressions.Expression.Convert%2A>.</span></span> <span data-ttu-id="03398-2306">`type` i `method` parametry są ignorowane, jeśli nie mają zastosowania do metody fabryka, która jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="03398-2306">The `type` and `method` parameters are ignored if they do not apply to the factory method that is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2307"><paramref name="operand" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2307"><paramref name="operand" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2308"><paramref name="unaryType" /> nie odpowiada na węzeł wyrażenie jednoargumentowe.</span><span class="sxs-lookup"><span data-stu-id="03398-2308"><paramref name="unaryType" /> does not correspond to a unary expression node.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2309">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cyklicznego inicjowanie elementów członkowskich elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="03398-2309">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="03398-2310"><see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2310">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2311"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2311">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2312">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne inicjowanie elementów członkowskich pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2312">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="03398-2313">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2313">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2314">`member` Parametru musi reprezentować pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2314">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2315"><paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2315"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2316"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2316"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="03398-2317">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2317">-or-</span></span> 
<span data-ttu-id="03398-2318"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2318">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="03398-2319"><see cref="T:System.Reflection.MemberInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2319">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2320">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2320">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2321">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący cykliczne inicjowanie elementów członkowskich pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2321">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</span></span></summary>
        <returns><span data-ttu-id="03398-2322">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> i <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2322">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2323">`member` Parametru musi reprezentować pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2323">The `member` parameter must represent a field or property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2324"><paramref name="member" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2324"><paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2325"><paramref name="member" /> nie reprezentuje pole lub właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-2325"><paramref name="member" /> does not represent a field or property.</span></span>  
  
<span data-ttu-id="03398-2326">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2326">-or-</span></span> 
<span data-ttu-id="03398-2327"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu pola lub właściwości, które <paramref name="member" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2327">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="03398-2328"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2328">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2329"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2329">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2330">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania cyklicznego elementów członkowskich elementu członkowskiego, która jest dostępna za pomocą metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2330">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-2331">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2331">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2332"><paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2332"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2333"><paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2333"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="03398-2334">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2334">-or-</span></span> 
<span data-ttu-id="03398-2335"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu właściwości używane przez metodę która <paramref name="propertyAccessor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2335">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor"><span data-ttu-id="03398-2336"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2336">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2337">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2337">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2338">Tworzy <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> reprezentujący inicjowania cyklicznego elementów członkowskich elementu członkowskiego, która jest dostępna za pomocą metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2338">Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-2339">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> zawierający <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> równa właściwości <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />, i <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2339">A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2340"><paramref name="propertyAccessor" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2340"><paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2341"><paramref name="propertyAccessor" /> reprezentuje metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2341"><paramref name="propertyAccessor" /> does not represent a property accessor method.</span></span>  
  
<span data-ttu-id="03398-2342">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2342">-or-</span></span> 
<span data-ttu-id="03398-2343"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje elementem członkowskim typu właściwości używane przez metodę która <paramref name="propertyAccessor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2343">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2344">Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2344">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2345">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2345">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2346"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2346">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2347">Reprezentuje wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2347">Represents an expression that creates a new object and initializes a property of the object.</span></span></summary>
        <returns><span data-ttu-id="03398-2348">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2348">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2349"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="03398-2349">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2350">W poniższym przykładzie pokazano wyrażenie, które tworzy nowy obiekt i inicjuje właściwość obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2350">The following example demonstrates an expression that creates a new object and initializes a property of the object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2351"><paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2351"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2352"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje członek typu, <paramref name="newExpression" />. Wpisz reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2352">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><span data-ttu-id="03398-2353">A <see cref="T:System.Linq.Expressions.NewExpression" /> można ustawić <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2353">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</span></span></param>
        <param name="bindings"><span data-ttu-id="03398-2354">Tablica <see cref="T:System.Linq.Expressions.MemberBinding" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2354">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2355">Tworzy <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2355">Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-2356">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> i <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2356">A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2357"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberInitExpression> jest równa <xref:System.Linq.Expressions.Expression.Type%2A> właściwość `newExpression`.</span><span class="sxs-lookup"><span data-stu-id="03398-2357">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberInitExpression> is equal to the <xref:System.Linq.Expressions.Expression.Type%2A> property of `newExpression`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2358">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> metodę w celu utworzenia <xref:System.Linq.Expressions.MemberInitExpression> reprezentujący inicjowania dwa elementy członkowskie nowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-2358">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> method to create a <xref:System.Linq.Expressions.MemberInitExpression> that represents the initialization of two members of a new object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2359"><paramref name="newExpression" /> lub <paramref name="bindings" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2359"><paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2360"><see cref="P:System.Linq.Expressions.MemberBinding.Member" /> Właściwość elementu <paramref name="bindings" /> nie reprezentuje członek typu, <paramref name="newExpression" />. Wpisz reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2360">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2361">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2362"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2363"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2364">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2366">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2367"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2368">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2369">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2369">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2370"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2371">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2372">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2372">Implementing Method</span></span>  
 <span data-ttu-id="03398-2373">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2374">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator modulo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2375">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2375">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2376">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2377">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2378">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2379">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2380">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2381">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2382">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2383">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2384">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2385">Typ węzła jest typ wyniku operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2385">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="03398-2386">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2387">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2387">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2388"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2389">Operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2389">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2390"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2391"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2392">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2393">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operacji arytmetycznych resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2395">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2396"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2397">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2398">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2398">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2399"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2400">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2401">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2401">Implementing Method</span></span>  
 <span data-ttu-id="03398-2402">Implementującej metody dla tej operacji jest wybierany w oparciu o następujące reguły:</span><span class="sxs-lookup"><span data-stu-id="03398-2402">The implementing method for the operation is chosen based on the following rules:</span></span>  
  
-   <span data-ttu-id="03398-2403">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2404">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator modulo <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the modulus operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2405">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2405">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2406">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2407">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2408">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2409">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2410">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2411">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2412">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2413">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2414">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2415">Typ węzła jest typ wyniku operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2415">The type of the node is the result type of the predefined modulus operator.</span></span>  
  
-   <span data-ttu-id="03398-2416">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2417">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator modulo wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2417">The type of the node is the nullable type that corresponds to the result type of the predefined modulus operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2418"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2419"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2420"><paramref name="method" /> jest <see langword="null" /> i operator modulo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2420"><paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2421">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2422"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2423"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2424">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2426"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2427"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2428">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2429">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2431"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2432"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2433">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-2434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2435">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania resztę.</span><span class="sxs-lookup"><span data-stu-id="03398-2435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2437">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2437">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2438"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2438">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2439"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2439">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2440">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2440">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2441">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2442">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2442">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2443"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2443">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2444">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2444">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2445">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2445">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2446"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2446">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2447">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2447">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2448">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2448">Implementing Method</span></span>  
 <span data-ttu-id="03398-2449">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2449">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2450">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2450">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2451">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2451">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2452">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2452">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2453">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2453">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2454">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2454">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2455">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2455">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2456">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2456">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2457">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2457">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2458">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2458">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2459">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2459">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2460">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2460">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2461">Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2461">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="03398-2462">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2462">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2463">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2463">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2464">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które mnoży dwie wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2464">The following code example shows how to create an expression that multiplies two values.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2465"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2465"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2466">Nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2466">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2467"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2467">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2468"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2468">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2469">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2469">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2470">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2470">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2471">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2471">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2472">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2472">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2473"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2473">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2474">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2474">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2475">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2475">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2476"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2476">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2477">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2477">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2478">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2478">Implementing Method</span></span>  
 <span data-ttu-id="03398-2479">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2479">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2480">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2480">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2481">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2481">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2482">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2482">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2483">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2483">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2484">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2484">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2485">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2485">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2486">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2486">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2487">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2487">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2488">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2488">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2489">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2489">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2490">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2490">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2491">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2491">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2492">Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2492">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="03398-2493">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2493">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2494">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2494">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2495"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2495"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2496"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2496"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2497"><paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2497"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2498">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2498">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2499"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2499">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2500"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2500">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2501">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2501">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2502">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2502">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2503"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2503">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2504"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2504">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2505">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2505">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2506">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2506">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2507">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2508"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2508">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2509"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2509">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2510">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2510">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-2511">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2511">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2512">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2512">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2513">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2514">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2514">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2515"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2516"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2517">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2517">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2518">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2519"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2519">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2520"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2520">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2521">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2521">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2522">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2522">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2523">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2524"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2524">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2525"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2525">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2526">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2526">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-2527">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2527">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2528">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację przypisania mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2528">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2529">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2530">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2530">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2531"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2532"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2533">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2533">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2534">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2535">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2535">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2536"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2536">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2537">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2537">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2538">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2538">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2539"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2539">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2540">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2540">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2541">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2541">Implementing Method</span></span>  
 <span data-ttu-id="03398-2542">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2542">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2543">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2543">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2544">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2544">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2545">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2545">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2546">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2546">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2547">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2547">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2548">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2548">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2549">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2549">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2550">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2550">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2551">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2551">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2552">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2552">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2553">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2553">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2554">Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2554">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="03398-2555">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2555">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2556">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2556">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2557"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2557"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2558">Nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2558">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2559"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2559">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2560"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2560">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2561">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2561">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2562">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację arytmetyczną mnożenia, która ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2562">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2563">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2563">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2564">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2564">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2565"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2565">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2566">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2566">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2567">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2567">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2568"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2568">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2569">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2569">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2570">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2570">Implementing Method</span></span>  
 <span data-ttu-id="03398-2571">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2571">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2572">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2572">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2573">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator mnożenia <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2573">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the multiplication operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2574">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2574">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2575">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2575">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2576">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2576">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2577">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2577">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2578">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2578">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2579">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2579">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2580">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2580">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2581">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2581">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2582">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2582">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2583">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2583">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2584">Typ węzła jest typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2584">The type of the node is the result type of the predefined multiplication operator.</span></span>  
  
-   <span data-ttu-id="03398-2585">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2585">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2586">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator mnożenia wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-2586">The type of the node is the nullable type that corresponds to the result type of the predefined multiplication operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2587"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2587"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2588"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2588"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2589"><paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator mnożenia dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2589"><paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2590">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2590">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2591"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2591">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2592">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2592">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2593">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2593">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2594"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2594">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2595"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2595">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2596">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2596">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2597">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-2597">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2598">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2598">Implementing Method</span></span>  
 <span data-ttu-id="03398-2599">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2599">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2600">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2600">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2601">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2601">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2602">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2602">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2603">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2603">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2604">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2604">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2605">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2605">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2606">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2606">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2607">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2607">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2608">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2608">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2609">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2609">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2610">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2610">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2611">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2611">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2612">Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje operację arytmetyczny negacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2612">The following example demonstrates how to create an expression that represents an arithmetic negation operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2613"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2613"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2614">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2614">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2615"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2615">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2616">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2616">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2617">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2617">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2618">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2618">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2619"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2619">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2620"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2620">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2621">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2621">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2622">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-2622">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2623">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2623">Implementing Method</span></span>  
 <span data-ttu-id="03398-2624">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2624">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2625">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2625">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2626">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2626">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2627">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2627">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2628">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2628">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2629">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2629">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2630">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2630">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2631">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2631">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2632">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2632">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2633">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2633">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2634">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2634">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2635">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2635">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2636">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2636">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2637">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2637">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2638"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2638"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2639"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2639"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2640"><paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2640"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="03398-2641">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2641">-or-</span></span> 
 <span data-ttu-id="03398-2642"><paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2642"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2643">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2643">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2644"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2644">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2645">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2645">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-2646">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2646">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2647"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2647">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2648"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2648">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2649">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2649">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2650">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-2650">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2651">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2651">Implementing Method</span></span>  
 <span data-ttu-id="03398-2652">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2652">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2653">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2653">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2654">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2654">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2655">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2655">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2656">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2656">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2657">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2657">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2658">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2658">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2659">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2659">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2660">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2660">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2661">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2661">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2662">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2662">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2663">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2663">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2664">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2664">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2665"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2665"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2666">Jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2666">The unary minus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2667"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2667">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2668">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2668">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2669">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację arytmetyczny negacji, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2669">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</span></span> <span data-ttu-id="03398-2670">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-2670">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-2671">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2671">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2672"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2672">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2673"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2673">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2674">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2674">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2675">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-2675">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2676">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2676">Implementing Method</span></span>  
 <span data-ttu-id="03398-2677">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2677">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2678">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2678">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2679">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje Jednoargumentowy operator odejmowania, <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2679">If `expression`.Type is a user-defined type that defines the unary minus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2680">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2680">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2681">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2681">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2682">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2682">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2683">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2683">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2684">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2684">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2685">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2685">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2686">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2686">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2687">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2687">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2688">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2688">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2689">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2689">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2690">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2690">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2691"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2691"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2692"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2692"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2693"><paramref name="method" /> jest <see langword="null" /> i jednoargumentowy minus operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2693"><paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="03398-2694">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2694">-or-</span></span> 
 <span data-ttu-id="03398-2695"><paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2695"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2696">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2696">Creates a <see cref="T:System.Linq.Expressions.NewExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="03398-2697"><see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2697">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2698">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie określonego konstruktora, który nie przyjmuje żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2698">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2699">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2699">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2700"><xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości wynikające <xref:System.Linq.Expressions.NewExpression> są puste kolekcje.</span><span class="sxs-lookup"><span data-stu-id="03398-2700">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="03398-2701"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2701">The <xref:System.Linq.Expressions.Expression.Type%2A> property represents the declaring type of the constructor represented by `constructor`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2702"><paramref name="constructor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2702"><paramref name="constructor" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2703">Konstruktor, <paramref name="constructor" /> reprezentuje ma co najmniej jeden parametr.</span><span class="sxs-lookup"><span data-stu-id="03398-2703">The constructor that <paramref name="constructor" /> represents has at least one parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2704">Element <see cref="T:System.Type" /> ma konstruktora, który nie przyjmuje żadnych argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2704">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</span></span></param>
        <summary><span data-ttu-id="03398-2705">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora bez parametrów dla określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-2705">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> właściwością <see cref="T:System.Reflection.ConstructorInfo" /> reprezentujący konstruktora bez parametrów dla określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-2706">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2707">`type` Parametru musi reprezentować typ, który ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="03398-2707">The `type` parameter must represent a type that has a constructor without parameters.</span></span>  
  
 <span data-ttu-id="03398-2708"><xref:System.Linq.Expressions.NewExpression.Arguments%2A> i <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwości wynikające <xref:System.Linq.Expressions.NewExpression> są puste kolekcje.</span><span class="sxs-lookup"><span data-stu-id="03398-2708">The <xref:System.Linq.Expressions.NewExpression.Arguments%2A> and <xref:System.Linq.Expressions.NewExpression.Members%2A> properties of the resulting <xref:System.Linq.Expressions.NewExpression> are empty collections.</span></span> <span data-ttu-id="03398-2709"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości jest równa `type`.</span><span class="sxs-lookup"><span data-stu-id="03398-2709">The <xref:System.Linq.Expressions.Expression.Type%2A> property is equal to `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2710">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.New%28System.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.NewExpression> reprezentujący tworzenia nowego wystąpienia obiektu słownika przez wywołanie konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="03398-2710">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.New%28System.Type%29> method to create a <xref:System.Linq.Expressions.NewExpression> that represents constructing a new instance of a dictionary object by calling the constructor without parameters.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2711"><paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2711"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2712">Typ, <paramref name="type" /> reprezentuje nie ma konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="03398-2712">The type that <paramref name="type" /> represents does not have a constructor without parameters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="03398-2713"><see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2713">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2714"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2714">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2715">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-2715">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2716">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2716">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2717">`arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2717">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2718">Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2718">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="03398-2719"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2719">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2720"><xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pusta kolekcja.</span><span class="sxs-lookup"><span data-stu-id="03398-2720">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2721"><paramref name="constructor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2721"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2722">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2722">-or-</span></span> 
<span data-ttu-id="03398-2723">Element <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2723">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2724"><paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2724">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2725">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2725">-or-</span></span> 
<span data-ttu-id="03398-2726"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2726">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="03398-2727"><see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2727">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2728">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2728">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2729">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-2729">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-2730">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> i <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2730">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2731">`arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2731">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2732">Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2732">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="03398-2733"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2734"><xref:System.Linq.Expressions.NewExpression.Members%2A> Właściwość jest pusta kolekcja.</span><span class="sxs-lookup"><span data-stu-id="03398-2734">The <xref:System.Linq.Expressions.NewExpression.Members%2A> property is an empty collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2735"><paramref name="constructor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2735"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2736">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2736">-or-</span></span> 
<span data-ttu-id="03398-2737">Element <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2737">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2738">Długość <paramref name="arguments" /> jest zgodna z liczbą parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2738">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2739">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2739">-or-</span></span> 
<span data-ttu-id="03398-2740"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2740">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="03398-2741"><see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2741">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2742"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2742">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="03398-2743"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2743">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2744">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-2744">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="03398-2745">Elementy członkowskie, które uzyskują dostęp do pól Konstruktor inicjowane są określone.</span><span class="sxs-lookup"><span data-stu-id="03398-2745">The members that access the constructor initialized fields are specified.</span></span></summary>
        <returns><span data-ttu-id="03398-2746">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2746">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2747">`arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2747">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2748">Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2748">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="03398-2749">Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2749">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="03398-2750">Jeśli `members` nie `null`, musi mieć taką samą liczbę elementów jako `arguments` i każdy element nie może być `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2750">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="03398-2751">Każdy element obiektu `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia typu deklarującego konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2751">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2752">Jeśli termin reprezentuje właściwości, właściwość musi mieć `get` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="03398-2752">If it represents a property, the property must have a `get` accessor.</span></span> <span data-ttu-id="03398-2753">Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego, który `members` element reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2753">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="03398-2754"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, `constructor` reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2754">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2755"><paramref name="constructor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2755"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2756">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2756">-or-</span></span> 
<span data-ttu-id="03398-2757">Element <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2757">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2758">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2758">-or-</span></span> 
<span data-ttu-id="03398-2759">Element <paramref name="members" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2759">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2760"><paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2760">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2761">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2761">-or-</span></span> 
<span data-ttu-id="03398-2762"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2762">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2763">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2763">-or-</span></span> 
<span data-ttu-id="03398-2764"><paramref name="members" /> Parametr nie ma taką samą liczbę elementów jako <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2764">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="03398-2765">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2765">-or-</span></span> 
<span data-ttu-id="03398-2766">Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości, który reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego, który jest reprezentowany przez odpowiedni element <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2766">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><span data-ttu-id="03398-2767"><see cref="T:System.Reflection.ConstructorInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2767">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-2768"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2768">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</span></span></param>
        <param name="members"><span data-ttu-id="03398-2769">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewExpression.Members" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2769">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2770">Tworzy <see cref="T:System.Linq.Expressions.NewExpression" /> reprezentujący wywołanie konstruktora określonego z określonymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="03398-2770">Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</span></span> <span data-ttu-id="03398-2771">Elementy członkowskie, które uzyskują dostęp do pól Konstruktor inicjowane są określane jako tablica.</span><span class="sxs-lookup"><span data-stu-id="03398-2771">The members that access the constructor initialized fields are specified as an array.</span></span></summary>
        <returns><span data-ttu-id="03398-2772">A <see cref="T:System.Linq.Expressions.NewExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.New" /> i <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> i <see cref="P:System.Linq.Expressions.NewExpression.Members" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2772">A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2773">`arguments` Parametr musi zawierać taką samą liczbę elementów jako liczba parametrów dla konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2773">The `arguments` parameter must contain the same number of elements as the number of parameters for the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2774">Jeśli `arguments` jest `null`, jest uznawane za pusta i <xref:System.Linq.Expressions.NewExpression.Arguments%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2774">If `arguments` is `null`, it is considered empty, and the <xref:System.Linq.Expressions.NewExpression.Arguments%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span>  
  
 <span data-ttu-id="03398-2775">Jeśli `members` jest `null`, <xref:System.Linq.Expressions.NewExpression.Members%2A> właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> jest pustą kolekcją.</span><span class="sxs-lookup"><span data-stu-id="03398-2775">If `members` is `null`, the <xref:System.Linq.Expressions.NewExpression.Members%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> is an empty collection.</span></span> <span data-ttu-id="03398-2776">Jeśli `members` nie `null`, musi mieć taką samą liczbę elementów jako `arguments` i każdy element nie może być `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2776">If `members` is not `null`, it must have the same number of elements as `arguments` and each element must not be `null`.</span></span> <span data-ttu-id="03398-2777">Każdy element obiektu `members` musi być <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> lub <xref:System.Reflection.MethodInfo> reprezentujący elementu członkowskiego wystąpienia typu deklarującego konstruktora, reprezentowane przez `constructor`.</span><span class="sxs-lookup"><span data-stu-id="03398-2777">Each element of `members` must be a <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> or <xref:System.Reflection.MethodInfo> that represents an instance member on the declaring type of the constructor represented by `constructor`.</span></span> <span data-ttu-id="03398-2778">Jeśli termin reprezentuje właściwości, właściwość musi być możliwe do pobrania wartości pól skojarzone.</span><span class="sxs-lookup"><span data-stu-id="03398-2778">If it represents a property, the property must be able to retrieve the value of the associated field.</span></span> <span data-ttu-id="03398-2779">Odpowiedni element `arguments` dla każdego elementu `members` musi mieć <xref:System.Linq.Expressions.Expression.Type%2A> właściwość, która reprezentuje typ, który można przypisać do typu elementu członkowskiego, który `members` element reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2779">The corresponding element of `arguments` for each element of `members` must have a <xref:System.Linq.Expressions.Expression.Type%2A> property that represents a type that is assignable to the type of the member that the `members` element represents.</span></span>  
  
 <span data-ttu-id="03398-2780"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewExpression> reprezentuje typ deklarujący konstruktora, `constructor` reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2780">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewExpression> represents the declaring type of the constructor that `constructor` represents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2781"><paramref name="constructor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2781"><paramref name="constructor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2782">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2782">-or-</span></span> 
<span data-ttu-id="03398-2783">Element <paramref name="arguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2783">An element of <paramref name="arguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2784">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2784">-or-</span></span> 
<span data-ttu-id="03398-2785">Element <paramref name="members" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2785">An element of <paramref name="members" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2786"><paramref name="arguments" /> Parametr nie zawiera taką samą liczbę elementów jako liczba parametrów dla konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2786">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2787">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2787">-or-</span></span> 
<span data-ttu-id="03398-2788"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="arguments" /> nie można przypisać do typu odpowiedniego parametru konstruktora, <paramref name="constructor" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2788">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</span></span>  
  
<span data-ttu-id="03398-2789">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2789">-or-</span></span> 
<span data-ttu-id="03398-2790"><paramref name="members" /> Parametr nie ma taką samą liczbę elementów jako <paramref name="arguments" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2790">The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.</span></span>  
  
<span data-ttu-id="03398-2791">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2791">-or-</span></span> 
<span data-ttu-id="03398-2792">Element <paramref name="arguments" /> ma <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwości, który reprezentuje typ, który nie jest możliwy do przypisania do typu elementu członkowskiego, który jest reprezentowany przez odpowiedni element <paramref name="members" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2792">An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2793">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</span><span class="sxs-lookup"><span data-stu-id="03398-2793">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2794">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-2794">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="03398-2795"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2795">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2796">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</span><span class="sxs-lookup"><span data-stu-id="03398-2796">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="03398-2797">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2797">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2798"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, w której pozycję jest równa długości `bounds` i którego typ elementu jest `type`.</span><span class="sxs-lookup"><span data-stu-id="03398-2798">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="03398-2799"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi reprezentować typ całkowitoliczbowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2799">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2800">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy ciągów, która ma pozycję 2.</span><span class="sxs-lookup"><span data-stu-id="03398-2800">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2801"><paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2801"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2802">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2802">-or-</span></span> 
<span data-ttu-id="03398-2803">Element <paramref name="bounds" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2803">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2804"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="bounds" /> nie reprezentuje typ całkowitoliczbowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2804">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2805">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-2805">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="bounds"><span data-ttu-id="03398-2806">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2806">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2807">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentujący tworzenie tablicy, który ma określony stopień.</span><span class="sxs-lookup"><span data-stu-id="03398-2807">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</span></span></summary>
        <returns><span data-ttu-id="03398-2808">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2808">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2809"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy, w której pozycję jest równa długości `bounds` i którego typ elementu jest `type`.</span><span class="sxs-lookup"><span data-stu-id="03398-2809">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is equal to the length of `bounds` and whose element type is `type`.</span></span>  
  
 <span data-ttu-id="03398-2810"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `bounds` musi reprezentować typ całkowitoliczbowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2810">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `bounds` must represent an integral type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2811">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy ciągów, która ma pozycję 2.</span><span class="sxs-lookup"><span data-stu-id="03398-2811">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> method to create an expression tree that represents creating a string array that has a rank of 2.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2812"><paramref name="type" /> lub <paramref name="bounds" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2812"><paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2813">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2813">-or-</span></span> 
<span data-ttu-id="03398-2814">Element <paramref name="bounds" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2814">An element of <paramref name="bounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2815"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="bounds" /> nie reprezentuje typ całkowitoliczbowy.</span><span class="sxs-lookup"><span data-stu-id="03398-2815">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2816">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-2816">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2817">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-2817">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2818"><see cref="T:System.Collections.Generic.IEnumerable`1" /> Zawierający <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2818">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2819">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-2819">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="03398-2820">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2820">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2821"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typ, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jego *cytowane*.</span><span class="sxs-lookup"><span data-stu-id="03398-2821">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-2822">Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-2822">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-2823">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2823">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-2824">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2824">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="03398-2825"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy której pozycję to 1 i którego typ elementu jest `type`.</span><span class="sxs-lookup"><span data-stu-id="03398-2825">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2826">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy jednowymiarowej ciąg, który jest inicjowany za pomocą listy wyrażenia ciągu.</span><span class="sxs-lookup"><span data-stu-id="03398-2826">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2827"><paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2827"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2828">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2828">-or-</span></span> 
<span data-ttu-id="03398-2829">Element <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2829">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2830"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwy do przypisania do typu, <paramref name="type" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-2830">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-2831">A <see cref="T:System.Type" /> reprezentujący typ elementu tablicy.</span><span class="sxs-lookup"><span data-stu-id="03398-2831">A <see cref="T:System.Type" /> that represents the element type of the array.</span></span></param>
        <param name="initializers"><span data-ttu-id="03398-2832">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-2832">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-2833">Tworzy <see cref="T:System.Linq.Expressions.NewArrayExpression" /> reprezentująca tablicę jednowymiarową tworzenia i inicjując go z listy elementów.</span><span class="sxs-lookup"><span data-stu-id="03398-2833">Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</span></span></summary>
        <returns><span data-ttu-id="03398-2834">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> i <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2834">A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2835"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości każdego elementu `initializers` musi reprezentować typ, który można przypisać do typu reprezentowanego przez `type`, prawdopodobnie po jego *cytowane*.</span><span class="sxs-lookup"><span data-stu-id="03398-2835">The <xref:System.Linq.Expressions.Expression.Type%2A> property of each element of `initializers` must represent a type that is assignable to the type represented by `type`, possibly after it is *quoted*.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03398-2836">Element będzie można podać tylko wtedy, gdy `type` jest <xref:System.Linq.Expressions.Expression>.</span><span class="sxs-lookup"><span data-stu-id="03398-2836">An element will be quoted only if `type` is <xref:System.Linq.Expressions.Expression>.</span></span> <span data-ttu-id="03398-2837">Cytowanie oznacza, że element jest opakowana w <xref:System.Linq.Expressions.ExpressionType.Quote> węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2837">Quoting means the element is wrapped in a <xref:System.Linq.Expressions.ExpressionType.Quote> node.</span></span> <span data-ttu-id="03398-2838">Węzeł wynikowy jest <xref:System.Linq.Expressions.UnaryExpression> którego <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> właściwości jest elementem `initializers`.</span><span class="sxs-lookup"><span data-stu-id="03398-2838">The resulting node is a <xref:System.Linq.Expressions.UnaryExpression> whose <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> property is the element of `initializers`.</span></span>  
  
 <span data-ttu-id="03398-2839"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.NewArrayExpression> reprezentuje typ tablicy której pozycję to 1 i którego typ elementu jest `type`.</span><span class="sxs-lookup"><span data-stu-id="03398-2839">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.NewArrayExpression> represents an array type whose rank is 1 and whose element type is `type`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2840">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> metodę, aby utworzyć drzewo wyrażenia, reprezentujący tworzenia tablicy jednowymiarowej ciąg, który jest inicjowany za pomocą listy wyrażenia ciągu.</span><span class="sxs-lookup"><span data-stu-id="03398-2840">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> method to create an expression tree that represents creating a one-dimensional string array that is initialized with a list of string expressions.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2841"><paramref name="type" /> lub <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2841"><paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-2842">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2842">-or-</span></span> 
<span data-ttu-id="03398-2843">Element <paramref name="initializers" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2843">An element of <paramref name="initializers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2844"><see cref="P:System.Linq.Expressions.Expression.Type" /> Właściwość elementu <paramref name="initializers" /> reprezentuje typ, który nie jest możliwy do przypisania do typu <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2844">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="03398-2845">Pobiera typ węzła <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2845">Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <value><span data-ttu-id="03398-2846">Jedną z <see cref="T:System.Linq.Expressions.ExpressionType" /> wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2846">One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2847"><xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość zapewnia bardziej wyspecjalizowane opis <xref:System.Linq.Expressions.Expression> niż po prostu jego typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="03398-2847">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property provides a more specialized description of an <xref:System.Linq.Expressions.Expression> than just its derived type.</span></span> <span data-ttu-id="03398-2848">Na przykład <xref:System.Linq.Expressions.BinaryExpression> może służyć do reprezentowania różnego rodzaju wyrażenia binarne, takie jak operacji dzielenia lub operacją "większe niż".</span><span class="sxs-lookup"><span data-stu-id="03398-2848">For example, a <xref:System.Linq.Expressions.BinaryExpression> can be used to represent many different kinds of binary expressions, such as a division operation or a "greater than" operation.</span></span> <span data-ttu-id="03398-2849"><xref:System.Linq.Expressions.Expression.NodeType%2A> Właściwość co opisywałoby, te wyrażenia binarne jako <xref:System.Linq.Expressions.ExpressionType.Divide> i <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="03398-2849">The <xref:System.Linq.Expressions.Expression.NodeType%2A> property would describe these binary expressions as <xref:System.Linq.Expressions.ExpressionType.Divide> and <xref:System.Linq.Expressions.ExpressionType.GreaterThan>, respectively.</span></span>  
  
 <span data-ttu-id="03398-2850">CLR typu statycznego wyrażenia, <xref:System.Linq.Expressions.Expression> reprezentuje obiekt jest reprezentowany przez <xref:System.Linq.Expressions.Expression.Type%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2850">The static CLR type of the expression that the <xref:System.Linq.Expressions.Expression> object represents is represented by the <xref:System.Linq.Expressions.Expression.Type%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2851">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span><span class="sxs-lookup"><span data-stu-id="03398-2851">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2852"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2852">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2853">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span><span class="sxs-lookup"><span data-stu-id="03398-2853">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2854">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2854">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2855"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2855">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2856"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2856">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2857">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2857">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2858">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2858">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2859">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2859">Implementing Method</span></span>  
 <span data-ttu-id="03398-2860">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2860">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2861">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje jednoargumentowy not operator <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2861">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2862">W przeciwnym razie, jeśli `expression`. Typ jest typem liczbowa lub Boolean, metoda implementującej `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2862">Otherwise, if `expression`.Type is a numeric or Boolean type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2863">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2863">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2864">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2864">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2865">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2865">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2866">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2866">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2867">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2867">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2868">`expression`. Typ jest typem wartościowym i odpowiedni typ niedopuszczający jest równy argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2868">`expression`.Type is a nullable value type and the corresponding non-nullable type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2869">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2869">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2870">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2870">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2871">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2871">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2872">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2872">Otherwise, the node is lifted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-2873">Poniższy przykład przedstawia sposób tworzenia wyrażenia, który reprezentuje wartość logiczna nie operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2873">The following example demonstrates how to create an expression that represents a logical NOT operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2874"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2874"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2875">Jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2875">The unary not operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2876"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2876">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2877">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2877">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2878">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący operację dopełnienia bitowego.</span><span class="sxs-lookup"><span data-stu-id="03398-2878">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</span></span> <span data-ttu-id="03398-2879">Implementowanie metoda może być określona.</span><span class="sxs-lookup"><span data-stu-id="03398-2879">The implementing method can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-2880">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2880">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2881"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2881">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-2882"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2882">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2883">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2883">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2884">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2884">Otherwise, they are `false`.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2885">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2885">Implementing Method</span></span>  
 <span data-ttu-id="03398-2886">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2886">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2887">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2887">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-2888">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje jednoargumentowy not operator <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2888">If `expression`.Type is a user-defined type that defines the unary not operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2889">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2889">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2890">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2890">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2891">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2891">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2892">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2892">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2893">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2893">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2894">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2894">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2895">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-2895">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2896">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2896">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2897">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2897">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-2898">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2898">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2899">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2899">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2900"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2900"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2901"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-2901"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2902"><paramref name="method" /> jest <see langword="null" /> i jednoargumentowy not operator nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2902"><paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="03398-2903">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-2903">-or-</span></span> 
 <span data-ttu-id="03398-2904"><paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2904"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2905">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span><span class="sxs-lookup"><span data-stu-id="03398-2905">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2906"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2906">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2907"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2907">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2908">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span><span class="sxs-lookup"><span data-stu-id="03398-2908">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-2909">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2909">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2910">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2910">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2911"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2911">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2912">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2912">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true`.</span></span> <span data-ttu-id="03398-2913">W przeciwnym razie jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2913">Otherwise, it is `false`.</span></span> <span data-ttu-id="03398-2914"><xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> Właściwość jest zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2914">The <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is always `false`.</span></span> <span data-ttu-id="03398-2915"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2915">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2916">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2916">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2917">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2917">Implementing Method</span></span>  
 <span data-ttu-id="03398-2918">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2918">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2919">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2919">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2920">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2920">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2921">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2921">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2922">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2922">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2923">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2923">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2924">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2924">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2925">Jeśli są spełnione następujące dwa warunki, węzeł zostało zniesione i typ węzła jest <xref:System.Boolean>:</span><span class="sxs-lookup"><span data-stu-id="03398-2925">If the following two conditions are satisfied, the node is lifted and the type of the node is <xref:System.Boolean>:</span></span>  
  
    -   <span data-ttu-id="03398-2926">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2926">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2927">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2927">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-2928">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2928">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2929">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2929">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2930">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2930">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-2931">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2931">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2932">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2932">The type of the node is <xref:System.Boolean>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2933"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2933"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2934">Nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2934">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2935"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2935">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2936"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2936">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="liftToNull"><span data-ttu-id="03398-2937"><see langword="true" /> Aby ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="true" />; <see langword="false" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> do <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2937"><see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2938">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2938">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2939">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównania nierówności.</span><span class="sxs-lookup"><span data-stu-id="03398-2939">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-2940">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2940">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2941">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2941">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2942"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2942">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2943">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> właściwość `true` i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości jest równa `liftToNull`.</span><span class="sxs-lookup"><span data-stu-id="03398-2943">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> property is `true` and the <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> property is equal to `liftToNull`.</span></span> <span data-ttu-id="03398-2944">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2944">Otherwise, they are both `false`.</span></span> <span data-ttu-id="03398-2945"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2945">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2946">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2946">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2947">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2947">Implementing Method</span></span>  
 <span data-ttu-id="03398-2948">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2948">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2949">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2949">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2950">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator nierówności <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2950">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the inequality operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2951">W przeciwnym razie jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2951">Otherwise, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2952">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2952">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2953">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2953">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2954">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2954">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2955">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2955">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2956">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione; Ponadto typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`:</span><span class="sxs-lookup"><span data-stu-id="03398-2956">If the following two conditions are satisfied, the node is lifted; also, the type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`:</span></span>  
  
    -   <span data-ttu-id="03398-2957">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2957">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2958">Zwracany typ metody wykonawcze jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2958">The return type of the implementing method is <xref:System.Boolean>.</span></span>  
  
 <span data-ttu-id="03398-2959">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2959">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2960">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2960">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2961">Typ węzła jest <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-2961">The type of the node is <xref:System.Boolean>.</span></span>  
  
-   <span data-ttu-id="03398-2962">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2962">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-2963">Typ węzła ma wartość null <xref:System.Boolean> Jeśli `liftToNull` jest `true` lub <xref:System.Boolean> Jeśli `liftToNull` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2963">The type of the node is nullable <xref:System.Boolean> if `liftToNull` is `true` or <xref:System.Boolean> if `liftToNull` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-2964"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2964"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-2965"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-2965"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-2966"><paramref name="method" /> jest <see langword="null" /> i nie zdefiniowano operator nierówności dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-2966"><paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2967">Zwraca wyrażenie odpowiadające te dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2967">Returns the expression representing the ones complement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2968"><see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2968">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="03398-2969">Zwraca wyrażenie odpowiadające te dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2969">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="03398-2970">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2970">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-2971"><see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2971">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="method"><span data-ttu-id="03398-2972">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2972">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-2973">Zwraca wyrażenie odpowiadające te dopełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-2973">Returns the expression representing the ones complement.</span></span></summary>
        <returns><span data-ttu-id="03398-2974">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-2974">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-2975">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2975">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-2976"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2976">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-2977"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2977">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-2978">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-2978">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="03398-2979">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-2979">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-2980">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-2980">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-2981"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2981">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-2982">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-2982">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-2983">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-2983">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-2984"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2984">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-2985">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-2985">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-2986">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-2986">Implementing Method</span></span>  
 <span data-ttu-id="03398-2987">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-2987">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-2988">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-2988">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2989">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-2989">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-2990">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-2990">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-2991">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2991">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-2992">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2992">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-2993">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2993">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-2994">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-2994">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-2995">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-2995">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-2996">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-2996">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-2997">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-2997">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-2998">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-2998">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-2999">Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-2999">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="03398-3000">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3000">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3001">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3001">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3002">W poniższym przykładzie kodu pokazano, jak utworzyć wyrażenie, które reprezentuje operację logiczne OR.</span><span class="sxs-lookup"><span data-stu-id="03398-3002">The following code example shows how to create an expression that represents a logical OR operation.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3003"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3003"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3004">Operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3004">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3005"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3005">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3006"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3006">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3007">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3007">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3008">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowej <see langword="OR" /> operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3008">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3009">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3009">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3010">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3010">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3011"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3011">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3012">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3012">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3013">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3013">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3014"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3014">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3015">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3015">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3016">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3016">Implementing Method</span></span>  
 <span data-ttu-id="03398-3017">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3017">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3018">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3018">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3019">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3019">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3020">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów całkowitych lub wartości logicznej, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3020">Otherwise, if `left`.Type and `right`.Type are integral or Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3021">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3021">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3022">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3022">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3023">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3023">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3024">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3024">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3025">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3025">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3026">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3026">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3027">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3027">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3028">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3028">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3029">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3029">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3030">Typ węzła jest typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3030">The type of the node is the result type of the predefined bitwise `OR` operator.</span></span>  
  
-   <span data-ttu-id="03398-3031">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3031">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3032">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku jest wstępnie zdefiniowane bitowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3032">The type of the node is the nullable type that corresponds to the result type of the predefined bitwise `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3033"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3033"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3034"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3034"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3035"><paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3035"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3036">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</span><span class="sxs-lookup"><span data-stu-id="03398-3036">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3037"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3037">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3038"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3038">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3039">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</span><span class="sxs-lookup"><span data-stu-id="03398-3039">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3040">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3040">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3041"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3041">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3042"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3042">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3043">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3043">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3044">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</span><span class="sxs-lookup"><span data-stu-id="03398-3044">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3045">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3045">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3046"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3046">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3047"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3047">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3048">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3048">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-3049">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3049">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3050">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący bitowe operacji przypisania OR.</span><span class="sxs-lookup"><span data-stu-id="03398-3050">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3051">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3051">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3052">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operator daje w wyniku <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3052">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operator evaluates to <see langword="false" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3053"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3053">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3054"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3054">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3055">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3055">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3056">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3056">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3057">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3057">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3058"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3058">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3059">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3059">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3060">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3060">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3061"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3061">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3062">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3062">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3063">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3063">Implementing Method</span></span>  
 <span data-ttu-id="03398-3064">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3064">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3065">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3065">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="03398-3066">Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-3066">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="03398-3067">Jednak warunkową `OR` operator jest obliczane przy użyciu operatora testu koniunkcji `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3067">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="03398-3068">W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3068">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="03398-3069">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3069">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3070">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3070">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3071">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3071">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3072">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3072">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3073">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3073">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3074">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3074">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3075">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3075">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3076">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3076">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3077">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3077">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3078">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-3078">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="03398-3079">Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3079">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3080">Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3080">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="03398-3081">Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3081">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3082">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3082">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3083">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, który reprezentuje wartość logiczna `OR` operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3083">The following code example shows how to create an expression that represents a logical `OR` operation that evaluates the second operand only if the first operand evaluates to `false`.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3084"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3084"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3085">Operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3085">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-3086">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3086">-or-</span></span> 
 <span data-ttu-id="03398-3087"><paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-3087"><paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3088"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3088">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3089"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3089">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3090">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3090">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3091">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący warunkowe <see langword="OR" /> operacji, która ocenia drugi argument operacji tylko wtedy, gdy pierwszy operand ma wartość <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3091">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3092">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3092">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3093">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3093">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3094"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3094">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3095">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3095">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3096">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3096">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3097"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3097">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3098">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3098">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3099">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3099">Implementing Method</span></span>  
 <span data-ttu-id="03398-3100">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3100">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3101">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3101">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-3102">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora testu koniunkcji `OR` operatora <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3102">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the bitwise `OR` operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="03398-3103">Warunkowe `OR` nie może zostać Przeciążony operator w języku C# lub Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="03398-3103">The conditional `OR` operator cannot be overloaded in C# or Visual Basic.</span></span> <span data-ttu-id="03398-3104">Jednak warunkową `OR` operator jest obliczane przy użyciu operatora testu koniunkcji `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3104">However, the conditional `OR` operator is evaluated by using the bitwise `OR` operator.</span></span> <span data-ttu-id="03398-3105">W związku z tym, zdefiniowane przez użytkownika przeciążenia operatora testu koniunkcji `OR` operator może być implementującej metody dla tego typu węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3105">Thus, a user-defined overload of the bitwise `OR` operator can be the implementing method for this node type.</span></span>  
  
-   <span data-ttu-id="03398-3106">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ typów logicznych, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3106">Otherwise, if `left`.Type and `right`.Type are Boolean types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3107">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3107">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3108">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3108">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3109">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3109">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3110">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3110">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3111">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3111">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3112">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3112">`left`.Type and `right`.Type are both value types of which at least one is nullable, and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3113">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3113">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3114">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3114">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3115">`left`. Typ i `right`. Typ są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-3115">`left`.Type and `right`.Type are the same Boolean type.</span></span>  
  
-   <span data-ttu-id="03398-3116">Jeśli `left`. Typ i `right`. Typ nie dopuszczają, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3116">If `left`.Type and `right`.Type are non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3117">Typ węzła jest typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3117">The type of the node is the result type of the predefined conditional `OR` operator.</span></span>  
  
-   <span data-ttu-id="03398-3118">Jeśli `left`. Typ i `right`. Typ dopuszczający wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3118">If `left`.Type and `right`.Type are nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3119">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku wstępnie zdefiniowanych warunkowe `OR` operatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3119">The type of the node is the nullable type that corresponds to the result type of the predefined conditional `OR` operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3120"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3120"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3121"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3121"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3122"><paramref name="method" /> jest <see langword="null" /> i operatora testu koniunkcji <see langword="OR" /> operator nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3122"><paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-3123">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3123">-or-</span></span> 
 <span data-ttu-id="03398-3124"><paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i <paramref name="right" />. Typ nie są tego samego typu Boolean.</span><span class="sxs-lookup"><span data-stu-id="03398-3124"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3125">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3125">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3126">Typ parametr lub zmienna.</span><span class="sxs-lookup"><span data-stu-id="03398-3126">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="03398-3127">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3127">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="03398-3128">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie.</span><span class="sxs-lookup"><span data-stu-id="03398-3128">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-3129">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.MethodCallExpression> obiekt, który drukuje wartość <xref:System.Linq.Expressions.ParameterExpression> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-3129">The following example demonstrates how to create a <xref:System.Linq.Expressions.MethodCallExpression> object that prints the value of a <xref:System.Linq.Expressions.ParameterExpression> object.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3130">Typ parametr lub zmienna.</span><span class="sxs-lookup"><span data-stu-id="03398-3130">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="03398-3131">Nazwa parametr lub zmienna, używana do debugowania lub drukowanie tylko do celów.</span><span class="sxs-lookup"><span data-stu-id="03398-3131">The name of the parameter or variable, used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="03398-3132">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3132">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="03398-3133">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> i <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3133">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3134"><paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3134"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3135">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3135">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3136"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3136">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="03398-3137">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3137">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3138">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3138">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3139"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3139">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3140">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3140">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-3141">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne dekrementacji 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3141">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3142">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3143">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3143">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3144"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3144">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="03398-3145">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3145">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3146">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3147"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3147">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3148">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3148">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-3149">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący przypisanie wyrażenia, a następnie przez kolejne przyrostu 1 oryginalne wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3149">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3150">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3151">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</span><span class="sxs-lookup"><span data-stu-id="03398-3151">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3152"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3152">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3153"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3153">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3154">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</span><span class="sxs-lookup"><span data-stu-id="03398-3154">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="03398-3155">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3155">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3156">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3156">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3157"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3157">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3158">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3158">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3159">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3159">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3160"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3160">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3161">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3161">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3162">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3162">Implementing Method</span></span>  
 <span data-ttu-id="03398-3163">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3163">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3164">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora potęgowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3164">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3165">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-3165">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3166">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3166">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="03398-3167">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3167">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3168">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3168">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3169">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3169">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3170">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3170">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3171">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3171">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3172"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3172"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3173">Nie zdefiniowano operator potęgowania dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3173">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-3174">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3174">-or-</span></span> 
 <span data-ttu-id="03398-3175"><paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3175"><paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3176"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3176">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3177"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3177">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3178">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3178">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3179">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący zwiększenie liczby do potęgi.</span><span class="sxs-lookup"><span data-stu-id="03398-3179">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</span></span></summary>
        <returns><span data-ttu-id="03398-3180">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3180">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3181">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3181">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3182"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3182">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3183">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3183">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3184">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3184">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3185"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3185">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3186">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3186">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3187">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3187">Implementing Method</span></span>  
 <span data-ttu-id="03398-3188">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3188">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3189">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest metoda implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3189">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3190">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora potęgowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3190">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the exponentiation operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3191">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ są <xref:System.Double>, implementacja metody jest <xref:System.Math.Pow%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-3191">Otherwise, if `left`.Type and `right`.Type are both <xref:System.Double>, the implementing method is <xref:System.Math.Pow%2A>.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3192">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3192">Node Type and Lifted versus Non-Lifted</span></span>  
  
-   <span data-ttu-id="03398-3193">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3193">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3194">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3194">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3195">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3195">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3196">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3196">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3197">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3197">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3198"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3198"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3199"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3199"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3200"><paramref name="method" /> jest <see langword="null" /> i operatora potęgowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3200"><paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span>  
  
<span data-ttu-id="03398-3201">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3201">-or-</span></span> 
 <span data-ttu-id="03398-3202"><paramref name="method" /> jest <see langword="null" /> i <paramref name="left" />. Typ i/lub <paramref name="right" />. Nie są typu <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3202"><paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3203">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3203">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3204"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3204">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3205"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3205">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3206">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3206">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3207">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3208"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3208">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3209"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3209">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3210">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3210">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3211">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3211">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3212">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3212">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3213"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3213">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3214"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3214">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3215">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3215">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-3216">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3216">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3217">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący podnoszenia wyrażenia do potęgi i przypisywanie wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3217">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3218">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3219">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3219">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3220"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3220">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="03398-3221">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3221">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3222">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3222">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3223"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3223">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3224">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3224">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-3225">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> zmniejsza tego wyrażenia przez 1 i przypisuje wynik z powrotem do wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3225">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3226">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3227">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3227">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3228"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3228">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <summary><span data-ttu-id="03398-3229">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3229">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3230">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3231"><see cref="T:System.Linq.Expressions.Expression" /> Można zastosować operacji.</span><span class="sxs-lookup"><span data-stu-id="03398-3231">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3232">A <see cref="T:System.Reflection.MethodInfo" /> reprezentujący implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3232">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</span></span></param>
        <summary><span data-ttu-id="03398-3233">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> , zwiększa się o 1 wyrażenia i przypisuje wynik wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3233">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</span></span></summary>
        <returns><span data-ttu-id="03398-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie wynikowe.</span><span class="sxs-lookup"><span data-stu-id="03398-3234">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3235">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3235">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3236"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3236">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="03398-3237">Może to być wartość null dla właściwości statyczne.</span><span class="sxs-lookup"><span data-stu-id="03398-3237">This can be null for static properties.</span></span></param>
        <param name="propertyAccessor"><span data-ttu-id="03398-3238"><see cref="T:System.Reflection.MethodInfo" /> Reprezentujący metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3238">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</span></span></param>
        <summary><span data-ttu-id="03398-3239">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości przy użyciu metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3239">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</span></span></summary>
        <returns><span data-ttu-id="03398-3240">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwości używane w <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3240">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3241"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-3241">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="03398-3242">Jeśli metoda reprezentowane przez `propertyAccessor` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3242">If the method represented by `propertyAccessor` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3243"><paramref name="propertyAccessor" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3243"><paramref name="propertyAccessor" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-3244">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3244">-or-</span></span> 
<span data-ttu-id="03398-3245">Metoda, <paramref name="propertyAccessor" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3245">The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3246"><paramref name="expression" />. Typ nie jest możliwy do przypisania do metody reprezentowanej przez typ deklarujący <paramref name="propertyAccessor" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3246"><paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.</span></span>  
  
<span data-ttu-id="03398-3247">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3247">-or-</span></span> 
<span data-ttu-id="03398-3248">Metoda, <paramref name="propertyAccessor" /> reprezentuje nie jest metoda dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3248">The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3249"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3249">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to.</span></span> <span data-ttu-id="03398-3250">Może to być wartość null dla właściwości statyczne.</span><span class="sxs-lookup"><span data-stu-id="03398-3250">This can be null for static properties.</span></span></param>
        <param name="property"><span data-ttu-id="03398-3251"><see cref="T:System.Reflection.PropertyInfo" /> Można ustawić <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3251">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3252">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3252">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="03398-3253">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3253">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3254"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-3254">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of <xref:System.Linq.Expressions.MemberExpression.Member%2A>.</span></span>  
  
 <span data-ttu-id="03398-3255">Jeśli właściwość jest reprezentowane przez `property` jest `static` (`Shared` w języku Visual Basic), `expression` może być `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3255">If the property represented by `property` is `static` (`Shared` in Visual Basic), `expression` can be `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3256"><paramref name="property" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3256"><paramref name="property" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="03398-3257">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3257">-or-</span></span> 
<span data-ttu-id="03398-3258">Właściwość, <paramref name="property" /> reprezentuje nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic) i <paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3258">The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3259"><paramref name="expression" />. Typ nie jest możliwy do przypisania do właściwości typ deklarujący, <paramref name="property" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-3259"><paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3260"><see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość o nazwie <paramref name="propertyName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3260">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />.</span></span> <span data-ttu-id="03398-3261">Może to być <see langword="null" /> właściwości statycznej.</span><span class="sxs-lookup"><span data-stu-id="03398-3261">This can be <see langword="null" /> for static properties.</span></span></param>
        <param name="propertyName"><span data-ttu-id="03398-3262">Nazwa właściwości, można uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="03398-3262">The name of a property to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-3263">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3263">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</span></span></summary>
        <returns><span data-ttu-id="03398-3264">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> reprezentująca właściwość oznaczona <paramref name="propertyName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3264">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3265"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> właściwość <xref:System.Reflection.PropertyInfo> reprezentująca właściwość oznaczona `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="03398-3265">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> property of the <xref:System.Reflection.PropertyInfo> that represents the property denoted by `propertyName`.</span></span>  
  
 <span data-ttu-id="03398-3266">Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych dla właściwości o nazwie `propertyName`.</span><span class="sxs-lookup"><span data-stu-id="03398-3266">This method searches `expression`.Type and its base types for a property that has the name `propertyName`.</span></span> <span data-ttu-id="03398-3267">Właściwości publiczne mają pierwszeństwo nad niepublicznych właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3267">Public properties are given preference over non-public properties.</span></span> <span data-ttu-id="03398-3268">Jeśli zostanie znalezione dopasowania właściwości, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> reprezentujący tę właściwość, aby <xref:System.Linq.Expressions.Expression.Property%2A>.</span><span class="sxs-lookup"><span data-stu-id="03398-3268">If a matching property is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> that represents that property to <xref:System.Linq.Expressions.Expression.Property%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3269">Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3269">The following example shows how to create an expression that represents accessing a property.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3270"><paramref name="expression" /> lub <paramref name="propertyName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3270"><paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3271">Nie ma właściwości o nazwie <paramref name="propertyName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-3271">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-3272">Obiekt, do której należy właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-3272">The object to which the property belongs.</span></span> <span data-ttu-id="03398-3273">Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="03398-3273">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="03398-3274"><see cref="T:System.Reflection.PropertyInfo" /> Reprezentująca właściwość do indeksu.</span><span class="sxs-lookup"><span data-stu-id="03398-3274">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-3275"><see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3275">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="03398-3276">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</span><span class="sxs-lookup"><span data-stu-id="03398-3276">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="03398-3277">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3277">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-3278">Obiekt, do której należy właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-3278">The object to which the property belongs.</span></span> <span data-ttu-id="03398-3279">Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="03398-3279">If the property is static/shared, it must be null.</span></span></param>
        <param name="indexer"><span data-ttu-id="03398-3280"><see cref="T:System.Reflection.PropertyInfo" /> Reprezentująca właściwość do indeksu.</span><span class="sxs-lookup"><span data-stu-id="03398-3280">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-3281">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3281">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="03398-3282">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</span><span class="sxs-lookup"><span data-stu-id="03398-3282">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="03398-3283">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3283">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><span data-ttu-id="03398-3284">Obiekt, do której należy właściwość.</span><span class="sxs-lookup"><span data-stu-id="03398-3284">The object to which the property belongs.</span></span> <span data-ttu-id="03398-3285">Jeśli właściwość jest statyczne/udostępnione, musisz mieć wartości null.</span><span class="sxs-lookup"><span data-stu-id="03398-3285">If the property is static/shared, it must be null.</span></span></param>
        <param name="propertyName"><span data-ttu-id="03398-3286">Nazwa indeksatora.</span><span class="sxs-lookup"><span data-stu-id="03398-3286">The name of the indexer.</span></span></param>
        <param name="arguments"><span data-ttu-id="03398-3287">Tablica <see cref="T:System.Linq.Expressions.Expression" /> obiekty, które są używane do indeksowania właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3287">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</span></span></param>
        <summary><span data-ttu-id="03398-3288">Tworzy <see cref="T:System.Linq.Expressions.IndexExpression" /> reprezentującą dostępu do właściwości indeksowanych.</span><span class="sxs-lookup"><span data-stu-id="03398-3288">Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</span></span></summary>
        <returns><span data-ttu-id="03398-3289">Utworzony <see cref="T:System.Linq.Expressions.IndexExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3289">The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3290">Obiekt zawierający właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3290">The containing object of the property.</span></span> <span data-ttu-id="03398-3291">Może to być wartość null dla właściwości statyczne.</span><span class="sxs-lookup"><span data-stu-id="03398-3291">This can be null for static properties.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3292"><see cref="P:System.Linq.Expressions.Expression.Type" /> Zawierający właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3292">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</span></span></param>
        <param name="propertyName"><span data-ttu-id="03398-3293">Właściwość, która ma być uzyskiwany dostęp.</span><span class="sxs-lookup"><span data-stu-id="03398-3293">The property to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-3294">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> uzyskiwania dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3294">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</span></span></summary>
        <returns><span data-ttu-id="03398-3295">Utworzony <see cref="T:System.Linq.Expressions.MemberExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3295">The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3296"><see cref="T:System.Linq.Expressions.Expression" /> Którego <see cref="P:System.Linq.Expressions.Expression.Type" /> zawiera właściwość lub pole o nazwie <paramref name="propertyOrFieldName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3296">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />.</span></span> <span data-ttu-id="03398-3297">Może to być wartość null dla statycznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="03398-3297">This can be null for static members.</span></span></param>
        <param name="propertyOrFieldName"><span data-ttu-id="03398-3298">Nazwa właściwości lub pola, które ma być uzyskiwany dostęp.</span><span class="sxs-lookup"><span data-stu-id="03398-3298">The name of a property or field to be accessed.</span></span></param>
        <summary><span data-ttu-id="03398-3299">Tworzy <see cref="T:System.Linq.Expressions.MemberExpression" /> reprezentująca dostęp do właściwości lub pola.</span><span class="sxs-lookup"><span data-stu-id="03398-3299">Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</span></span></summary>
        <returns><span data-ttu-id="03398-3300">A <see cref="T:System.Linq.Expressions.MemberExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> właściwością <paramref name="expression" />i <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> właściwością <see cref="T:System.Reflection.PropertyInfo" /> lub <see cref="T:System.Reflection.FieldInfo" /> reprezentująca właściwość lub pole wskazywane przez <paramref name="propertyOrFieldName" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3300">A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3301"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwości wynikające <xref:System.Linq.Expressions.MemberExpression> jest równa <xref:System.Reflection.PropertyInfo.PropertyType%2A> lub <xref:System.Reflection.FieldInfo.FieldType%2A> właściwości <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo>, odpowiednio, który reprezentuje właściwość lub pole wskazywane przez `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="03398-3301">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.MemberExpression> is equal to the <xref:System.Reflection.PropertyInfo.PropertyType%2A> or <xref:System.Reflection.FieldInfo.FieldType%2A> properties of the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo>, respectively, that represents the property or field denoted by `propertyOrFieldName`.</span></span>  
  
 <span data-ttu-id="03398-3302">Metoda ta wyszukuje `expression`. Typ i jego typów podstawowych, właściwość lub pole o nazwie `propertyOrFieldName`.</span><span class="sxs-lookup"><span data-stu-id="03398-3302">This method searches `expression`.Type and its base types for a property or field that has the name `propertyOrFieldName`.</span></span> <span data-ttu-id="03398-3303">Właściwości publiczne i pola są podane preferencji za pośrednictwem właściwości niepubliczne i pola.</span><span class="sxs-lookup"><span data-stu-id="03398-3303">Public properties and fields are given preference over non-public properties and fields.</span></span> <span data-ttu-id="03398-3304">Ponadto właściwości mają pierwszeństwo nad polami.</span><span class="sxs-lookup"><span data-stu-id="03398-3304">Also, properties are given preference over fields.</span></span> <span data-ttu-id="03398-3305">Jeśli właściwość lub pole dopasowania zostanie znaleziony, ta metoda przekazuje `expression` i <xref:System.Reflection.PropertyInfo> lub <xref:System.Reflection.FieldInfo> reprezentujący tej właściwości lub pola <xref:System.Linq.Expressions.Expression.Property%2A> lub <xref:System.Linq.Expressions.Expression.Field%2A>, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="03398-3305">If a matching property or field is found, this method passes `expression` and the <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.FieldInfo> that represents that property or field to <xref:System.Linq.Expressions.Expression.Property%2A> or <xref:System.Linq.Expressions.Expression.Field%2A>, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3306">Poniższy przykład pokazuje, jak utworzyć wyrażenie, które reprezentuje, uzyskiwanie dostępu do właściwości lub pola.</span><span class="sxs-lookup"><span data-stu-id="03398-3306">The following example shows how to create an expression that represents accessing a property or field.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3307"><paramref name="expression" /> lub <paramref name="propertyOrFieldName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3307"><paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3308">Nie właściwości lub pola o nazwie <paramref name="propertyOrFieldName" /> jest zdefiniowany w <paramref name="expression" />. Typ lub jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="03398-3308">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3309"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3309">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3310">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyrażenie stałej wartości typu <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3310">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3311">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3311">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3312"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> reprezentuje zbudowany typ <xref:System.Linq.Expressions.Expression%601>, gdzie argument typu jest typu reprezentowanego przez `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3312">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents the constructed type <xref:System.Linq.Expressions.Expression%601>, where the type argument is the type represented by `expression`.Type.</span></span> <span data-ttu-id="03398-3313"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3313">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property is `null`.</span></span> <span data-ttu-id="03398-3314">Zarówno <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3314">Both <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> are `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3315"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3315"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-3316">Zmniejsza tego węzła w celu prostszego wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3316">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="03398-3317">Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3317">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="03398-3318">Ta metoda może zwrócić inny węzeł, która sama musi zostać obniżona.</span><span class="sxs-lookup"><span data-stu-id="03398-3318">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="03398-3319">Wyrażenie mniejsze.</span><span class="sxs-lookup"><span data-stu-id="03398-3319">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-3320">Zmniejsza tego węzła w celu prostszego wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3320">Reduces this node to a simpler expression.</span></span> <span data-ttu-id="03398-3321">Jeśli CanReduce zwraca wartość true, powinny zostać zwrócone prawidłowe wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="03398-3321">If CanReduce returns true, this should return a valid expression.</span></span> <span data-ttu-id="03398-3322">Ta metoda może zwrócić inny węzeł, która sama musi zostać obniżona.</span><span class="sxs-lookup"><span data-stu-id="03398-3322">This method can return another node which itself must be reduced.</span></span></summary>
        <returns><span data-ttu-id="03398-3323">Wyrażenie mniejsze.</span><span class="sxs-lookup"><span data-stu-id="03398-3323">The reduced expression.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3324">W odróżnieniu od Reduce ta metoda sprawdza, czy niższych węźle spełnia określone invariants.</span><span class="sxs-lookup"><span data-stu-id="03398-3324">Unlike Reduce, this method checks that the reduced node satisfies certain invariants.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-3325">Zmniejsza wyrażenia na typ węzła znane, (który nie jest węzłem rozszerzenia) lub po prostu zwraca wyrażenie, jeśli nie jest jeszcze znany typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3325">Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</span></span></summary>
        <returns><span data-ttu-id="03398-3326">Wyrażenie mniejsze.</span><span class="sxs-lookup"><span data-stu-id="03398-3326">The reduced expression.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3327"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3327">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3328"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3328">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3329">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie równości odwołań.</span><span class="sxs-lookup"><span data-stu-id="03398-3329">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-3330">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3330">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3331"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3331">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3332"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3332">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3333">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący porównanie nierówności odwołań.</span><span class="sxs-lookup"><span data-stu-id="03398-3333">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</span></span></summary>
        <returns><span data-ttu-id="03398-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3334">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3335">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="03398-3335">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-3336">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="03398-3336">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></summary>
        <returns><span data-ttu-id="03398-3337">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="03398-3337">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3338">Nowy <see cref="T:System.Type" /> wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3338">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="03398-3339">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku z danym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-3339">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="03398-3340">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący ponowne generowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="03398-3340">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3341">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span><span class="sxs-lookup"><span data-stu-id="03398-3341">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-3342"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-3342">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <summary><span data-ttu-id="03398-3343">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span><span class="sxs-lookup"><span data-stu-id="03398-3343">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span></summary>
        <returns><span data-ttu-id="03398-3344">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3344">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-3345"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-3345">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-3346">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3346">The value that will be passed to the associated label upon jumping.</span></span></param>
        <summary><span data-ttu-id="03398-3347">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcji return.</span><span class="sxs-lookup"><span data-stu-id="03398-3347">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</span></span> <span data-ttu-id="03398-3348">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-3348">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-3349">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3349">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-3350">Poniższy przykład przedstawia sposób tworzenia wyrażenia zawierającego <xref:System.Linq.Expressions.Expression.Return%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3350">The following example demonstrates how to create an expression that contains the <xref:System.Linq.Expressions.Expression.Return%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-3351"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-3351">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3352"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3352">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3353">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-3353">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span></summary>
        <returns><span data-ttu-id="03398-3354">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Return <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />i wartość null, które zostaną przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3354">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="03398-3355"><see cref="T:System.Linq.Expressions.LabelTarget" /> , <see cref="T:System.Linq.Expressions.GotoExpression" /> Spowoduje przejście do.</span><span class="sxs-lookup"><span data-stu-id="03398-3355">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</span></span></param>
        <param name="value"><span data-ttu-id="03398-3356">Wartość, które zostaną przekazane do skojarzonego etykiety po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3356">The value that will be passed to the associated label upon jumping.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3357"><see cref="T:System.Type" /> Można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3357">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3358">Tworzy <see cref="T:System.Linq.Expressions.GotoExpression" /> reprezentujący instrukcję return z określonym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-3358">Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</span></span> <span data-ttu-id="03398-3359">Można określić wartość przekazana do etykiety na skok.</span><span class="sxs-lookup"><span data-stu-id="03398-3359">The value passed to the label upon jumping can be specified.</span></span></summary>
        <returns><span data-ttu-id="03398-3360">A <see cref="T:System.Linq.Expressions.GotoExpression" /> z <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> równa Kontynuuj <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> właściwością <paramref name="target" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> właściwością <paramref name="type" />, i <paramref name="value" /> mają być przekazane do etykietą docelową po przeskakiwanie.</span><span class="sxs-lookup"><span data-stu-id="03398-3360">A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3361">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3361">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3362"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3362">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3363"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3363">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3364">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3364">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3365">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3366">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3366">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3367"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3367">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3368">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3368">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3369">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3369">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3370"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3370">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3371">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3371">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3372">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3372">Implementing Method</span></span>  
 <span data-ttu-id="03398-3373">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3373">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3374">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora przesunięcia w prawo, <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3374">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3375">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3375">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3376">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3376">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3377">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3377">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3378">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3378">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3379">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3379">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3380">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3380">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3381">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3381">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3382">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3382">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3383">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3383">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3384">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3384">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3385">Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3385">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="03398-3386">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3386">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3387">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3387">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3388"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3388"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3389">Operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3389">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3390"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3390">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3391"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3391">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3392">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3392">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3393">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację bitowego przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3393">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3394">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3395">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3395">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3396"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3396">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3397">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3397">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3398">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3398">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3399"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3399">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3400">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3400">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3401">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3401">Implementing Method</span></span>  
 <span data-ttu-id="03398-3402">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3402">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3403">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3403">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-3404">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operatora przesunięcia w prawo, <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3404">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the right-shift operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3405">W przeciwnym razie, jeśli `left`. Typ jest typem całkowitym (jeden z <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, lub odpowiednie typy dopuszczające wartości null) i `right`. Typ jest <xref:System.Int32>, implementacja metody jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3405">Otherwise, if `left`.Type is an integral type (one of <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, or the corresponding nullable types) and `right`.Type is <xref:System.Int32>, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3406">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3406">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3407">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3407">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3408">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3408">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3409">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3409">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3410">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3410">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3411">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3411">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3412">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3412">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3413">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3413">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3414">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3414">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3415">Typ węzła jest typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3415">The type of the node is the result type of the predefined right-shift operator.</span></span>  
  
-   <span data-ttu-id="03398-3416">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3416">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3417">Typ węzła jest typ dopuszczający wartość null, który odpowiada typ wyniku wstępnie zdefiniowanego operatora przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3417">The type of the node is the nullable type that corresponds to the result type of the predefined right-shift operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3418"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3418"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3419"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3419"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3420"><paramref name="method" /> jest <see langword="null" /> i operator przesunięcia w prawo nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3420"><paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3421">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3421">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3422"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3422">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3423"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3423">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3424">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3424">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3425">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3426"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3426">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3427"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3427">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3428">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3428">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3429">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3429">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3430">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3431"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3431">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3432"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3432">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3433">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3433">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-3434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3434">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3435">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację logiczną przypisania przesunięcia w prawo.</span><span class="sxs-lookup"><span data-stu-id="03398-3435">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3436">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3437">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3437">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="03398-3438">Kolekcja <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-3438">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-3439">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3439">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3440">Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3440">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><span data-ttu-id="03398-3441">Tablica <see cref="T:System.Linq.Expressions.ParameterExpression" /> obiekty służące do wypełniania <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="03398-3441">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</span></span></param>
        <summary><span data-ttu-id="03398-3442">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3442">Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3443">Wystąpienie <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> i <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3443">An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3444">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3444">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3445"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3445">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3446">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3446">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3447">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3447">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3448">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3448">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3449">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3449">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3450"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3450">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3451">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3451">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3452">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3452">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3453"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3453">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3454">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3454">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3455">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3455">Implementing Method</span></span>  
 <span data-ttu-id="03398-3456">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3456">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3457">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3457">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3458">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3458">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3459">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3459">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3460">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3460">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3461">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3461">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3462">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3462">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3463">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3463">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3464">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3464">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3465">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3465">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3466">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3466">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3467">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3467">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3468">Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3468">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="03398-3469">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3469">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3470">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3470">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3471">Poniższy przykład kodu pokazuje, jak utworzyć wyrażenie, które odejmuje argumentu z pierwszego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-3471">The following code example shows how to create an expression that subtracts the argument from the first argument.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3472"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3472"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3473">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3473">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3474">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3474">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3475">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3475">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3476">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3476">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3477">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, które ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3477">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3478">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3478">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3479">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3479">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3480"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3480">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3481">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3481">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3482">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3482">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3483"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3483">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3484">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3484">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3485">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3485">Implementing Method</span></span>  
 <span data-ttu-id="03398-3486">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3486">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3487">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3487">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-3488">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3488">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3489">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3489">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3490">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3490">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3491">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3491">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3492">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3492">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3493">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3493">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3494">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3494">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3495">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3495">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3496">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3496">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3497">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3497">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3498">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3498">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3499">Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3499">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="03398-3500">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3500">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3501">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3501">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3502"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3502"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3503"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3503"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3504"><paramref name="method" /> jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3504"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3505">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3505">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3506"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3506">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3507"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3507">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3508">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3508">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3509">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3509">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3510"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3510">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3511"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3511">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3512">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3512">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3513">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3513">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3514">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3514">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3515"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3515">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3516"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3516">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3517">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3517">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-3518">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3518">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3519">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który nie ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3519">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3520">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3520">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3521">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3521">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3522"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3522">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3523"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3523">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3524">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3524">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3525">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3525">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3526"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3526">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3527"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3527">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3528">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3528">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3529">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3529">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3530">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3530">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3531"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3531">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3532"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3532">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3533">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3533">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <param name="conversion"><span data-ttu-id="03398-3534">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3534">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3535">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację Przypisanie odejmowania, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3535">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3536">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3536">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3537">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3537">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3538">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3538">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3539">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3539">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3540">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3540">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3541">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3541">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3542">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3542">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3543"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3543">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3544">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3544">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3545">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3545">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3546"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3546">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3547">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3547">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3548">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3548">Implementing Method</span></span>  
 <span data-ttu-id="03398-3549">Następujące reguły określają wybranej metody wykonawcze dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3549">The following rules determine the selected implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3550">Jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3550">If the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3551">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3551">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3552">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3552">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3553">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3553">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3554">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3554">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3555">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3555">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3556">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3556">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3557">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3557">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3558">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3558">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3559">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3559">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3560">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3560">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3561">Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3561">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="03398-3562">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3562">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3563">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3563">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3564"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3564"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3565">Operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3565">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="03398-3566">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3566">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</span></span></param>
        <param name="right"><span data-ttu-id="03398-3567">A <see cref="T:System.Linq.Expressions.Expression" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3567">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3568">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3568">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3569">Tworzy <see cref="T:System.Linq.Expressions.BinaryExpression" /> reprezentujący operację odejmowania arytmetyczne, który ma sprawdzanie przepełnienia.</span><span class="sxs-lookup"><span data-stu-id="03398-3569">Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</span></span></summary>
        <returns><span data-ttu-id="03398-3570">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> i <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, i <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3570">A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3571">Wartość wynikowa <xref:System.Linq.Expressions.BinaryExpression> ma <xref:System.Linq.Expressions.BinaryExpression.Method%2A> właściwością implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3571">The resulting <xref:System.Linq.Expressions.BinaryExpression> has the <xref:System.Linq.Expressions.BinaryExpression.Method%2A> property set to the implementing method.</span></span> <span data-ttu-id="03398-3572"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3572">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3573">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3573">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3574">W przeciwnym razie są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3574">Otherwise, they are `false`.</span></span> <span data-ttu-id="03398-3575"><xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> Właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3575">The <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> property is `null`.</span></span>  
  
 <span data-ttu-id="03398-3576">Poniższe informacje zawierają opis metody wykonawcze, typ węzła i tego, czy zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3576">The following information describes the implementing method, the node type, and whether a node is lifted.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3577">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3577">Implementing Method</span></span>  
 <span data-ttu-id="03398-3578">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3578">The following rules determine the implementing method for the operation :</span></span>  
  
-   <span data-ttu-id="03398-3579">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje dwa argumenty, jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3579">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes two arguments, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-3580">W przeciwnym razie, jeśli <xref:System.Linq.Expressions.Expression.Type%2A> właściwości albo `left` lub `right` reprezentuje typ zdefiniowany przez użytkownika, który przeciążenia operator odejmowania <xref:System.Reflection.MethodInfo> reprezentujący się, że metoda jest metodą implementującej.</span><span class="sxs-lookup"><span data-stu-id="03398-3580">Otherwise, if the <xref:System.Linq.Expressions.Expression.Type%2A> property of either `left` or `right` represents a user-defined type that overloads the subtraction operator, the <xref:System.Reflection.MethodInfo> that represents that method is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3581">W przeciwnym razie, jeśli `left`. Typ i `right`. Typ to typy liczbowe, implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3581">Otherwise, if `left`.Type and `right`.Type are numeric types, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3582">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3582">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3583">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3583">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3584">Jeśli `left`. Typ i `right`. Typ można przypisać odpowiednie typy argumentów metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3584">If `left`.Type and `right`.Type are assignable to the corresponding argument types of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3585">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3585">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3586">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3586">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3587">`left`. Typ i `right`. Typ są oba typy wartości, z których co najmniej jedna ma wartość null, a odpowiednie typy nieprzyjmujące wartości są równe odpowiednie typy argumentów metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3587">`left`.Type and `right`.Type are both value types of which at least one is nullable and the corresponding non-nullable types are equal to the corresponding argument types of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3588">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3588">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3589">Jeśli metoda implementującej jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3589">If the implementing method is `null`:</span></span>  
  
-   <span data-ttu-id="03398-3590">Jeśli `left`. Typ i `right`. Typ są obie wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3590">If `left`.Type and `right`.Type are both non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3591">Typ węzła jest typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3591">The type of the node is the result type of the predefined subtraction operator.</span></span>  
  
-   <span data-ttu-id="03398-3592">Jeśli `left`. Typ i `right`. Typ są dopuszczającego wartość null, zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3592">If `left`.Type and `right`.Type are both nullable, the node is lifted.</span></span> <span data-ttu-id="03398-3593">Typ węzła jest typ dopuszczający wartość null, odpowiadający typ wyniku operator odejmowania wstępnie zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="03398-3593">The type of the node is the nullable type that corresponds to the result type of the predefined subtraction operator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3594"><paramref name="left" /> lub <paramref name="right" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3594"><paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3595"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie przyjmuje dokładnie dwóch argumentów.</span><span class="sxs-lookup"><span data-stu-id="03398-3595"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3596"><paramref name="method" /> jest <see langword="null" /> i operator odejmowania nie jest zdefiniowany dla <paramref name="left" />. Typ i <paramref name="right" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3596"><paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3597">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcji.</span><span class="sxs-lookup"><span data-stu-id="03398-3597">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="03398-3598">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3598">The value to be tested against each case.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3599">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3599">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3600">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję bez przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3600">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3601">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3601">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3602">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="03398-3602">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="03398-3603">Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="03398-3603">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="03398-3604">Jeśli `switchValue` nie pasuje do żadnego przypadków, jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="03398-3604">If `switchValue` does not match any of the cases, no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3605">Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika bez przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3605">The following example demonstrates how to create an expression that represents a swtich statement without a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="03398-3606">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3606">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="03398-3607">Wynik o przełącznikiem Jeśli <paramref name="switchValue" /> nie pasuje do żadnego z przypadków.</span><span class="sxs-lookup"><span data-stu-id="03398-3607">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3608">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3608">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3609">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3609">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3610">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3610">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3611">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="03398-3611">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="03398-3612">Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="03398-3612">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
 <span data-ttu-id="03398-3613">Jeśli `switchValue` nie pasuje do żadnego z przypadków przypadek domyślny, reprezentowane przez `defaultBody` jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="03398-3613">If `switchValue` does not match any of the cases, the default case represented by `defaultBody` is run.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3614">Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika, który ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3614">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="03398-3615">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3615">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="03398-3616">Wynik o przełącznikiem Jeśli <paramref name="switchValue" /> nie pasuje do żadnego z przypadków.</span><span class="sxs-lookup"><span data-stu-id="03398-3616">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="03398-3617">Metoda porównania równości do użycia.</span><span class="sxs-lookup"><span data-stu-id="03398-3617">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3618">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3618">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3619">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3619">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3620">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3620">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue"><span data-ttu-id="03398-3621">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3621">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="03398-3622">Wynik o przełącznikiem Jeśli <paramref name="switchValue" /> nie pasuje do żadnego z przypadków.</span><span class="sxs-lookup"><span data-stu-id="03398-3622">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="03398-3623">Metoda porównania równości do użycia.</span><span class="sxs-lookup"><span data-stu-id="03398-3623">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3624">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3624">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3625">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3625">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3626">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3626">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3627">Typ wyniku przełącznika.</span><span class="sxs-lookup"><span data-stu-id="03398-3627">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="03398-3628">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3628">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="03398-3629">Wynik o przełącznikiem Jeśli <paramref name="switchValue" /> nie pasuje do żadnego z przypadków.</span><span class="sxs-lookup"><span data-stu-id="03398-3629">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="03398-3630">Metoda porównania równości do użycia.</span><span class="sxs-lookup"><span data-stu-id="03398-3630">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3631">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3631">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3632">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3632">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3633">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3633">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3634">Typ wyniku przełącznika.</span><span class="sxs-lookup"><span data-stu-id="03398-3634">The result type of the switch.</span></span></param>
        <param name="switchValue"><span data-ttu-id="03398-3635">Wartość, która ma być testowana w każdym przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3635">The value to be tested against each case.</span></span></param>
        <param name="defaultBody"><span data-ttu-id="03398-3636">Wynik o przełącznikiem Jeśli <paramref name="switchValue" /> nie pasuje do żadnego z przypadków.</span><span class="sxs-lookup"><span data-stu-id="03398-3636">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</span></span></param>
        <param name="comparison"><span data-ttu-id="03398-3637">Metoda porównania równości do użycia.</span><span class="sxs-lookup"><span data-stu-id="03398-3637">The equality comparison method to use.</span></span></param>
        <param name="cases"><span data-ttu-id="03398-3638">Zestaw przypadków dla tego wyrażenia switch.</span><span class="sxs-lookup"><span data-stu-id="03398-3638">The set of cases for this switch expression.</span></span></param>
        <summary><span data-ttu-id="03398-3639">Tworzy <see cref="T:System.Linq.Expressions.SwitchExpression" /> reprezentujący <see langword="switch" /> instrukcję, która ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3639">Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</span></span></summary>
        <returns><span data-ttu-id="03398-3640">Utworzony <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3640">The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3641">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektów, które zostaną użyte w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-3641">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3642">Treść przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3642">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="03398-3643">Wartości testów sprawy.</span><span class="sxs-lookup"><span data-stu-id="03398-3643">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="03398-3644">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> obiektów, które zostaną użyte w <see cref="T:System.Linq.Expressions.SwitchExpression" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="03398-3644">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</span></span></summary>
        <returns><span data-ttu-id="03398-3645">Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3645">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3646">Wszystkie <xref:System.Linq.Expressions.SwitchCase> obiekty w <xref:System.Linq.Expressions.SwitchExpression> obiekt musi mieć tego samego typu, chyba że <xref:System.Linq.Expressions.SwitchExpression> ma typ `void`.</span><span class="sxs-lookup"><span data-stu-id="03398-3646">All <xref:System.Linq.Expressions.SwitchCase> objects in a <xref:System.Linq.Expressions.SwitchExpression> object must have the same type, unless the <xref:System.Linq.Expressions.SwitchExpression> has the type `void`.</span></span>  
  
 <span data-ttu-id="03398-3647">Każdy <xref:System.Linq.Expressions.SwitchCase> obiektu jest niejawny `break` instrukcji, co oznacza, że nie istnieje żadne niejawne fall za pośrednictwem od jednej etykiety case do innej.</span><span class="sxs-lookup"><span data-stu-id="03398-3647">Each <xref:System.Linq.Expressions.SwitchCase> object has an implicit `break` statement, which means that there is no implicit fall through from one case label to another.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3648">Poniższy przykład pokazuje, jak utworzyć wyrażenie, który reprezentuje instrukcji pomocą przełącznika, który ma przypadek domyślny.</span><span class="sxs-lookup"><span data-stu-id="03398-3648">The following example demonstrates how to create an expression that represents a swtich statement that has a default case.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3649">Treść przypadku.</span><span class="sxs-lookup"><span data-stu-id="03398-3649">The body of the case.</span></span></param>
        <param name="testValues"><span data-ttu-id="03398-3650">Wartości testów sprawy.</span><span class="sxs-lookup"><span data-stu-id="03398-3650">The test values of the case.</span></span></param>
        <summary><span data-ttu-id="03398-3651">Tworzy <see cref="T:System.Linq.Expressions.SwitchCase" /> do użycia w <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3651">Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3652">Utworzony <see cref="T:System.Linq.Expressions.SwitchCase" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3652">The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3653">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3653">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="03398-3654">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3654">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3655">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3655">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3656">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3656">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="03398-3657">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3657">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="03398-3658">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3658">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3659">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3659">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> właściwości ustawione na określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="03398-3660">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="03398-3661">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3661">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="03398-3662">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3662">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="03398-3663">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3663">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3664">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3664">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3665">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> właściwości ustawione na określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="03398-3665">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="03398-3666">A <see cref="T:System.String" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3666">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</span></span></param>
        <param name="language"><span data-ttu-id="03398-3667">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3667">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</span></span></param>
        <param name="languageVendor"><span data-ttu-id="03398-3668">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3668">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</span></span></param>
        <param name="documentType"><span data-ttu-id="03398-3669">A <see cref="T:System.Guid" /> można ustawić <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> równa.</span><span class="sxs-lookup"><span data-stu-id="03398-3669">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3670">Tworzy wystąpienie <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3670">Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3671">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> zawierający <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> i <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> właściwości ustawione na określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="03398-3671">A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3672">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="03398-3672">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="03398-3673"><see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3673">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <summary><span data-ttu-id="03398-3674">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="03398-3674">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</span></span></summary>
        <returns><span data-ttu-id="03398-3675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</span><span class="sxs-lookup"><span data-stu-id="03398-3675">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-3676">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiektu, który używa <xref:System.Linq.Expressions.Expression.Throw%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3676">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that uses the <xref:System.Linq.Expressions.Expression.Throw%2A> method.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="03398-3677"><see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3677">An <see cref="T:System.Linq.Expressions.Expression" />.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3678">Nowy <see cref="T:System.Type" /> wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3678">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="03398-3679">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący, zostanie zgłoszony wyjątek z danym typem.</span><span class="sxs-lookup"><span data-stu-id="03398-3679">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</span></span></summary>
        <returns><span data-ttu-id="03398-3680">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący wyjątek.</span><span class="sxs-lookup"><span data-stu-id="03398-3680">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="03398-3681">Zwraca tekstową reprezentację wartości <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3681">Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3682">Tekstowa reprezentacja <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3682">A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3683">Treści bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3683">The body of the try block.</span></span></param>
        <param name="handlers"><span data-ttu-id="03398-3684">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch, który ma zostać skojarzony z bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3684">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="03398-3685">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby catch, instrukcje i ani błędów, ani bloku finally.</span><span class="sxs-lookup"><span data-stu-id="03398-3685">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</span></span></summary>
        <returns><span data-ttu-id="03398-3686">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3686">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-3687">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch.</span><span class="sxs-lookup"><span data-stu-id="03398-3687">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3688">Treści bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3688">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="03398-3689">Treści bloku finally.</span><span class="sxs-lookup"><span data-stu-id="03398-3689">The body of the finally block.</span></span></param>
        <param name="handlers"><span data-ttu-id="03398-3690">Tablica zero lub więcej <see cref="T:System.Linq.Expressions.CatchBlock" /> wyrażeń reprezentujących instrukcji catch, który ma zostać skojarzony z bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3690">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</span></span></param>
        <summary><span data-ttu-id="03398-3691">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z dowolnej liczby instrukcji catch i bloku finally.</span><span class="sxs-lookup"><span data-stu-id="03398-3691">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</span></span></summary>
        <returns><span data-ttu-id="03398-3692">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3692">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="03398-3693">Poniższy przykład przedstawia sposób tworzenia <xref:System.Linq.Expressions.TryExpression> obiekt, który zawiera instrukcję catch i finally, instrukcja.</span><span class="sxs-lookup"><span data-stu-id="03398-3693">The following example demonstrates how to create a <xref:System.Linq.Expressions.TryExpression> object that contains a catch statement and a finally statement.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3694">Treści bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3694">The body of the try block.</span></span></param>
        <param name="fault"><span data-ttu-id="03398-3695">Treść bloku błędów.</span><span class="sxs-lookup"><span data-stu-id="03398-3695">The body of the fault block.</span></span></param>
        <summary><span data-ttu-id="03398-3696">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący bloku try z blokiem błędów i nie catch, instrukcje.</span><span class="sxs-lookup"><span data-stu-id="03398-3696">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="03398-3697">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3697">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body"><span data-ttu-id="03398-3698">Treści bloku try.</span><span class="sxs-lookup"><span data-stu-id="03398-3698">The body of the try block.</span></span></param>
        <param name="finally"><span data-ttu-id="03398-3699">Treści bloku finally.</span><span class="sxs-lookup"><span data-stu-id="03398-3699">The body of the finally block.</span></span></param>
        <summary><span data-ttu-id="03398-3700">Tworzy <see cref="T:System.Linq.Expressions.TryExpression" /> reprezentujący za pomocą bloku try finally blok i nie catch, instrukcje.</span><span class="sxs-lookup"><span data-stu-id="03398-3700">Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</span></span></summary>
        <returns><span data-ttu-id="03398-3701">Utworzony <see cref="T:System.Linq.Expressions.TryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3701">The created <see cref="T:System.Linq.Expressions.TryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="03398-3702">Tablica obiektów typu, które określają argumenty typu dla typu delegat elementu System.Action.</span><span class="sxs-lookup"><span data-stu-id="03398-3702">An array of Type objects that specify the type arguments for the System.Action delegate type.</span></span></param>
        <param name="actionType"><span data-ttu-id="03398-3703">Po powrocie z tej metody zawiera typ delegat elementu System.Action ogólny, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-3703">When this method returns, contains the generic System.Action delegate type that has specific type arguments.</span></span> <span data-ttu-id="03398-3704">Zawiera wartość null, jeśli nie ogólnego delegat elementu System.Action, który odpowiada <paramref name="typeArgs" />. Ten parametr jest przekazywany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="03398-3704">Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="03398-3705">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typ ogólny delegat elementu System.Action, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-3705">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</span></span></summary>
        <returns><span data-ttu-id="03398-3706"><see langword="true" /> Jeśli typ ogólny delegat elementu System.Action został utworzony dla konkretnego <paramref name="typeArgs" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3706"><see langword="true" /> if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs"><span data-ttu-id="03398-3707">Tablica obiektów typu, które określają argumenty typu dla typu delegata System.Func.</span><span class="sxs-lookup"><span data-stu-id="03398-3707">An array of Type objects that specify the type arguments for the System.Func delegate type.</span></span></param>
        <param name="funcType"><span data-ttu-id="03398-3708">Po powrocie z tej metody zawiera typ delegata System.Func ogólny, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-3708">When this method returns, contains the generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="03398-3709">Zawiera wartość null, jeśli nie Delegat ogólny System.Func, który odpowiada <paramref name="typeArgs" />. Ten parametr jest przekazywany jako niezainicjowany.</span><span class="sxs-lookup"><span data-stu-id="03398-3709">Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="03398-3710">Tworzy <see cref="P:System.Linq.Expressions.Expression.Type" /> obiekt, który reprezentuje typ ogólny delegata System.Func, który zawiera argumenty określonego typu.</span><span class="sxs-lookup"><span data-stu-id="03398-3710">Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments.</span></span> <span data-ttu-id="03398-3711">Ostatni argument typu określa zwracany typ delegata utworzony.</span><span class="sxs-lookup"><span data-stu-id="03398-3711">The last type argument specifies the return type of the created delegate.</span></span></summary>
        <returns><span data-ttu-id="03398-3712"><see langword="true" /> Jeśli ogólny typ delegata System.Func został utworzony dla konkretnego <paramref name="typeArgs" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3712"><see langword="true" /> if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="03398-3713">Pobiera typu statycznego wyrażenia, które to <see cref="T:System.Linq.Expressions.Expression" /> reprezentuje.</span><span class="sxs-lookup"><span data-stu-id="03398-3713">Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</span></span></summary>
        <value><span data-ttu-id="03398-3714"><see cref="T:System.Type" /> Reprezentujący typu statycznego wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3714">The <see cref="T:System.Type" /> that represents the static type of the expression.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3715"><xref:System.Linq.Expressions.Expression.NodeType%2A> Jest typ węzła drzewa wyrażeń, natomiast <xref:System.Linq.Expressions.Expression.Type%2A> reprezentuje wspólnego języka wspólnego (CLR) typu statycznego wyrażenia, który reprezentuje węzeł.</span><span class="sxs-lookup"><span data-stu-id="03398-3715">The <xref:System.Linq.Expressions.Expression.NodeType%2A> is the type of the expression tree node, whereas the <xref:System.Linq.Expressions.Expression.Type%2A> represents the static common language runtime (CLR) type of the expression that the node represents.</span></span> <span data-ttu-id="03398-3716">Na przykład dwoma węzłami z różnych typów węzłów może mieć takie same <xref:System.Linq.Expressions.Expression.Type%2A>, jak pokazano w poniższym przykładzie kodu.</span><span class="sxs-lookup"><span data-stu-id="03398-3716">For example, two nodes with different node types can have the same <xref:System.Linq.Expressions.Expression.Type%2A>, as shown in the following code example.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3717"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3717">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3718">A <see cref="T:System.Type" /> można ustawić <see cref="P:System.Linq.Expressions.Expression.Type" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3718">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3719">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawnego odwołania lub konwersja boxing gdzie <see langword="null" /> jest podany, jeśli konwersja nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="03398-3719">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</span></span></summary>
        <returns><span data-ttu-id="03398-3720">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.Expression.Type" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3720">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3721"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> jest `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3721">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is `null`.</span></span> <span data-ttu-id="03398-3722"><xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> właściwości są `false`.</span><span class="sxs-lookup"><span data-stu-id="03398-3722">The <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> properties are both `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3723">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.UnaryExpression> reprezentujący konwersja odwołania wyrażenia nieprzyjmujące wartości liczby całkowitej. typ dopuszczający wartość null liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="03398-3723">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.UnaryExpression> that represents the reference conversion of a non-nullable integer expression to the nullable integer type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3724"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3724"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3725"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="T:System.Linq.Expressions.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3725">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3726">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3726">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3727">Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> , porównuje tożsamości typu run-time.</span><span class="sxs-lookup"><span data-stu-id="03398-3727">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</span></span></summary>
        <returns><span data-ttu-id="03398-3728">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> i dla których <see cref="T:System.Linq.Expressions.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3728">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3729"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3729">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> można ustawić <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3730">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3731">Tworzy <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3731">Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</span></span></summary>
        <returns><span data-ttu-id="03398-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dla którego <see cref="P:System.Linq.Expressions.Expression.NodeType" /> właściwości jest równa <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> i dla których <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> i <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> właściwości są ustawione do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3732">A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3733"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> reprezentuje <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="03398-3733">The <xref:System.Linq.Expressions.Expression.Type%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> represents <xref:System.Boolean>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03398-3734">Poniższy przykład pokazuje sposób użycia <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> metodę w celu utworzenia <xref:System.Linq.Expressions.TypeBinaryExpression> reprezentująca to test typ wartości ciągu przed <xref:System.Int32> typu.</span><span class="sxs-lookup"><span data-stu-id="03398-3734">The following example demonstrates how to use the <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> method to create a <xref:System.Linq.Expressions.TypeBinaryExpression> that represents a type test of a string value against the <xref:System.Int32> type.</span></span>  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3735"><paramref name="expression" /> lub <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3735"><paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3736">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</span><span class="sxs-lookup"><span data-stu-id="03398-3736">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3737"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3737">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3738">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</span><span class="sxs-lookup"><span data-stu-id="03398-3738">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3739">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> właściwość o określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3739">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3740"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3740">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-3741"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3741">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3742">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3742">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3743">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-3743">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3744">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3744">Implementing Method</span></span>  
 <span data-ttu-id="03398-3745">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3745">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3746">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje operator, plus jednoargumentowy <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3746">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3747">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3747">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3748">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3748">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3749">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3749">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3750">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3750">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3751">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3751">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3752">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3752">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3753">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-3753">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3754">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3754">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3755">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3755">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-3756">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3756">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3757">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3757">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3758"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3758"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3759">Jednoargumentowy operator plus nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3759">The unary plus operator is not defined for <paramref name="expression" />.Type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3760"><see cref="T:System.Linq.Expressions.Expression" /> Można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3760">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</span></span></param>
        <param name="method"><span data-ttu-id="03398-3761">A <see cref="T:System.Reflection.MethodInfo" /> można ustawić <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3761">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</span></span></param>
        <summary><span data-ttu-id="03398-3762">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący Jednoargumentowa operacja plus.</span><span class="sxs-lookup"><span data-stu-id="03398-3762">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</span></span></summary>
        <returns><span data-ttu-id="03398-3763">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> zawierający <see cref="P:System.Linq.Expressions.Expression.NodeType" /> równa właściwości <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> i <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> równa określonej wartości właściwości.</span><span class="sxs-lookup"><span data-stu-id="03398-3763">A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3764"><xref:System.Linq.Expressions.UnaryExpression.Method%2A> Właściwość wynikowy <xref:System.Linq.Expressions.UnaryExpression> ustawiono implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3764">The <xref:System.Linq.Expressions.UnaryExpression.Method%2A> property of the resulting <xref:System.Linq.Expressions.UnaryExpression> is set to the implementing method.</span></span> <span data-ttu-id="03398-3765"><xref:System.Linq.Expressions.Expression.Type%2A> Właściwość jest ustawiona na typ węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3765">The <xref:System.Linq.Expressions.Expression.Type%2A> property is set to the type of the node.</span></span> <span data-ttu-id="03398-3766">Jeśli węzeł zostało zniesione, <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> i <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> właściwości są `true`.</span><span class="sxs-lookup"><span data-stu-id="03398-3766">If the node is lifted, the <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> and <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> properties are both `true`.</span></span> <span data-ttu-id="03398-3767">Są one w przeciwnym razie wartość false.</span><span class="sxs-lookup"><span data-stu-id="03398-3767">Otherwise, they are false.</span></span>  
  
#### <a name="implementing-method"></a><span data-ttu-id="03398-3768">Metoda implementująca</span><span class="sxs-lookup"><span data-stu-id="03398-3768">Implementing Method</span></span>  
 <span data-ttu-id="03398-3769">Następujące reguły określają implementującej metody dla operacji:</span><span class="sxs-lookup"><span data-stu-id="03398-3769">The following rules determine the implementing method for the operation:</span></span>  
  
-   <span data-ttu-id="03398-3770">Jeśli `method` nie jest `null` i reprezentuje inny niż void, `static` (`Shared` w języku Visual Basic) metoda, która przyjmuje jeden argument jest implementującej metody dla węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3770">If `method` is not `null` and it represents a non-void, `static` (`Shared` in Visual Basic) method that takes one argument, it is the implementing method for the node.</span></span>  
  
-   <span data-ttu-id="03398-3771">Jeśli `expression`. Typem jest typ zdefiniowany przez użytkownika, który definiuje operator, plus jednoargumentowy <xref:System.Reflection.MethodInfo> , który reprezentuje operator jest implementującej metody.</span><span class="sxs-lookup"><span data-stu-id="03398-3771">If `expression`.Type is a user-defined type that defines the unary plus operator, the <xref:System.Reflection.MethodInfo> that represents that operator is the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3772">W przeciwnym razie, jeśli `expression`. Typ jest typu liczbowego, jest implementującej metody `null`.</span><span class="sxs-lookup"><span data-stu-id="03398-3772">Otherwise, if `expression`.Type is a numeric type, the implementing method is `null`.</span></span>  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a><span data-ttu-id="03398-3773">Typ węzła oraz węzły podniesione i niepodniesione</span><span class="sxs-lookup"><span data-stu-id="03398-3773">Node Type and Lifted versus Non-Lifted</span></span>  
 <span data-ttu-id="03398-3774">Jeśli implementującej metody nie jest `null`:</span><span class="sxs-lookup"><span data-stu-id="03398-3774">If the implementing method is not `null`:</span></span>  
  
-   <span data-ttu-id="03398-3775">Jeśli `expression`. Typ można przypisać do typu argumentu metody wykonawcze, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3775">If `expression`.Type is assignable to the argument type of the implementing method, the node is not lifted.</span></span> <span data-ttu-id="03398-3776">Typ węzła jest typem zwracanym metody wykonawcze.</span><span class="sxs-lookup"><span data-stu-id="03398-3776">The type of the node is the return type of the implementing method.</span></span>  
  
-   <span data-ttu-id="03398-3777">Jeśli następujące dwa warunki są spełnione, węzeł zostało zniesione i typ węzła jest typ dopuszczający wartość null, który odpowiada na zwracany typ metody wykonawcze:</span><span class="sxs-lookup"><span data-stu-id="03398-3777">If the following two conditions are satisfied, the node is lifted and the type of the node is the nullable type that corresponds to the return type of the implementing method:</span></span>  
  
    -   <span data-ttu-id="03398-3778">`expression`. Typ jest typem wartościowym i odpowiedni typ wartości nie przyjmujące wartości jest równa argument typu implementującego metodę.</span><span class="sxs-lookup"><span data-stu-id="03398-3778">`expression`.Type is a nullable value type and the corresponding non-nullable value type is equal to the argument type of the implementing method.</span></span>  
  
    -   <span data-ttu-id="03398-3779">Zwracany typ metody wykonawcze jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="03398-3779">The return type of the implementing method is a non-nullable value type.</span></span>  
  
 <span data-ttu-id="03398-3780">Jeśli metoda implementującej jest `null`, typ węzła jest `expression`. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3780">If the implementing method is `null`, the type of the node is `expression`.Type.</span></span> <span data-ttu-id="03398-3781">Jeśli `expression`. Typ wartości null, węzeł nie zostało zniesione.</span><span class="sxs-lookup"><span data-stu-id="03398-3781">If `expression`.Type is non-nullable, the node is not lifted.</span></span> <span data-ttu-id="03398-3782">W przeciwnym razie zostało zniesione węzła.</span><span class="sxs-lookup"><span data-stu-id="03398-3782">Otherwise, the node is lifted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="03398-3783"><paramref name="expression" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3783"><paramref name="expression" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="03398-3784"><paramref name="method" /> nie jest <see langword="null" /> i metody reprezentująca zwraca <see langword="void" />, nie jest <see langword="static" /> (<see langword="Shared" /> w języku Visual Basic), lub nie ma dokładnie jednego argumentu.</span><span class="sxs-lookup"><span data-stu-id="03398-3784"><paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="03398-3785"><paramref name="method" /> jest <see langword="null" /> i Jednoargumentowy operator plus nie jest zdefiniowany dla <paramref name="expression" />. Typ.</span><span class="sxs-lookup"><span data-stu-id="03398-3785"><paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.</span></span>  
  
<span data-ttu-id="03398-3786">—lub—</span><span class="sxs-lookup"><span data-stu-id="03398-3786">-or-</span></span> 
 <span data-ttu-id="03398-3787"><paramref name="expression" />. Typu (lub odpowiedni typ wartości null, jeśli jest to typ wartości null) nie jest możliwy do przypisania do typu argumentu metody reprezentowanej przez <paramref name="method" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3787"><paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="03398-3788"><see cref="T:System.Linq.Expressions.Expression" /> Do rozpakowania.</span><span class="sxs-lookup"><span data-stu-id="03398-3788">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</span></span></param>
        <param name="type"><span data-ttu-id="03398-3789">Nowy <see cref="T:System.Type" /> wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3789">The new <see cref="T:System.Type" /> of the expression.</span></span></param>
        <summary><span data-ttu-id="03398-3790">Tworzy <see cref="T:System.Linq.Expressions.UnaryExpression" /> reprezentujący jawne rozpakowywania.</span><span class="sxs-lookup"><span data-stu-id="03398-3790">Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</span></span></summary>
        <returns><span data-ttu-id="03398-3791">Wystąpienie <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3791">An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="03398-3792">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3792">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3793">Typ parametr lub zmienna.</span><span class="sxs-lookup"><span data-stu-id="03398-3793">The type of the parameter or variable.</span></span></param>
        <summary><span data-ttu-id="03398-3794">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3794">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="03398-3795">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie</span><span class="sxs-lookup"><span data-stu-id="03398-3795">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="03398-3796">Typ parametr lub zmienna.</span><span class="sxs-lookup"><span data-stu-id="03398-3796">The type of the parameter or variable.</span></span></param>
        <param name="name"><span data-ttu-id="03398-3797">Nazwa parametr lub zmienna.</span><span class="sxs-lookup"><span data-stu-id="03398-3797">The name of the parameter or variable.</span></span> <span data-ttu-id="03398-3798">Ta nazwa jest używana do debugowania lub drukowanie tylko do celów.</span><span class="sxs-lookup"><span data-stu-id="03398-3798">This name is used for debugging or printing purpose only.</span></span></param>
        <summary><span data-ttu-id="03398-3799">Tworzy <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł, który może służyć do identyfikowania parametr lub zmienna w drzewo wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3799">Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</span></span></summary>
        <returns><span data-ttu-id="03398-3800">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> węzeł o określonej nazwie i typie.</span><span class="sxs-lookup"><span data-stu-id="03398-3800">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><span data-ttu-id="03398-3801">Wystąpienie <see cref="T:System.Func`2" />.</span><span class="sxs-lookup"><span data-stu-id="03398-3801">An instance of <see cref="T:System.Func`2" />.</span></span></param>
        <summary><span data-ttu-id="03398-3802">Zmniejsza węzeł, a następnie wywołuje delegata gości na mniejsze wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="03398-3802">Reduces the node and then calls the visitor delegate on the reduced expression.</span></span> <span data-ttu-id="03398-3803">Metoda zgłasza wyjątek, jeśli węzeł nie jest obniżaniu.</span><span class="sxs-lookup"><span data-stu-id="03398-3803">The method throws an exception if the node is not reducible.</span></span></summary>
        <returns><span data-ttu-id="03398-3804">Wyrażenie odwiedzana lub wyrażeniem, które powinny zostać użyte w drzewie.</span><span class="sxs-lookup"><span data-stu-id="03398-3804">The expression being visited, or an expression which should replace it in the tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03398-3805">Zastępuje tę metodę, aby zapewnić logikę, aby zapoznać się z węzłów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="03398-3805">Override this method to provide logic to walk the node's children.</span></span> <span data-ttu-id="03398-3806">Typowa implementacja wywołuje obiekt odwiedzający. Odwiedź stronę na każdym z jego elementów podrzędnych, a ewentualne je zmienić, powinna zwrócić nową kopię sam z zmodyfikowane elementy podrzędne.</span><span class="sxs-lookup"><span data-stu-id="03398-3806">A typical implementation will call visitor.Visit on each of its children, and if any of them change, should return a new copy of itself with the modified children.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="SemaphoreSecurity.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac584c547789bd5907b052331368ba36af03e2fe08f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84c547789bd5907b052331368ba36af03e2fe08f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Represents the Windows access control security for a named semaphore.</source>
          <target state="translated">Reprezentuje kontrolę dostępu systemu Windows o nazwie semafora.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>This class cannot be inherited.</source>
          <target state="translated">Klasa ta nie może być dziedziczona.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>A <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object specifies access rights for a named system semaphore, and also specifies how access attempts are audited.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu określa prawa dostępu do semafora nazwanego systemu oraz określa, jak są poddawane inspekcji prób dostępu.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Access rights to the semaphore are expressed as rules, with each access rule represented by a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> object.</source>
          <target state="translated">Prawa dostępu do semafora są wyrażane jako reguł, z dostępu reprezentowany przez <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Each auditing rule is represented by a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> object.</source>
          <target state="translated">Każda reguła inspekcji jest reprezentowana przez <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>This mirrors the underlying Windows security system, in which each securable object has at most one discretionary access control list (DACL) that controls access to the secured object, and at most one system access control list (SACL) that specifies which access attempts are audited.</source>
          <target state="translated">Odzwierciedla to podstawowy system zabezpieczeń systemu Windows, w którym każdy zabezpieczanego obiektu ma co najwyżej jeden poufnej listy kontroli dostępu (DACL), że kontroluje dostęp do bezpiecznego obiektu i co najwyżej jeden system listy kontroli dostępu (SACL) określająca, do których dostęp prób są poddawane inspekcji.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The DACL and SACL are ordered lists of access control entries (ACE) that specify access and auditing for users and groups.</source>
          <target state="translated">Listy DACL i SACL są uporządkowane listy wpisów kontroli dostępu (ACE), które określają dostępu i inspekcji dla użytkowników i grup.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>A <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> object might represent more than one ACE.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> lub <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> object może reprezentować więcej niż jednego wpisu kontroli dostępu.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>A <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object can represent a local semaphore or a named system semaphore.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu może reprezentować semafora lokalnego lub semafora systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Windows access control security is meaningful only for named system semaphores.</source>
          <target state="translated">Kontrolę dostępu systemu Windows jest znaczący tylko w przypadku systemu o nazwie semaforów.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph>, and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> classes hide the implementation details of ACLs and ACEs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph>, I <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> klasy Ukryj szczegóły implementacji wpisów ACE i listy kontroli dostępu.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>They allow you to ignore the seventeen different ACE types and the complexity of correctly maintaining inheritance and propagation of access rights.</source>
          <target state="translated">Umożliwiają one Ignoruj siedemnaście różne typy ACE i złożoność poprawnie obsługi dziedziczenia i propagacji praw dostępu.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>These objects are also designed to prevent the following common access control errors:</source>
          <target state="translated">Te obiekty są również zaprojektowana tak, aby zapobiec następujące typowe błędy kontroli dostępu:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Creating a security descriptor with a null DACL.</source>
          <target state="translated">Tworzenie deskryptora zabezpieczeń z listy DACL wartości null.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>A null reference to a DACL allows any user to add access rules to an object, potentially creating a denial-of-service attack.</source>
          <target state="translated">Odwołanie o wartości null do listy DACL umożliwia dowolnym użytkownikom dodawanie reguły dostępu do obiektu, potencjalnie tworzenie ataku typu "odmowa usługi".</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>A new <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object always starts with an empty DACL, which denies all access for all users.</source>
          <target state="translated">Nowy <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu zawsze rozpoczyna się od pusty listy DACL, która nie zezwala na dostęp dla wszystkich użytkowników.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Violating the canonical ordering of ACEs.</source>
          <target state="translated">Naruszenie canonical kolejność ACE.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>If the ACE list in the DACL is not kept in the canonical order, users might inadvertently be given access to the secured object.</source>
          <target state="translated">Lista ACE w listy DACL nie jest przechowywany w Porządek kanoniczny, użytkownicy mogą przypadkowo uzyskać dostęp do zabezpieczonego obiektu.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>For example, denied access rights must always appear before allowed access rights.</source>
          <target state="translated">Na przykład prawa dostępu odmowy zawsze musi występować przed dozwolone uprawnienia.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source><ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> objects maintain the correct order internally.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiekty wewnętrznie Obsługa właściwej kolejności.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Manipulating security descriptor flags, which should be under resource manager control only.</source>
          <target state="translated">Manipulowanie flagi deskryptora zabezpieczeń, które powinny być pod kontrolą Menedżera zasobów tylko.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Creating invalid combinations of ACE flags.</source>
          <target state="translated">Tworzenie nieprawidłową kombinację flag ACE.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Manipulating inherited ACEs.</source>
          <target state="translated">Manipulowanie ACE dziedziczone.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Inheritance and propagation are handled by the resource manager, in response to changes you make to access and audit rules.</source>
          <target state="translated">Dziedziczenie i propagacji są obsługiwane przez Menedżera zasobów w odpowiedzi na zmiany wprowadzone do reguł dostępu i inspekcji.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Inserting meaningless ACEs into ACLs.</source>
          <target state="translated">Wstawianie znaczenia wpisy kontroli dostępu do listy kontroli dostępu.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The only capabilities not supported by the .NET security objects are dangerous activities that should be avoided by the majority of application developers, such as the following:</source>
          <target state="translated">Tylko funkcje nie są obsługiwane przez obiekty zabezpieczeń .NET są niebezpieczne działania, które należy unikać przez większość deweloperów aplikacji, takie jak następujące:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Low-level tasks that are normally performed by the resource manager.</source>
          <target state="translated">Zadania niskiego poziomu, które są wykonywane zwykle przez Menedżera zasobów.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Adding or removing access control entries in ways that do not maintain the canonical ordering.</source>
          <target state="translated">Dodawanie lub usuwanie wpisów kontroli dostępu w sposób, w którym nie obsługują canonical porządkowania.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>To modify Windows access control security for a named semaphore, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to get the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Aby zmodyfikować Windows kontrolę dostępu dla nazwanego semafora, użyj <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> metodę, aby pobrać <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Modify the security object by adding and removing rules, and then use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to reattach it.</source>
          <target state="translated">Zmodyfikuj obiekt zabezpieczeń przez dodawanie i usuwanie reguł, a następnie użyć <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> metodę, aby dołączyć go ponownie.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Changes you make to a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object do not affect the access levels of the named semaphore until you call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to assign the altered security object to the named semaphore.</source>
          <target state="translated">Zmiany wprowadzane do <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu nie wpływają na poziomów dostępu o nazwie semafora czasu wywołania <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> metodę przypisania do semafora nazwanego obiektu zmieniony zabezpieczeń.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>To copy access control security from one semaphore to another, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object representing the access and audit rules for the first semaphore, then use the <ph id="ph3">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method, or a constructor that accepts a <ph id="ph4">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, to assign those rules to the second semaphore.</source>
          <target state="translated">Aby skopiować kontrolę dostępu z jednego semafora do innego, należy użyć <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> metodę, aby pobrać <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiekt reprezentujący reguł dostępu i inspekcji dla pierwszego semafora, a następnie użyj <ph id="ph3">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> metody lub konstruktora akceptującego <ph id="ph4">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu można przypisać te reguły do semafora drugiego.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Users with an investment in the security descriptor definition language (SDDL) can use the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A&gt;</ph> method to set access rules for a named semaphore, and the <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A&gt;</ph> method to obtain a string that represents the access rules in SDDL format.</source>
          <target state="translated">Użytkownicy z inwestycji w definicji deskryptora zabezpieczeń w języku (SDDL) można używać <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A&gt;</ph> metodę, aby ustawić zasady dostępu o nazwie semafora i <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A&gt;</ph> metodę, aby uzyskać ciąg reprezentujący format SDDL reguły dostępu.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>This is not recommended for new development.</source>
          <target state="translated">Nie jest to zalecane w przypadku nowych wdrożeń.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Security on synchronization objects is not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Zabezpieczenia obiektów synchronizacji nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The following code example demonstrates the separation between <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rules and <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> rules, and shows the combination of rights in compatible rules.</source>
          <target state="translated">Poniższy przykład kodu pokazuje oddzielenie <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguł i <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> reguł i zawiera kombinację praw w niezgodne reguły.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu, dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika i wyświetla wynikowy pary reguł.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule.</source>
          <target state="translated">W przykładzie następnie umożliwia nowe prawa dla bieżącego użytkownika oraz wyświetla wynik, pokazujący, że nowe uprawnienia zostaną scalone z istniejącym <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="T:System.Security.AccessControl.SemaphoreSecurity">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class with default values.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> z domyślnymi wartościami.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor">
          <source>A new <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object always starts with an empty discretionary access list (DACL), which denies all access for all users.</source>
          <target state="translated">Nowy <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu zawsze rozpoczyna się od listy pusty dostępu (DACL), która nie zezwala na dostęp dla wszystkich użytkowników.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor">
          <source>This class is not supported on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>The name of the system semaphore whose access control security rules are to be retrieved.</source>
          <target state="translated">Nazwa semafora systemowego, której reguły zabezpieczeń kontroli dostępu mają zostać pobrane.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>A combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlSections" /&gt;</ph> flags specifying the sections to retrieve.</source>
          <target state="translated">Kombinację <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlSections" /&gt;</ph> flagi określające sekcje do pobrania.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class with the specified sections of the access control security rules from the system semaphore with the specified name.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> klasy z określonej sekcji zasady zabezpieczeń kontroli dostępu z semafora systemowego o określonej nazwie.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>This constructor allows you to obtain the access control security for a named system semaphore without first creating a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">Ten konstruktor umożliwia uzyskiwanie kontrolę dostępu do semafora systemu o nazwie bez tworzenia <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>Caution must be exercised when working with named system objects.</source>
          <target state="translated">Uwaga muszą być wykonywane podczas pracy z obiektami systemu o nazwie.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>If there is a system object named <ph id="ph1">`name`</ph> that is not a semaphore, its control access security might be retrieved.</source>
          <target state="translated">Jeśli jest obiektem systemu o nazwie <ph id="ph1">`name`</ph> nie jest semafora, kontroli dostępu zabezpieczeń może pobrać.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)">
          <source>This class is not supported on Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType">
          <source>Gets the enumeration that the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class uses to represent access rights.</source>
          <target state="translated">Pobiera wyliczenie, który <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> klasa używana do reprezentowania praw dostępu.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> enumeration.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> reprezentujący obiekt <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> wyliczenia.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> class override the <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A&gt;</ph> property and return the type they use to represent access rights.</source>
          <target state="translated">Klasy, które pochodzą z <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> klasy zastąpienie <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A&gt;</ph> właściwości i zwracany typ przejdą do reprezentowania praw dostępu.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType">
          <source>When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct enumeration type to use with each security object.</source>
          <target state="translated">Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu wyliczenia poprawne korzystać z każdego obiektu zabezpieczeń.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Principal.IdentityReference" /&gt;</ph> that identifies the user or group the rule applies to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Principal.IdentityReference" /&gt;</ph> , Które identyfikują użytkownik lub grupa reguła dotyczy.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> values specifying the access rights to allow or deny, cast to an integer.</source>
          <target state="translated">Bitowe połączenie <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> wartości określających prawa dostępu do dozwolonych lub zablokowanych, rzutowania na liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Meaningless for named semaphores, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Meaningless for named semaphores, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Meaningless for named semaphores, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> values specifying whether the rights are allowed or denied.</source>
          <target state="translated">Jeden z <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> wartości określający, czy prawa zezwolono na dostęp lub odmowa dostępu.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Creates a new access control rule for the specified user, with the specified access rights, access control, and flags.</source>
          <target state="translated">Tworzy nową regułę kontroli dostępu dla określonego użytkownika z określonego uprawnienia kontroli dostępu i flagi.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> object representing the specified rights for the specified user.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> obiekt reprezentujący określonego uprawnienia dla określonego użytkownika.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>The recommended way to create access control rules is to use the constructors of the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> class.</source>
          <target state="translated">Zalecanym sposobem tworzenia zasad kontroli dostępu jest użycie konstruktorów <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAccessRule&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>Although inheritance and propagation flags are meaningless for named semaphores, it is still possible to specify them This is not recommended, because it needlessly complicates the maintenance of rules, for example by interfering with the combination of rules that would otherwise be compatible.</source>
          <target state="translated">Mimo że flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe, określ je, który nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguły w przeciwnym razie wyniesie zgodne.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph>, <ph id="ph2">&lt;paramref name="inheritanceFlags" /&gt;</ph>, <ph id="ph3">&lt;paramref name="propagationFlags" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="type" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph>, <ph id="ph2">&lt;paramref name="inheritanceFlags" /&gt;</ph>, <ph id="ph3">&lt;paramref name="propagationFlags" /&gt;</ph>, lub <ph id="ph4">&lt;paramref name="type" /&gt;</ph> określa nieprawidłową wartość.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph> wynosi zero.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)">
          <source><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> is neither of type <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>, nor of a type such as <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> nie jest ani typu <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>, ani typu, takich jak <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> którego można przekonwertować na typ <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType">
          <source>Gets the type that the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class uses to represent access rules.</source>
          <target state="translated">Pobiera typ, który <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> klasa używana do reprezentowania zasad dostępu.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> class.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> reprezentujący obiekt <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> class override the <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A&gt;</ph> property and return the type they use to represent access rules.</source>
          <target state="translated">Klasy, które pochodzą z <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> klasy zastąpienie <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A&gt;</ph> właściwości i zwracany typ przejdą do reprezentowania zasad dostępu.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType">
          <source>When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct access rule type to use with each security object.</source>
          <target state="translated">Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły dostępu do użycia z każdego obiektu zabezpieczeń.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The access control rule to add.</source>
          <target state="translated">Reguła kontroli dostępu do dodania.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Searches for a matching rule with which the new rule can be merged.</source>
          <target state="translated">Wyszukuje Reguła dopasowywania, z którego można by scalić nowej reguły.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If none are found, adds the new rule.</source>
          <target state="translated">Jeśli żaden nie zostaną znalezione, dodaje nową regułę.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A&gt;</ph> method searches for rules with the same user or group and the same <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> as <ph id="ph3">`rule`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A&gt;</ph> Metoda szuka reguły z tego samego użytkownika lub grupy i tym samym <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> jako <ph id="ph3">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If none are found, <ph id="ph1">`rule`</ph> is added.</source>
          <target state="translated">Jeśli żaden nie zostaną znalezione, <ph id="ph1">`rule`</ph> został dodany.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If a matching rule is found, the rights in <ph id="ph1">`rule`</ph> are merged with the existing rule.</source>
          <target state="translated">Jeśli reguła dopasowywania zostanie znaleziony, prawa w <ph id="ph1">`rule`</ph> są łączone z istniejącą regułą.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example demonstrates the separation between <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rules and <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> rules, and shows the combination of rights in compatible rules.</source>
          <target state="translated">Poniższy przykład kodu pokazuje oddzielenie <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguł i <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> reguł i zawiera kombinację praw w niezgodne reguły.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu, dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika i wyświetla wynikowy pary reguł.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule.</source>
          <target state="translated">W przykładzie następnie umożliwia nowe prawa dla bieżącego użytkownika oraz wyświetla wynik, pokazujący, że nowe uprawnienia zostaną scalone z istniejącym <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The audit rule to add.</source>
          <target state="translated">Reguła inspekcji, aby dodać.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The user specified by this rule determines the search.</source>
          <target state="translated">Użytkownik określony przez tę regułę określa wyszukiwania.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Searches for an audit rule with which the new rule can be merged.</source>
          <target state="translated">Wyszukuje reguła inspekcji, z którego można by scalić nowej reguły.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If none are found, adds the new rule.</source>
          <target state="translated">Jeśli żaden nie zostaną znalezione, dodaje nową regułę.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A&gt;</ph> method searches for rules with the same user or group as <ph id="ph2">`rule`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A&gt;</ph> Metody wyszukuje reguły z tego samego użytkownika lub grupy jako <ph id="ph2">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If none are found, <ph id="ph1">`rule`</ph> is added.</source>
          <target state="translated">Jeśli żaden nie zostaną znalezione, <ph id="ph1">`rule`</ph> został dodany.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If a matching rule is found, the flags in <ph id="ph1">`rule`</ph> are merged into the existing rule.</source>
          <target state="translated">Jeśli reguła dopasowywania zostanie znaleziony, flagi w <ph id="ph1">`rule`</ph> są scalane w istniejącą regułę.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Principal.IdentityReference" /&gt;</ph> that identifies the user or group the rule applies to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Principal.IdentityReference" /&gt;</ph> , Które identyfikują użytkownik lub grupa reguła dotyczy.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> values specifying the access rights to audit, cast to an integer.</source>
          <target state="translated">Bitowe połączenie <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreRights" /&gt;</ph> wartości określających prawa dostępu do inspekcji, rzutowania na liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>Meaningless for named wait handles, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>Meaningless for named wait handles, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>Meaningless for named wait handles, because they have no hierarchy.</source>
          <target state="translated">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditFlags" /&gt;</ph> values that specify whether to audit successful access, failed access, or both.</source>
          <target state="translated">Bitowe połączenie <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditFlags" /&gt;</ph> wartości, które określają, czy inspekcji pomyślnego dostępu i dostępu nie powiodło się.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>Creates a new audit rule, specifying the user the rule applies to, the access rights to audit, and the outcome that triggers the audit rule.</source>
          <target state="translated">Tworzy nową regułę inspekcji, określając użytkownika, którego dotyczy reguła, prawa dostępu do inspekcji i wyników, które wyzwala reguła inspekcji.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> object representing the specified audit rule for the specified user.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> obiekt reprezentujący reguła określonego inspekcji dla określonego użytkownika.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>The return type of the method is the base class, <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditRule" /&gt;</ph>, but the return value can be cast safely to the derived class.</source>
          <target state="translated">Klasa podstawowa jest zwracany typ metody <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditRule" /&gt;</ph>, ale wartość zwracaną mogą bezpiecznie rzutowane do klasy pochodnej.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>The recommended way to create audit rules is to use the constructors of the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> class.</source>
          <target state="translated">Zalecanym sposobem tworzenia zasady inspekcji jest użycie konstruktorów <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreAuditRule&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>Although inheritance and propagation flags are meaningless for named semaphores, it is still possible to specify them.</source>
          <target state="translated">Chociaż flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe je określić.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>This is not recommended, because it needlessly complicates the maintenance of rules, for example by interfering with the combination of rules that would otherwise be compatible.</source>
          <target state="translated">Nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguł, które w przeciwnym razie będą zgodne.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph>, <ph id="ph2">&lt;paramref name="inheritanceFlags" /&gt;</ph>, <ph id="ph3">&lt;paramref name="propagationFlags" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="flags" /&gt;</ph> specifies an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph>, <ph id="ph2">&lt;paramref name="inheritanceFlags" /&gt;</ph>, <ph id="ph3">&lt;paramref name="propagationFlags" /&gt;</ph>, lub <ph id="ph4">&lt;paramref name="flags" /&gt;</ph> określa nieprawidłową wartość.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="accessMask" /&gt;</ph> wynosi zero.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)">
          <source><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> is neither of type <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>, nor of a type such as <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> that can be converted to type <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="identityReference" /&gt;</ph> nie jest ani typu <ph id="ph2">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>, ani typu, takich jak <ph id="ph3">&lt;see cref="T:System.Security.Principal.NTAccount" /&gt;</ph> którego można przekonwertować na typ <ph id="ph4">&lt;see cref="T:System.Security.Principal.SecurityIdentifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType">
          <source>Gets the type that the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> class uses to represent audit rules.</source>
          <target state="translated">Pobiera typ, który <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> klasa używana do reprezentowania zasad inspekcji.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> class.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> reprezentujący obiekt <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> class override the <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A&gt;</ph> property and return the type they use to represent audit rights.</source>
          <target state="translated">Klasy, które pochodzą z <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity&gt;</ph> klasy zastąpienie <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A&gt;</ph> właściwości i zwracany typ przejdą do reprezentowania prawa inspekcji.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType">
          <source>When you work with arrays or collections that contain multiple types of security objects, use this property to determine the correct audit rule type to use with each security object.</source>
          <target state="translated">Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły poprawne inspekcji do użycia z każdego obiektu zabezpieczeń.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> that specifies the user and <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> użytkownik, który określa i <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> do wyszukiwania i zestaw dziedziczenia i propagacji flag, które pasujący do reguły, jeśli znaleziono, musi być zgodny z.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Specifies the rights to remove from the compatible rule, if found.</source>
          <target state="translated">Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Searches for an access control rule with the same user and <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (allow or deny) as the specified rule, and with compatible inheritance and propagation flags; if such a rule is found, the rights contained in the specified access rule are removed from it.</source>
          <target state="translated">Wyszukuje reguły kontroli dostępu z tego samego użytkownika i <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (zezwalania lub odmowy) jako określonej reguły oraz zgodne dziedziczenia i flagi propagacji; jeśli taka reguła zostanie znaleziony, prawa zawarte w tej regule określonego dostępu są usuwane z go.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a compatible rule is found; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> is searched for a rule that has the same user and the same <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> value as <ph id="ph3">`rule`</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> jest wyszukiwany regułę, która ma ten sam użytkownik i tym samym <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> wartość jako <ph id="ph3">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If no such rule is found, no action is taken, and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in <ph id="ph1">`rule`</ph>.</source>
          <target state="translated">W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we <ph id="ph1">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If no compatible rule is found, no action is taken, and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If a rule with compatible flags is found, the rights specified in <ph id="ph1">`rule`</ph> are removed from the compatible rule, and the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Jeśli znaleziono reguły z flagami zgodne, prawa określone w <ph id="ph1">`rule`</ph> są usuwane z niezgodne reguły, a metoda zwraca <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If <ph id="ph1">`rule`</ph> specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</source>
          <target state="translated">Jeśli <ph id="ph1">`rule`</ph> określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If all rights are removed from the compatible rule, the entire rule is removed from the current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Although you can specify inheritance and propagation flags for semaphore access rules, by creating them with the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A&gt;</ph> method, this is not recommended.</source>
          <target state="translated">Mimo że można określić flagi dziedziczenia i propagacji dla reguły dostępu do semafora, tworząc je za pomocą <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A&gt;</ph> metody, nie jest to zalecane.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Inheritance and propagation have no meaning for named semaphores, and they make the maintenance of access rules more complicated.</source>
          <target state="translated">Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów, a konserwacji reguł dostępu umożliwiają bardziej skomplikowane.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A&gt;</ph> method to remove rights from an <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule in a <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A&gt;</ph> metodę, aby usunąć prawa z <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły w <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>It also shows that other rights in <ph id="ph1">`rule`</ph> are ignored.</source>
          <target state="translated">Przedstawiono również że inne prawa w <ph id="ph1">`rule`</ph> są ignorowane.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object and adds rules that allow and deny various rights for the current user.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The rights allowed include <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph>, and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize&gt;</ph>.</source>
          <target state="translated">Prawa mogą zawierać <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph>, i <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then creates a new rule for the current user, including <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership&gt;</ph> rights, and uses that rule with the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A&gt;</ph> method to remove <ph id="ph4">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph> from the <ph id="ph5">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule in the <ph id="ph6">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Przykład utworzy nową regułę dla bieżącego użytkownika, w tym <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph> i <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership&gt;</ph> praw i korzysta z tej reguły z <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A&gt;</ph> metodę, aby usunąć <ph id="ph4">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions&gt;</ph> z <ph id="ph5">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły w <ph id="ph6">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The extraneous <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership&gt;</ph> right in <ph id="ph2">`rule`</ph> is ignored.</source>
          <target state="translated">Nadmiarowe <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership&gt;</ph> prawym przyciskiem myszy w <ph id="ph2">`rule`</ph> jest ignorowana.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> that specifies the user and <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> to search for.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> użytkownik, który określa i <ph id="ph2">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> do wyszukania.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Any rights specified by this rule are ignored.</source>
          <target state="translated">Wszelkie prawa określone przez tę regułę są ignorowane.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Searches for all access control rules with the same user and <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (allow or deny) as the specified rule and, if found, removes them.</source>
          <target state="translated">Wyszukuje wszystkie reguły kontroli z tego samego użytkownika dostępu i <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (zezwalania lub odmowy) jako określona reguła oraz, jeśli znaleziono usuwa je.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object is searched for rules that have the same user and the same <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> value as <ph id="ph3">`rule`</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> reguły, które mają ten sam użytkownik i tym samym przeszukiwany jest obiekt <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> wartość jako <ph id="ph3">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Any rights specified by <ph id="ph1">`rule`</ph> are ignored when performing this search.</source>
          <target state="translated">Wszelkie prawa określone przez <ph id="ph1">`rule`</ph> są ignorowane, podczas wykonywania tego wyszukiwania.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If no matching rules are found, no action is taken.</source>
          <target state="translated">Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example shows that the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A&gt;</ph> method removes all rules that match user and <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph>, ignoring rights.</source>
          <target state="translated">W poniższym przykładzie pokazano, że <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A&gt;</ph> metoda usuwa wszystkie reguły zgodnych użytkowników i <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph>, ignorowanie praw.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> , dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika, a następnie scala dodatkowych praw do <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule from the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Przykład utworzy nową regułę, która umożliwia użytkownikowi przejęcie na własność i używa tej reguły, aby usunąć <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły z <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> to remove.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> Do usunięcia.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Searches for an access control rule that exactly matches the specified rule and, if found, removes it.</source>
          <target state="translated">Wyszukuje reguły kontroli dostępu, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The rule is removed only if it exactly matches <ph id="ph1">`rule`</ph> in all details, including flags.</source>
          <target state="translated">Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada <ph id="ph1">`rule`</ph> wszystkie szczegóły, w tym flag.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Other rules with the same user and <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> are not affected.</source>
          <target state="translated">Inne zasady z tego samego użytkownika i <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> pozostają niezmienione.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the access security rules for a user.</source>
          <target state="translated">Reguła reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń dostępu dla użytkownika.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> method cannot remove it.</source>
          <target state="translated">W związku z tym reguły może już nie istnieje w określonej formy znajdował się, gdy ten element został dodany, w tym przypadku <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> metody nie można go usunąć.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example shows that the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.</source>
          <target state="translated">W poniższym przykładzie pokazano, że <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> metoda wymaga dokładnego dopasowania, aby można było usunąć regułę, a reguły zezwalania i odmowy uprawnień są od siebie niezależne.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> access rule.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> , dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika, a następnie scala dodatkowych praw do <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> regułę dostępu.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then passes the original <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule to the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> method, and displays the results, showing that nothing is deleted.</source>
          <target state="translated">Przykład następnie przekazuje oryginalnej <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> regułę dotyczącą <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> — metoda i wyświetla wyniki, wskazujące, że nic nie zostanie usunięta.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then constructs a rule that matches the <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rule in the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object, and successfully uses the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> method to remove the rule.</source>
          <target state="translated">Przykład następnie tworzy regułę, która odpowiada <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły w <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu i pomyślnie używa <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A&gt;</ph> metodę, aby usunąć regułę.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> that specifies the user to search for, and a set of inheritance and propagation flags that a matching rule, if found, must be compatible with.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> , który określa użytkownika, aby wyszukać i zestaw flagi dziedziczenia i propagacji, które pasujący reguły, jeśli znaleziono, musi być zgodny z.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Specifies the rights to remove from the compatible rule, if found.</source>
          <target state="translated">Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Searches for an audit control rule with the same user as the specified rule, and with compatible inheritance and propagation flags; if a compatible rule is found, the rights contained in the specified rule are removed from it.</source>
          <target state="translated">Wyszukuje reguły inspekcji z tego samego użytkownika określoną regułą oraz zgodne dziedziczenia i flagi propagacji; Jeśli znaleziono niezgodne reguły, prawa zawarte w określonej reguły są usuwane z niej.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a compatible rule is found; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> is searched for an audit rule that has the same user as <ph id="ph2">`rule`</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> jest wyszukiwany zasady inspekcji, który ma tego samego użytkownika <ph id="ph2">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If no such rule is found, no action is taken, and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If matching rules are found, their inheritance and compatibility flags are checked for compatibility with the flags specified in <ph id="ph1">`rule`</ph>.</source>
          <target state="translated">W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we <ph id="ph1">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If no compatible rule is found, no action is taken, and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If a rule with compatible flags is found, the rights specified in <ph id="ph1">`rule`</ph> are removed from the compatible rule, and the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Jeśli znaleziono reguły z flagami zgodne, prawa określone w <ph id="ph1">`rule`</ph> są usuwane z niezgodne reguły, a metoda zwraca <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If <ph id="ph1">`rule`</ph> specifies rights not contained in the compatible rule, no action is taken with respect to those rights.</source>
          <target state="translated">Jeśli <ph id="ph1">`rule`</ph> określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If all rights are removed from the compatible rule, the entire rule is removed from the current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object.</source>
          <target state="translated">Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Although you can specify inheritance and propagation flags for semaphore audit rules, by creating them with the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A&gt;</ph> method, this is not recommended.</source>
          <target state="translated">Mimo że można określić flagi dziedziczenia i propagacji semafora zasady inspekcji, tworząc je za pomocą <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A&gt;</ph> metody, nie jest to zalecane.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Inheritance and propagation have no meaning for named semaphores, and they make the maintenance of audit rules more complicated.</source>
          <target state="translated">Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów a konserwacji zasad inspekcji umożliwiają bardziej skomplikowane.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> that specifies the user to search for.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> , który określa użytkownika do wyszukania.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Any rights specified by this rule are ignored.</source>
          <target state="translated">Wszelkie prawa określone przez tę regułę są ignorowane.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Searches for all audit rules with the same user as the specified rule and, if found, removes them.</source>
          <target state="translated">Przeszukuje wszystkie inspekcji reguły z określoną regułą tego samego użytkownika i, jeśli znaleziono, usuwa je.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The current <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> is searched for audit rules that have the same user as <ph id="ph2">`rule`</ph>.</source>
          <target state="translated">Bieżący <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> jest wyszukiwany zasady inspekcji, które mają tego samego użytkownika <ph id="ph2">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Any rights specified by <ph id="ph1">`rule`</ph> are ignored when performing this search.</source>
          <target state="translated">Wszelkie prawa określone przez <ph id="ph1">`rule`</ph> są ignorowane, podczas wykonywania tego wyszukiwania.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>All matching rules are removed.</source>
          <target state="translated">Wszystkie reguły dopasowywania zostaną usunięte.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If no matching rules are found, no action is taken.</source>
          <target state="translated">Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> to remove.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> Do usunięcia.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Searches for an audit rule that exactly matches the specified rule and, if found, removes it.</source>
          <target state="translated">Wyszukuje zasady inspekcji, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The rule is removed only if it exactly matches <ph id="ph1">`rule`</ph> in all details, including flags.</source>
          <target state="translated">Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada <ph id="ph1">`rule`</ph> wszystkie szczegóły, w tym flag.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Other audit rules for the same user are not affected.</source>
          <target state="translated">Nie wpływa na inne zasady inspekcji dla tego użytkownika.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>A rule represents one or more underlying access control entries (ACE), and these entries are split or combined as necessary when you modify the audit security rules for a user.</source>
          <target state="translated">Reguła reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń inspekcji dla użytkownika.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Thus, a rule might no longer exist in the specific form it had when it was added, and in that case the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A&gt;</ph> method cannot remove it.</source>
          <target state="translated">W związku z tym reguły może już nie istnieje w określonej formy znajdował się, gdy ten element został dodany, w tym przypadku <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A&gt;</ph> metody nie można go usunąć.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> to add.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> Do dodania.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The user specified by this rule determines the rules to remove before this rule is added.</source>
          <target state="translated">Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Removes all access control rules with the same user as the specified rule, regardless of <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph>, and then adds the specified rule.</source>
          <target state="translated">Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika określoną regułą, niezależnie od tego <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph>, a następnie dodaje określoną regułą.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If there are no access rules whose user matches the specified rule, <ph id="ph1">`rule`</ph> is added.</source>
          <target state="translated">Jeśli brak reguł dostępu do których użytkownik odpowiada określonej reguły <ph id="ph1">`rule`</ph> został dodany.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A&gt;</ph> method replaces all rules for the matching user with the rule specified for the match.</source>
          <target state="translated">Poniższy kod przedstawia przykład sposobu <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A&gt;</ph> metoda zastępuje wszystkie reguły dla zgodnego użytkownika podana reguła dopasowania.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object and adds rules that allow and deny various rights for the current user.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then creates a new rule that allows the current user full control, and uses the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A&gt;</ph> method to replace both of the existing rules with the new rule.</source>
          <target state="translated">Przykład utworzy nową regułę, która pozwala bieżąca Pełna kontrola użytkownika i używa <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A&gt;</ph> metodę, aby zastąpić zarówno istniejących reguł nowej reguły.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> to add.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /&gt;</ph> Do dodania.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The user and <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> of this rule determine the rules to remove before this rule is added.</source>
          <target state="translated">Użytkownik i <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> tej zasady określają zasady można usunąć przed dodaniem tej reguły.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Removes all access control rules with the same user and <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (allow or deny) as the specified rule, and then adds the specified rule.</source>
          <target state="translated">Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika i <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlType" /&gt;</ph> (zezwalania lub odmowy) jako określonej reguły, a następnie dodaje określoną regułą.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If the specified rule has <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph>, the effect of this method is to remove all <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> rules for the specified user, replacing them with the specified rule.</source>
          <target state="translated">Jeśli dla określonej reguły <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph>, ta metoda powoduje usunięcie wszystkich <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Allow&gt;</ph> reguły dla określonego użytkownika, zastępując je z określoną regułą.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If the specified rule has <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph>, all <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> rules for the specified user are replaced with the specified rule.</source>
          <target state="translated">Jeśli dla określonej reguły <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph>, wszystkie <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType.Deny&gt;</ph> zastępuje reguły dla określonego użytkownika z określoną regułą.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>If there are no rules whose user and <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> match the specified rule, <ph id="ph2">`rule`</ph> is added.</source>
          <target state="translated">Jeśli brak reguł której użytkownika i <ph id="ph1">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> zgodne z określoną regułą <ph id="ph2">`rule`</ph> został dodany.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A&gt;</ph> method removes all rules that match both the user and the <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> of <ph id="ph3">`rule`</ph>, replacing them with <ph id="ph4">`rule`</ph>.</source>
          <target state="translated">Poniższy kod przedstawia przykład sposobu <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A&gt;</ph> metoda usuwa wszystkie reguły, które odpowiadają zarówno wobec użytkownika i <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlType&gt;</ph> z <ph id="ph3">`rule`</ph>, zastępując je za pomocą <ph id="ph4">`rule`</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object and adds rules that allow and deny various rights for the current user.</source>
          <target state="translated">W przykładzie jest tworzony <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The example then creates a new rule that allows the current user full control, and uses the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A&gt;</ph> method to replace the existing Allow rule with the new rule.</source>
          <target state="translated">Przykład utworzy nową regułę, która pozwala bieżąca Pełna kontrola użytkownika i używa <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A&gt;</ph> metodę, aby zastąpić istniejącą regułę z nową regułę Zezwalaj.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>The rule that denies access is not affected.</source>
          <target state="translated">Nie dotyczy reguła, która nie zezwala na dostęp.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>This example does not attach the security object to a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">W tym przykładzie nie dołączy do obiektu zabezpieczeń <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source>Examples that attach security objects can be found in <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> to add.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /&gt;</ph> Do dodania.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>The user specified by this rule determines the rules to remove before this rule is added.</source>
          <target state="translated">Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>Removes all audit rules with the same user as the specified rule, regardless of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditFlags" /&gt;</ph> value, and then adds the specified rule.</source>
          <target state="translated">Usuwa wszystkie reguły z tego samego użytkownika określoną regułą inspekcji, niezależnie od tego <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AuditFlags" /&gt;</ph> wartość, a następnie dodaje określoną regułą.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source>If there are no audit rules whose user matches the specified rule, <ph id="ph1">`rule`</ph> is added.</source>
          <target state="translated">Jeśli brak reguł inspekcji, w których użytkownik odpowiada określonej reguły <ph id="ph1">`rule`</ph> został dodany.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)">
          <source><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rule" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
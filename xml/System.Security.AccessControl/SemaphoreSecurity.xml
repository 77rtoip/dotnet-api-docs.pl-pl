<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dbaaedf80ead2c907ed593520cd66b949ee55078" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69085875" /></Metadata><TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje zabezpieczenia kontroli dostępu do systemu Windows dla nazwanego semafora. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.SemaphoreSecurity> Obiekt określa prawa dostępu dla nazwanego semafora systemowego, a także określa sposób inspekcji prób dostępu. Prawa dostępu do semafora są wyrażane jako reguły, z każdą regułą dostępu reprezentowaną przez <xref:System.Security.AccessControl.SemaphoreAccessRule> obiekt. Każda reguła inspekcji jest reprezentowana przez <xref:System.Security.AccessControl.SemaphoreAuditRule> obiekt.  
  
 Odzwierciedla to podstawowy system zabezpieczeń systemu Windows, w którym każdy zabezpieczany obiekt ma co najwyżej jedną poufną listę kontroli dostępu (DACL), która kontroluje dostęp do bezpiecznego obiektu i co najwyżej jedną systemową listę kontroli dostępu (SACL), która określa dostęp próby są poddawane inspekcji. Lista DACL i SACL uporządkowane listy wpisów kontroli dostępu (ACE), które określają dostęp i inspekcję dla użytkowników i grup. Obiekt <xref:System.Security.AccessControl.SemaphoreAccessRule> lub<xref:System.Security.AccessControl.SemaphoreAuditRule> może reprezentować więcej niż jeden wpis ACE.  
  
> [!NOTE]
>  <xref:System.Threading.Semaphore> Obiekt może reprezentować semafor lokalny lub nazwany semafor systemowy. Zabezpieczenia kontroli dostępu systemu Windows są zrozumiałe tylko dla nazwanych semaforów systemu.  
  
 Klasy <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule> i<xref:System.Security.AccessControl.SemaphoreAuditRule> ukrywają szczegóły implementacji list ACL i ACE. Umożliwiają one ignorowanie różnych typów ACE siedemnastu i złożoność prawidłowego zachowania dziedziczenia i propagacji praw dostępu. Te obiekty zostały również zaprojektowane tak, aby uniemożliwić następujące typowe błędy kontroli dostępu:  
  
-   Tworzenie deskryptora zabezpieczeń z LISTą DACL o wartości null. Odwołanie o wartości null do listy DACL pozwala każdemu użytkownikowi dodawać reguły dostępu do obiektu, co może spowodować atak typu "odmowa usługi". Nowy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt zawsze zaczyna się od pustej listy DACL, co spowoduje odmowę dostępu dla wszystkich użytkowników.  
  
-   Naruszanie porządku kanonicznego kontroli dostępu. Jeśli lista ACE w DACL nie jest zachowana w kolejności kanonicznej, użytkownicy mogą przypadkowo uzyskać dostęp do bezpiecznego obiektu. Na przykład odmowa uprawnień dostępu musi być zawsze wyświetlana przed dozwolonymi prawami dostępu. <xref:System.Security.AccessControl.SemaphoreSecurity>obiekty zachowują prawidłową kolejność wewnętrznie.  
  
-   Manipulowanie flagami deskryptora zabezpieczeń, które powinny znajdować się tylko w obszarze kontroli Menedżera zasobów.  
  
-   Tworzenie nieprawidłowych kombinacji flag ACE.  
  
-   Manipulowanie dziedziczonymi ACE. Dziedziczenie i Propagacja są obsługiwane przez Menedżera zasobów w odpowiedzi na zmiany wprowadzone w zasadach dostępu i inspekcji.  
  
-   Wstawianie bezużytecznego dostępu do list kontroli dostępu.  
  
 Jedynymi możliwościami, które nie są obsługiwane przez obiekty zabezpieczeń .NET, są niebezpieczne działania, które należy unikać większości deweloperów aplikacji, takich jak następujące:  
  
-   Zadania niskiego poziomu, które są zwykle wykonywane przez Menedżera zasobów.  
  
-   Dodawanie lub usuwanie wpisów kontroli dostępu w sposób, który nie zachowuje porządku kanonicznego.  
  
 Aby zmodyfikować zabezpieczenia kontroli dostępu do systemu Windows dla nazwanego semafora <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> , użyj metody w <xref:System.Security.AccessControl.SemaphoreSecurity> celu pobrania obiektu. Zmodyfikuj obiekt zabezpieczeń, dodając i usuwając reguły, a następnie używając <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metody, aby ponownie dołączyć.  
  
> [!IMPORTANT]
>  Zmiany wprowadzane do <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu nie wpływają na poziomy dostępu nazwanego semafora do momentu <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> wywołania metody przypisania zmieniony obiekt zabezpieczeń do nazwanego semafora.  
  
 Aby skopiować zabezpieczenia kontroli dostępu z jednego semafora do drugiego, użyj <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> metody w celu <xref:System.Security.AccessControl.SemaphoreSecurity> uzyskania obiektu reprezentującego reguły dostępu i inspekcji dla pierwszego <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> semafora, a następnie użyj metody lub konstruktora, który akceptuje <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, aby przypisać te reguły do drugiego semafora.  
  
 Użytkownicy z inwestycją w język definicji deskryptora zabezpieczeń (SDDL) mogą używać <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metody do ustawiania reguł dostępu dla nazwanego semafora <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> i metody uzyskiwania ciągu, który reprezentuje reguły dostępu w formacie SDDL. Nie jest to zalecane w przypadku nowych rozwiązań programistycznych.  
  
> [!NOTE]
>  Zabezpieczenia dotyczące obiektów synchronizacji nie są obsługiwane w systemie Windows 98 lub Windows Millennium Edition.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje rozdzielenie <xref:System.Security.AccessControl.AccessControlType.Allow> reguł i <xref:System.Security.AccessControl.AccessControlType.Deny> reguł i pokazuje kombinację praw w zgodnych regułach. Przykład tworzy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, dodaje reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, a następnie wyświetla uzyskaną parę reguł. W tym przykładzie można następnie uzyskać nowe prawa dla bieżącego użytkownika i wyświetlić wynik, wskazując, że nowe prawa są scalone z istniejącą <xref:System.Security.AccessControl.AccessControlType.Allow> regułą.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasy z wartościami domyślnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt zawsze zaczyna się od pustej listy arbitralnego dostępu (DACL), która odrzuca cały dostęp dla wszystkich użytkowników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego, którego reguły zabezpieczeń kontroli dostępu mają być pobierane.</param>
        <param name="includeSections">Kombinacja <see cref="T:System.Security.AccessControl.AccessControlSections" /> flag określających sekcje do pobrania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasy z określonymi sekcjami reguł zabezpieczeń kontroli dostępu z semafora systemowego o określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor pozwala uzyskać zabezpieczenia kontroli dostępu dla nazwanego semafora systemowego bez wcześniejszego utworzenia <xref:System.Threading.Semaphore> obiektu.  
  
 Należy zachować ostrożność podczas pracy z nazwanymi obiektami systemowymi. Jeśli istnieje obiekt systemowy o nazwie `name` , który nie jest semaforem, jego zabezpieczenia dostępu do kontroli mogą zostać pobrane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Wyliczenie używane przez <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasę do reprezentowania praw dostępu.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący Wyliczenie. <see cref="T:System.Security.AccessControl.SemaphoreRights" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> przesłaniają Właściwość i zwracają typ, którego używają do reprezentowania praw dostępu. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ wyliczenia do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> Identyfikujący użytkownika lub grupę, do której odnosi się reguła.</param>
        <param name="accessMask">Bitowa kombinacja <see cref="T:System.Security.AccessControl.SemaphoreRights" /> wartości określająca prawa dostępu do zezwalania lub odmowy, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Bez znaczenia dla nazwanych semaforów, ponieważ nie mają hierarchii.</param>
        <param name="inheritanceFlags">Bez znaczenia dla nazwanych semaforów, ponieważ nie mają hierarchii.</param>
        <param name="propagationFlags">Bez znaczenia dla nazwanych semaforów, ponieważ nie mają hierarchii.</param>
        <param name="type">Jedna z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartości określająca, czy prawa są dozwolone czy odrzucane.</param>
        <summary>Tworzy nową regułę kontroli dostępu dla określonego użytkownika, z określonymi prawami dostępu, kontrolą dostępu i flagami.</summary>
        <returns><see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Obiekt reprezentujący określone prawa dla określonego użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia reguł kontroli dostępu jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAccessRule> klasy.  
  
> [!NOTE]
>  Chociaż flagi dziedziczenia i propagacji są bezwzględne dla nazwanych semaforów, nadal można je określić, nie jest to zalecane, ponieważ niepotrzebnie komplikuje konserwację reguł, na przykład przez zakłócanie kombinacji reguł w przeciwnym razie byłyby zgodne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> lub<paramref name="type" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="accessMask" />ma wartość zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" />nie jest typem <see cref="T:System.Security.Principal.SecurityIdentifier" />ani typu, takiego jak <see cref="T:System.Security.Principal.NTAccount" /> , który można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, którego <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> Klasa używa do reprezentowania reguł dostępu.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący klasę. <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> przesłaniają Właściwość i zwracają typ używany do reprezentowania reguł dostępu. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ reguły dostępu do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła kontroli dostępu do dodania.</param>
        <summary>Wyszukuje pasującą regułę, z którą można scalić nową regułę. Jeśli nie zostanie znaleziona, program doda nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje reguły z tym samym użytkownikiem lub grupą, tak samo <xref:System.Security.AccessControl.AccessControlType> jak `rule`. <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> Jeśli żaden nie zostanie znaleziony `rule` , jest dodawany. Jeśli zostanie znaleziona zgodna reguła, prawa w programie `rule` są scalane z istniejącą regułą.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje rozdzielenie <xref:System.Security.AccessControl.AccessControlType.Allow> reguł i <xref:System.Security.AccessControl.AccessControlType.Deny> reguł i pokazuje kombinację praw w zgodnych regułach. Przykład tworzy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, dodaje reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, a następnie wyświetla uzyskaną parę reguł. W tym przykładzie można następnie uzyskać nowe prawa dla bieżącego użytkownika i wyświetlić wynik, wskazując, że nowe prawa są scalone z istniejącą <xref:System.Security.AccessControl.AccessControlType.Allow> regułą.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła inspekcji do dodania. Użytkownik określony przez tę regułę określa wyszukiwanie.</param>
        <summary>Wyszukuje regułę inspekcji, z którą można scalić nową regułę. Jeśli nie zostanie znaleziona, program doda nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje reguły z tym samym użytkownikiem lub grupą, `rule`co. <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> Jeśli żaden nie zostanie znaleziony `rule` , jest dodawany. W przypadku znalezienia pasującej reguły flagi w programie `rule` są scalane z istniejącą regułą.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> Identyfikujący użytkownika lub grupę, do której odnosi się reguła.</param>
        <param name="accessMask">Bitowa kombinacja <see cref="T:System.Security.AccessControl.SemaphoreRights" /> wartości określająca prawa dostępu do inspekcji, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Bez względu na nazwane uchwyty oczekiwania, ponieważ nie mają hierarchii.</param>
        <param name="inheritanceFlags">Bez względu na nazwane uchwyty oczekiwania, ponieważ nie mają hierarchii.</param>
        <param name="propagationFlags">Bez względu na nazwane uchwyty oczekiwania, ponieważ nie mają hierarchii.</param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.AuditFlags" /> wartości, które określają, czy ma być przeprowadzana inspekcja pomyślnego dostępu, Niepowodzenie dostępu czy obu.</param>
        <summary>Tworzy nową regułę inspekcji określającą użytkownika, do którego odnosi się reguła, prawa dostępu do inspekcji oraz wynik wyzwalający regułę inspekcji.</summary>
        <returns><see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Obiekt reprezentujący określoną regułę inspekcji dla określonego użytkownika. Zwracany typ metody jest klasą <see cref="T:System.Security.AccessControl.AuditRule" />bazową, ale zwracana wartość może być bezpiecznie rzutowana na klasę pochodną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia reguł inspekcji jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAuditRule> klasy.  
  
> [!NOTE]
>  Chociaż flagi dziedziczenia i propagacji są bezużyteczne dla nazwanych semaforów, nadal można je określić. Nie jest to zalecane, ponieważ niepotrzebnie komplikuje konserwację reguł, na przykład przez zakłócanie kombinacji reguł, które w przeciwnym razie byłyby zgodne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> lub<paramref name="flags" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="accessMask" />ma wartość zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" />nie jest typem <see cref="T:System.Security.Principal.SecurityIdentifier" />ani typu, takiego jak <see cref="T:System.Security.Principal.NTAccount" /> , który można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, którego <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> Klasa używa do reprezentowania reguł inspekcji.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący klasę. <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> przesłaniają Właściwość i zwracają typ używany do reprezentowania praw inspekcji. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ reguły inspekcji do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> , który określa użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> wyszukiwanie, oraz zestaw flag dziedziczenia i propagacji, które są zgodne z regułą, jeśli znaleziono, musi być zgodny z. Określa prawa do usunięcia z zgodnej reguły, jeśli zostanie znaleziona.</param>
        <summary>Wyszukuje regułę kontroli dostępu z tym samym użytkownikiem i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jako określoną regułę oraz z zgodnymi flagami dziedziczenia i propagacji. Jeśli taka reguła zostanie znaleziona, prawa zawarte w określonej regule dostępu są usuwane z niej.</summary>
        <returns><see langword="true" />Jeśli zostanie znaleziona zgodna reguła; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> jest wyszukiwany dla reguły, która ma tego samego użytkownika i taką <xref:System.Security.AccessControl.AccessControlType> samą wartość `rule`jak. Jeśli nie zostanie znaleziona taka reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostaną znalezione pasujące reguły, ich dziedziczenie i flagi zgodności są sprawdzane pod kątem zgodności z `rule`flagami określonymi w. Jeśli nie zostanie znaleziona zgodna reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostanie znaleziona reguła z zgodnymi flagami, prawa określone `rule` w programie są usuwane z zgodnej reguły i zwraca `true`metodę. Jeśli `rule` określa prawa, które nie są zawarte w zgodnej regule, nie jest podejmowana żadna akcja w odniesieniu do tych praw. Jeśli wszystkie prawa zostaną usunięte z reguły zgodności, cała reguła zostanie usunięta z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu.  
  
> [!IMPORTANT]
>  Chociaż można określić flagi dziedziczenia i propagacji dla reguł dostępu semaforów, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> metody, nie jest to zalecane. Dziedziczenie i Propagacja nie mają znaczenia dla nazwanych semaforów i sprawiają, że konserwacja reguł dostępu jest bardziej skomplikowana.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> metody usuwania praw <xref:System.Security.AccessControl.AccessControlType.Allow> z reguły w <xref:System.Security.AccessControl.SemaphoreSecurity> obiekcie. Pokazuje również, że inne prawa w `rule` programie są ignorowane.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt i dodawane są reguły zezwalające na różne prawa dla bieżącego użytkownika. Dozwolone prawa obejmują <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, i <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. W przykładzie zostanie utworzona Nowa reguła dla bieżącego użytkownika, w tym <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> i <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> prawa, a także reguła zostanie <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> użyta z <xref:System.Security.AccessControl.SemaphoreSecurity> metodą usuwania <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> z <xref:System.Security.AccessControl.AccessControlType.Allow> reguły w obiekcie. Obce <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> prawo w programie `rule` jest ignorowane.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> , który określa użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> wyszukiwanie. Wszystkie prawa określone przez tę regułę zostaną zignorowane.</param>
        <summary>Wyszukuje wszystkie reguły kontroli dostępu dla tego samego użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jak określona reguła i, jeśli została znaleziona, usunie je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt jest wyszukiwany dla reguł, które mają tego samego użytkownika i <xref:System.Security.AccessControl.AccessControlType> taką samą `rule`wartość jak. Wszystkie prawa określone przez `rule` są ignorowane podczas wykonywania tego wyszukiwania. Jeśli nie zostaną znalezione pasujące reguły, nie zostanie podjęta żadna akcja.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> Metoda usuwa wszystkie reguły, które pasują do użytkownika, i <xref:System.Security.AccessControl.AccessControlType>ignorując prawa.  
  
 Przykład tworzy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, dodaje reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, a następnie scala dodatkowe prawa <xref:System.Security.AccessControl.AccessControlType.Allow> do reguły. W przykładzie zostanie utworzona Nowa reguła umożliwiająca bieżącemu użytkownikowi przejęcie na własność i użycie tej reguły w celu usunięcia <xref:System.Security.AccessControl.AccessControlType.Allow> reguły <xref:System.Security.AccessControl.SemaphoreSecurity> z obiektu.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do usunięcia.</param>
        <summary>Wyszukuje regułę kontroli dostępu, która dokładnie pasuje do określonej reguły i, jeśli zostanie znaleziona, usunie ją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła jest usuwana tylko wtedy, gdy dokładnie `rule` pasuje do wszystkich szczegółów, w tym flag. Inne reguły z tym samym użytkownikiem i <xref:System.Security.AccessControl.AccessControlType> nie wpływają na nie.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej z podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielone lub łączone w miarę potrzeb podczas modyfikowania reguł zabezpieczeń dostępu dla użytkownika. W ten sposób reguła może już nie istnieć w konkretnym formularzu, gdy została dodana, a w takim przypadku <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> Metoda nie może go usunąć.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metoda wymaga dokładnego dopasowania, aby usunąć regułę, i że reguły zezwalające na prawa i Odmów są niezależne od siebie.  
  
 Przykład tworzy <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt, dodaje reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, a następnie scala dodatkowe prawa <xref:System.Security.AccessControl.AccessControlType.Allow> do reguły dostępu. W przykładzie zostanie przekazana pierwotna <xref:System.Security.AccessControl.AccessControlType.Allow> reguła <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> do metody i zostaną wyświetlone wyniki, co oznacza, że nic nie zostanie usunięte. Przykład następnie konstruuje regułę zgodną <xref:System.Security.AccessControl.AccessControlType.Allow> z regułą <xref:System.Security.AccessControl.SemaphoreSecurity> w obiekcie i pomyślnie używa <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metody do usunięcia reguły.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> który określa użytkownika do wyszukania, a zestaw flag dziedziczenia i propagacji, które jest zgodna z regułą, jeśli znaleziono, musi być zgodny z. Określa prawa do usunięcia z zgodnej reguły, jeśli zostanie znaleziona.</param>
        <summary>Wyszukuje regułę kontroli inspekcji z tym samym użytkownikiem co określona reguła i ze zgodnymi flagami dziedziczenia i propagacji; Jeśli zostanie znaleziona zgodna reguła, prawa zawarte w określonej regule zostaną z niej usunięte.</summary>
        <returns><see langword="true" />Jeśli zostanie znaleziona zgodna reguła; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca <xref:System.Security.AccessControl.SemaphoreSecurity> jest przeszukiwana reguła inspekcji, która ma tego samego użytkownika co `rule`. Jeśli nie zostanie znaleziona taka reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostaną znalezione pasujące reguły, ich dziedziczenie i flagi zgodności są sprawdzane pod kątem zgodności z `rule`flagami określonymi w. Jeśli nie zostanie znaleziona zgodna reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostanie znaleziona reguła z zgodnymi flagami, prawa określone `rule` w programie są usuwane z zgodnej reguły i zwraca `true`metodę. Jeśli `rule` określa prawa, które nie są zawarte w zgodnej regule, nie jest podejmowana żadna akcja w odniesieniu do tych praw. Jeśli wszystkie prawa zostaną usunięte z reguły zgodności, cała reguła zostanie usunięta z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu.  
  
> [!IMPORTANT]
>  Chociaż można określić flagi dziedziczenia i propagacji dla reguł inspekcji semaforów, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> metody, nie jest to zalecane. Dziedziczenie i Propagacja nie mają znaczenia dla nazwanych semaforów i sprawiają, że konserwacja reguł inspekcji jest bardziej skomplikowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> , który określa użytkownika do wyszukania. Wszystkie prawa określone przez tę regułę zostaną zignorowane.</param>
        <summary>Wyszukuje wszystkie reguły inspekcji z tym samym użytkownikiem co określona reguła i, jeśli zostanie znaleziona, usunie je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> jest przeszukiwany dla reguł inspekcji, które mają tego samego `rule`użytkownika co. Wszystkie prawa określone przez `rule` są ignorowane podczas wykonywania tego wyszukiwania. Wszystkie zgodne reguły są usuwane. Jeśli nie zostaną znalezione pasujące reguły, nie zostanie podjęta żadna akcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Do usunięcia.</param>
        <summary>Wyszukuje regułę inspekcji dokładnie zgodną z określoną regułą i, jeśli zostanie znaleziona, usunie ją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła jest usuwana tylko wtedy, gdy dokładnie `rule` pasuje do wszystkich szczegółów, w tym flag. Nie dotyczy to innych reguł inspekcji dla tego samego użytkownika.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej z podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielone lub łączone w miarę potrzeb podczas modyfikowania reguł zabezpieczeń inspekcji dla użytkownika. W ten sposób reguła może już nie istnieć w konkretnym formularzu, gdy została dodana, a w takim przypadku <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> Metoda nie może go usunąć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły kontroli dostępu z tym samym użytkownikiem co określona reguła, niezależnie od <see cref="T:System.Security.AccessControl.AccessControlType" />, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych reguł dostępu, których użytkownik jest zgodny z określoną `rule` regułą, zostanie dodany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metoda zastępuje wszystkie reguły dla pasującego użytkownika regułą określoną dla dopasowania.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt i dodawane są reguły zezwalające na różne prawa dla bieżącego użytkownika. Przykład tworzy nową regułę, która zezwala bieżącemu użytkownikowi na pełną kontrolę, i używa <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metody do zastąpienia obu istniejących reguł nową regułą.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do dodania. Użytkownik i <see cref="T:System.Security.AccessControl.AccessControlType" /> ta reguła określają reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły kontroli dostępu z tym samym użytkownikiem i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jak określona reguła, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określona reguła ma <xref:System.Security.AccessControl.AccessControlType.Allow>, efekt tej metody polega na usunięciu wszystkich <xref:System.Security.AccessControl.AccessControlType.Allow> reguł dla określonego użytkownika, zastępując je określoną regułą. Jeśli określona reguła ma <xref:System.Security.AccessControl.AccessControlType.Deny>wartość, wszystkie <xref:System.Security.AccessControl.AccessControlType.Deny> reguły dla określonego użytkownika zostaną zastąpione określoną regułą.  
  
 Jeśli nie ma żadnych reguł, <xref:System.Security.AccessControl.AccessControlType> `rule` których użytkownik i zgodne z określoną regułą zostanie dodany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> Metoda usuwa wszystkie reguły, które pasują zarówno do użytkownika, jak `rule` <xref:System.Security.AccessControl.AccessControlType> i `rule`z, zastępując je.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt i dodawane są reguły zezwalające na różne prawa dla bieżącego użytkownika. Przykład tworzy nową regułę, która zezwala bieżącemu użytkownikowi na pełną kontrolę, i używa <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> metody, aby zastąpić istniejącą regułę zezwalania nową regułą. Nie dotyczy reguły, która odmówi dostępu.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:System.Threading.Semaphore> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły inspekcji z tym samym użytkownikiem co określona reguła, niezależnie od <see cref="T:System.Security.AccessControl.AuditFlags" /> wartości, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych reguł inspekcji, których użytkownik jest zgodny z określoną `rule` regułą, jest dodawany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

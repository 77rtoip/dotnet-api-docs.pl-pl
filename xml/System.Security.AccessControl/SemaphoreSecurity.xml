<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02041a0b04c0b45af0a829d8bd9904736588668d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36532346" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemaphoreSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type SemaphoreSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kontrolę dostępu systemu Windows o nazwie semafora. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu określa prawa dostępu do semafora nazwanego systemu oraz określa, jak są poddawane inspekcji prób dostępu. Prawa dostępu do semafora są wyrażane jako reguł, z dostępu reprezentowany przez <xref:System.Security.AccessControl.SemaphoreAccessRule> obiektu. Każda reguła inspekcji jest reprezentowana przez <xref:System.Security.AccessControl.SemaphoreAuditRule> obiektu.  
  
 Odzwierciedla to podstawowy system zabezpieczeń systemu Windows, w którym każdy zabezpieczanego obiektu ma co najwyżej jeden poufnej listy kontroli dostępu (DACL), że kontroluje dostęp do bezpiecznego obiektu i co najwyżej jeden system listy kontroli dostępu (SACL) określająca, do których dostęp prób są poddawane inspekcji. Listy DACL i SACL są uporządkowane listy wpisów kontroli dostępu (ACE), które określają dostępu i inspekcji dla użytkowników i grup. A <xref:System.Security.AccessControl.SemaphoreAccessRule> lub <xref:System.Security.AccessControl.SemaphoreAuditRule> object może reprezentować więcej niż jednego wpisu kontroli dostępu.  
  
> [!NOTE]
>  A <xref:System.Threading.Semaphore> obiektu może reprezentować semafora lokalnego lub semafora systemu o nazwie. Kontrolę dostępu systemu Windows jest znaczący tylko w przypadku systemu o nazwie semaforów.  
  
 <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, I <xref:System.Security.AccessControl.SemaphoreAuditRule> klasy Ukryj szczegóły implementacji wpisów ACE i listy kontroli dostępu. Umożliwiają one Ignoruj siedemnaście różne typy ACE i złożoność poprawnie obsługi dziedziczenia i propagacji praw dostępu. Te obiekty są również zaprojektowana tak, aby zapobiec następujące typowe błędy kontroli dostępu:  
  
-   Tworzenie deskryptora zabezpieczeń z listy DACL wartości null. Odwołanie o wartości null do listy DACL umożliwia dowolnym użytkownikom dodawanie reguły dostępu do obiektu, potencjalnie tworzenie ataku typu "odmowa usługi". Nowy <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu zawsze rozpoczyna się od pusty listy DACL, która nie zezwala na dostęp dla wszystkich użytkowników.  
  
-   Naruszenie canonical kolejność ACE. Lista ACE w listy DACL nie jest przechowywany w Porządek kanoniczny, użytkownicy mogą przypadkowo uzyskać dostęp do zabezpieczonego obiektu. Na przykład prawa dostępu odmowy zawsze musi występować przed dozwolone uprawnienia. <xref:System.Security.AccessControl.SemaphoreSecurity> obiekty wewnętrznie Obsługa właściwej kolejności.  
  
-   Manipulowanie flagi deskryptora zabezpieczeń, które powinny być pod kontrolą Menedżera zasobów tylko.  
  
-   Tworzenie nieprawidłową kombinację flag ACE.  
  
-   Manipulowanie ACE dziedziczone. Dziedziczenie i propagacji są obsługiwane przez Menedżera zasobów w odpowiedzi na zmiany wprowadzone do reguł dostępu i inspekcji.  
  
-   Wstawianie znaczenia wpisy kontroli dostępu do listy kontroli dostępu.  
  
 Tylko funkcje nie są obsługiwane przez obiekty zabezpieczeń .NET są niebezpieczne działania, które należy unikać przez większość deweloperów aplikacji, takie jak następujące:  
  
-   Zadania niskiego poziomu, które są wykonywane zwykle przez Menedżera zasobów.  
  
-   Dodawanie lub usuwanie wpisów kontroli dostępu w sposób, w którym nie obsługują canonical porządkowania.  
  
 Aby zmodyfikować Windows kontrolę dostępu dla nazwanego semafora, użyj <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu. Zmodyfikuj obiekt zabezpieczeń przez dodawanie i usuwanie reguł, a następnie użyć <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metodę, aby dołączyć go ponownie.  
  
> [!IMPORTANT]
>  Zmiany wprowadzane do <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu nie wpływają na poziomów dostępu o nazwie semafora czasu wywołania <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metodę przypisania do semafora nazwanego obiektu zmieniony zabezpieczeń.  
  
 Aby skopiować kontrolę dostępu z jednego semafora do innego, należy użyć <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Security.AccessControl.SemaphoreSecurity> obiekt reprezentujący reguł dostępu i inspekcji dla pierwszego semafora, a następnie użyj <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> metody lub konstruktora akceptującego <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu można przypisać te reguły do semafora drugiego.  
  
 Użytkownicy z inwestycji w definicji deskryptora zabezpieczeń w języku (SDDL) można używać <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby ustawić zasady dostępu o nazwie semafora i <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metodę, aby uzyskać ciąg reprezentujący format SDDL reguły dostępu. Nie jest to zalecane w przypadku nowych wdrożeń.  
  
> [!NOTE]
>  Zabezpieczenia obiektów synchronizacji nie jest obsługiwane dla systemu Windows 98 lub Windows Millennium Edition.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje oddzielenie <xref:System.Security.AccessControl.AccessControlType.Allow> reguł i <xref:System.Security.AccessControl.AccessControlType.Deny> reguł i zawiera kombinację praw w niezgodne reguły. W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu, dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika i wyświetla wynikowy pary reguł. W przykładzie następnie umożliwia nowe prawa dla bieżącego użytkownika oraz wyświetla wynik, pokazujący, że nowe uprawnienia zostaną scalone z istniejącym <xref:System.Security.AccessControl.AccessControlType.Allow> reguły.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.SemaphoreAccessRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreAuditRule" />
    <altmember cref="T:System.Security.AccessControl.SemaphoreRights" />
    <altmember cref="M:System.Threading.Semaphore.GetAccessControl" />
    <altmember cref="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> z domyślnymi wartościami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowy <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu zawsze rozpoczyna się od listy pusty dostępu (DACL), która nie zezwala na dostęp dla wszystkich użytkowników.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.SemaphoreSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="new System.Security.AccessControl.SemaphoreSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa semafora systemowego, której reguły zabezpieczeń kontroli dostępu mają zostać pobrane.</param>
        <param name="includeSections">Kombinację <see cref="T:System.Security.AccessControl.AccessControlSections" /> flagi określające sekcje do pobrania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasy z określonej sekcji zasady zabezpieczeń kontroli dostępu z semafora systemowego o określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor umożliwia uzyskiwanie kontrolę dostępu do semafora systemu o nazwie bez tworzenia <xref:System.Threading.Semaphore> obiektu.  
  
 Uwaga muszą być wykonywane podczas pracy z obiektami systemu o nazwie. Jeśli jest obiektem systemu o nazwie `name` nie jest semafora, kontroli dostępu zabezpieczeń może pobrać.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyliczenie, który <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasa używana do reprezentowania praw dostępu.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Security.AccessControl.SemaphoreRights" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity> klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> właściwości i zwracany typ przejdą do reprezentowania praw dostępu. Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu wyliczenia poprawne korzystać z każdego obiektu zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="abstract member AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule&#xA;override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="semaphoreSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> , Które identyfikują użytkownik lub grupa reguła dotyczy.</param>
        <param name="accessMask">Bitowe połączenie <see cref="T:System.Security.AccessControl.SemaphoreRights" /> wartości określających prawa dostępu do dozwolonych lub zablokowanych, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="inheritanceFlags">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="propagationFlags">Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="type">Jeden z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartości określający, czy prawa zezwolono na dostęp lub odmowa dostępu.</param>
        <summary>Tworzy nową regułę kontroli dostępu dla określonego użytkownika z określonego uprawnienia kontroli dostępu i flagi.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> obiekt reprezentujący określonego uprawnienia dla określonego użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia zasad kontroli dostępu jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAccessRule> klasy.  
  
> [!NOTE]
>  Mimo że flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe, określ je, który nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguły w przeciwnym razie wyniesie zgodne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, lub <paramref name="type" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> jest <see langword="null" />.  - lub - <paramref name="accessMask" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> nie jest ani typu <see cref="T:System.Security.Principal.SecurityIdentifier" />, ani typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasa używana do reprezentowania zasad dostępu.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity> klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> właściwości i zwracany typ przejdą do reprezentowania zasad dostępu. Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły dostępu do użycia z każdego obiektu zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła kontroli dostępu do dodania.</param>
        <summary>Wyszukuje Reguła dopasowywania, z którego można by scalić nowej reguły. Jeśli żaden nie zostaną znalezione, dodaje nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> Metoda szuka reguły z tego samego użytkownika lub grupy i tym samym <xref:System.Security.AccessControl.AccessControlType> jako `rule`. Jeśli żaden nie zostaną znalezione, `rule` został dodany. Jeśli reguła dopasowywania zostanie znaleziony, prawa w `rule` są łączone z istniejącą regułą.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje oddzielenie <xref:System.Security.AccessControl.AccessControlType.Allow> reguł i <xref:System.Security.AccessControl.AccessControlType.Deny> reguł i zawiera kombinację praw w niezgodne reguły. W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu, dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika i wyświetla wynikowy pary reguł. W przykładzie następnie umożliwia nowe prawa dla bieżącego użytkownika oraz wyświetla wynik, pokazujący, że nowe uprawnienia zostaną scalone z istniejącym <xref:System.Security.AccessControl.AccessControlType.Allow> reguły.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AddAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła inspekcji, aby dodać. Użytkownik określony przez tę regułę określa wyszukiwania.</param>
        <summary>Wyszukuje reguła inspekcji, z którego można by scalić nowej reguły. Jeśli żaden nie zostaną znalezione, dodaje nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> Metody wyszukuje reguły z tego samego użytkownika lub grupy jako `rule`. Jeśli żaden nie zostaną znalezione, `rule` został dodany. Jeśli reguła dopasowywania zostanie znaleziony, flagi w `rule` są scalane w istniejącą regułę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="abstract member AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule&#xA;override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="semaphoreSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">
          <see cref="T:System.Security.Principal.IdentityReference" /> , Które identyfikują użytkownik lub grupa reguła dotyczy.</param>
        <param name="accessMask">Bitowe połączenie <see cref="T:System.Security.AccessControl.SemaphoreRights" /> wartości określających prawa dostępu do inspekcji, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="inheritanceFlags">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="propagationFlags">Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii.</param>
        <param name="flags">Bitowe połączenie <see cref="T:System.Security.AccessControl.AuditFlags" /> wartości, które określają, czy inspekcji pomyślnego dostępu i dostępu nie powiodło się.</param>
        <summary>Tworzy nową regułę inspekcji, określając użytkownika, którego dotyczy reguła, prawa dostępu do inspekcji i wyników, które wyzwala reguła inspekcji.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> obiekt reprezentujący reguła określonego inspekcji dla określonego użytkownika. Klasa podstawowa jest zwracany typ metody <see cref="T:System.Security.AccessControl.AuditRule" />, ale wartość zwracaną mogą bezpiecznie rzutowane do klasy pochodnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia zasady inspekcji jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAuditRule> klasy.  
  
> [!NOTE]
>  Chociaż flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe je określić. Nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguł, które w przeciwnym razie będą zgodne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, lub <paramref name="flags" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> jest <see langword="null" />.  - lub - <paramref name="accessMask" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> nie jest ani typu <see cref="T:System.Security.Principal.SecurityIdentifier" />, ani typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> klasa używana do reprezentowania zasad inspekcji.</summary>
        <value>A <see cref="T:System.Type" /> reprezentujący obiekt <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> klasy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity> klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> właściwości i zwracany typ przejdą do reprezentowania prawa inspekcji. Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły poprawne inspekcji do użycia z każdego obiektu zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As SemaphoreAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; bool" Usage="semaphoreSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> użytkownik, który określa i <see cref="T:System.Security.AccessControl.AccessControlType" /> do wyszukiwania i zestaw dziedziczenia i propagacji flag, które pasujący do reguły, jeśli znaleziono, musi być zgodny z. Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono.</param>
        <summary>Wyszukuje reguły kontroli dostępu z tego samego użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> (zezwalania lub odmowy) jako określonej reguły oraz zgodne dziedziczenia i flagi propagacji; jeśli taka reguła zostanie znaleziony, prawa zawarte w tej regule określonego dostępu są usuwane z go.</summary>
        <returns>
          <see langword="true" /> Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> jest wyszukiwany regułę, która ma ten sam użytkownik i tym samym <xref:System.Security.AccessControl.AccessControlType> wartość jako `rule`. Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca `false`. W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we `rule`. Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca `false`. Jeśli znaleziono reguły z flagami zgodne, prawa określone w `rule` są usuwane z niezgodne reguły, a metoda zwraca `true`. Jeśli `rule` określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw. Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu.  
  
> [!IMPORTANT]
>  Mimo że można określić flagi dziedziczenia i propagacji dla reguły dostępu do semafora, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> metody, nie jest to zalecane. Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów, a konserwacji reguł dostępu umożliwiają bardziej skomplikowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> metodę, aby usunąć prawa z <xref:System.Security.AccessControl.AccessControlType.Allow> reguły w <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu. Przedstawiono również że inne prawa w `rule` są ignorowane.  
  
 W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika. Prawa mogą zawierać <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, i <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. Przykład utworzy nową regułę dla bieżącego użytkownika, w tym <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> i <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> praw i korzysta z tej reguły z <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> metodę, aby usunąć <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> z <xref:System.Security.AccessControl.AccessControlType.Allow> reguły w <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu. Nadmiarowe <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> prawym przyciskiem myszy w `rule` jest ignorowana.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleAll : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> użytkownik, który określa i <see cref="T:System.Security.AccessControl.AccessControlType" /> do wyszukania. Wszelkie prawa określone przez tę regułę są ignorowane.</param>
        <summary>Wyszukuje wszystkie reguły kontroli z tego samego użytkownika dostępu i <see cref="T:System.Security.AccessControl.AccessControlType" /> (zezwalania lub odmowy) jako określona reguła oraz, jeśli znaleziono usuwa je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> reguły, które mają ten sam użytkownik i tym samym przeszukiwany jest obiekt <xref:System.Security.AccessControl.AccessControlType> wartość jako `rule`. Wszelkie prawa określone przez `rule` są ignorowane, podczas wykonywania tego wyszukiwania. Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, że <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> metoda usuwa wszystkie reguły zgodnych użytkowników i <xref:System.Security.AccessControl.AccessControlType>, ignorowanie praw.  
  
 W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> , dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika, a następnie scala dodatkowych praw do <xref:System.Security.AccessControl.AccessControlType.Allow> reguły. Przykład utworzy nową regułę, która umożliwia użytkownikowi przejęcie na własność i używa tej reguły, aby usunąć <xref:System.Security.AccessControl.AccessControlType.Allow> reguły z <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAccessRuleSpecific : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do usunięcia.</param>
        <summary>Wyszukuje reguły kontroli dostępu, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada `rule` wszystkie szczegóły, w tym flag. Inne zasady z tego samego użytkownika i <xref:System.Security.AccessControl.AccessControlType> pozostają niezmienione.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń dostępu dla użytkownika. W związku z tym reguły może już nie istnieje w określonej formy znajdował się, gdy ten element został dodany, w tym przypadku <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metody nie można go usunąć.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, że <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metoda wymaga dokładnego dopasowania, aby można było usunąć regułę, a reguły zezwalania i odmowy uprawnień są od siebie niezależne.  
  
 W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> , dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika, a następnie scala dodatkowych praw do <xref:System.Security.AccessControl.AccessControlType.Allow> regułę dostępu. Przykład następnie przekazuje oryginalnej <xref:System.Security.AccessControl.AccessControlType.Allow> regułę dotyczącą <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> — metoda i wyświetla wyniki, wskazujące, że nic nie zostanie usunięta. Przykład następnie tworzy regułę, która odpowiada <xref:System.Security.AccessControl.AccessControlType.Allow> reguły w <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu i pomyślnie używa <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> metodę, aby usunąć regułę.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As SemaphoreAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; bool" Usage="semaphoreSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> , który określa użytkownika, aby wyszukać i zestaw flagi dziedziczenia i propagacji, które pasujący reguły, jeśli znaleziono, musi być zgodny z. Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono.</param>
        <summary>Wyszukuje reguły inspekcji z tego samego użytkownika określoną regułą oraz zgodne dziedziczenia i flagi propagacji; Jeśli znaleziono niezgodne reguły, prawa zawarte w określonej reguły są usuwane z niej.</summary>
        <returns>
          <see langword="true" /> Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> jest wyszukiwany zasady inspekcji, który ma tego samego użytkownika `rule`. Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca `false`. W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we `rule`. Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca `false`. Jeśli znaleziono reguły z flagami zgodne, prawa określone w `rule` są usuwane z niezgodne reguły, a metoda zwraca `true`. Jeśli `rule` określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw. Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu.  
  
> [!IMPORTANT]
>  Mimo że można określić flagi dziedziczenia i propagacji semafora zasady inspekcji, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> metody, nie jest to zalecane. Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów a konserwacji zasad inspekcji umożliwiają bardziej skomplikowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleAll : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> , który określa użytkownika do wyszukania. Wszelkie prawa określone przez tę regułę są ignorowane.</param>
        <summary>Przeszukuje wszystkie inspekcji reguły z określoną regułą tego samego użytkownika i, jeśli znaleziono, usuwa je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity> jest wyszukiwany zasady inspekcji, które mają tego samego użytkownika `rule`. Wszelkie prawa określone przez `rule` są ignorowane, podczas wykonywania tego wyszukiwania. Wszystkie reguły dopasowywania zostaną usunięte. Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.RemoveAuditRuleSpecific : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Do usunięcia.</param>
        <summary>Wyszukuje zasady inspekcji, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada `rule` wszystkie szczegóły, w tym flag. Nie wpływa na inne zasady inspekcji dla tego użytkownika.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń inspekcji dla użytkownika. W związku z tym reguły może już nie istnieje w określonej formy znajdował się, gdy ten element został dodany, w tym przypadku <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> metody nie można go usunąć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.ResetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika określoną regułą, niezależnie od tego <see cref="T:System.Security.AccessControl.AccessControlType" />, a następnie dodaje określoną regułą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli brak reguł dostępu do których użytkownik odpowiada określonej reguły `rule` został dodany.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metoda zastępuje wszystkie reguły dla zgodnego użytkownika podana reguła dopasowania.  
  
 W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika. Przykład utworzy nową regułę, która pozwala bieżąca Pełna kontrola użytkownika i używa <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> metodę, aby zastąpić zarówno istniejących reguł nowej reguły.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As SemaphoreAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::SemaphoreAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAccessRule : System.Security.AccessControl.SemaphoreAccessRule -&gt; unit" Usage="semaphoreSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> Do dodania. Użytkownik i <see cref="T:System.Security.AccessControl.AccessControlType" /> tej zasady określają zasady można usunąć przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> (zezwalania lub odmowy) jako określonej reguły, a następnie dodaje określoną regułą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dla określonej reguły <xref:System.Security.AccessControl.AccessControlType.Allow>, ta metoda powoduje usunięcie wszystkich <xref:System.Security.AccessControl.AccessControlType.Allow> reguły dla określonego użytkownika, zastępując je z określoną regułą. Jeśli dla określonej reguły <xref:System.Security.AccessControl.AccessControlType.Deny>, wszystkie <xref:System.Security.AccessControl.AccessControlType.Deny> zastępuje reguły dla określonego użytkownika z określoną regułą.  
  
 Jeśli brak reguł której użytkownika i <xref:System.Security.AccessControl.AccessControlType> zgodne z określoną regułą `rule` został dodany.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> metoda usuwa wszystkie reguły, które odpowiadają zarówno wobec użytkownika i <xref:System.Security.AccessControl.AccessControlType> z `rule`, zastępując je za pomocą `rule`.  
  
 W przykładzie jest tworzony <xref:System.Security.AccessControl.SemaphoreSecurity> obiektu i dodaje reguły zezwalania i odmowy różne uprawnienia dla bieżącego użytkownika. Przykład utworzy nową regułę, która pozwala bieżąca Pełna kontrola użytkownika i używa <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> metodę, aby zastąpić istniejącą regułę z nową regułę Zezwalaj. Nie dotyczy reguła, która nie zezwala na dostęp.  
  
> [!NOTE]
>  W tym przykładzie nie dołączy do obiektu zabezpieczeń <xref:System.Threading.Semaphore> obiektu. Przykłady, które załączyć obiekty zabezpieczeń można znaleźć w <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> i <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As SemaphoreAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::SemaphoreAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="member this.SetAuditRule : System.Security.AccessControl.SemaphoreAuditRule -&gt; unit" Usage="semaphoreSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły z tego samego użytkownika określoną regułą inspekcji, niezależnie od tego <see cref="T:System.Security.AccessControl.AuditFlags" /> wartość, a następnie dodaje określoną regułą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli brak reguł inspekcji, w których użytkownik odpowiada określonej reguły `rule` został dodany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
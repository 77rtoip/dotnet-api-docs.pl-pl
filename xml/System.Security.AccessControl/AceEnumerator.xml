<Type Name="AceEnumerator" FullName="System.Security.AccessControl.AceEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e243cb564071bf81517ddfffdd03c3b5e986c43c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69265429" /></Metadata><TypeSignature Language="C#" Value="public sealed class AceEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AceEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.AceEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AceEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class AceEnumerator sealed : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type AceEnumerator = class&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Security.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia możliwość wykonywania iteracji przez wpisy kontroli dostępu (ACE) na liście kontroli dostępu (ACL).</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.GenericAce Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.AccessControl.GenericAce Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As GenericAce" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::GenericAce ^ Current { System::Security::AccessControl::GenericAce ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Security.AccessControl.GenericAce" Usage="System.Security.AccessControl.AceEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.GenericAce</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element z <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji. Ta właściwość pobiera przyjazną dla typu wersję obiektu.</summary>
        <value>Bieżący element w <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="aceEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa moduł wyliczający do następnego elementu <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji.</summary>
        <returns><see langword="true" />Jeśli moduł wyliczający został pomyślnie zaawansowana do następnego elementu; <see langword="false" /> Jeśli moduł wyliczający przeszedł koniec kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego lub po wywołaniu <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> metody moduł wyliczający jest umieszczony przed pierwszym elementem kolekcji, a pierwsze wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> metody przenosi moduł wyliczający na pierwszy element kolekcji.  
  
 Po przekazaniu końca kolekcji kolejne wywołania <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> zostaną zwrócone `false` do momentu <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> wywołania.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> <xref:System.InvalidOperationException>wyrzuca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="aceEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia początkową pozycję modułu wyliczającego, która jest wcześniejsza niż pierwszy element <see cref="T:System.Security.AccessControl.GenericAce" /> w kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli, takie jak dodawanie, modyfikowanie lub usuwanie elementów, są wykonywane do kolekcji, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> metody <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> lub metody zgłasza<xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
        <block subset="none" type="overrides"><para>Wszystkie wywołania <see cref="M:System.Security.AccessControl.AceEnumerator.Reset" /> muszą wynikać z tego samego stanu dla modułu wyliczającego. Preferowana implementacja polega na przeniesieniu modułu wyliczającego na początek kolekcji przed pierwszym elementem. Powoduje to unieważnienie modułu wyliczającego, jeśli kolekcja została zmodyfikowana od czasu utworzenia modułu wyliczającego, <see cref="M:System.Security.AccessControl.AceEnumerator.MoveNext" /> który <see cref="P:System.Security.AccessControl.AceEnumerator.Current" />jest zgodny z i.</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element z kolekcji.</summary>
        <value>Bieżący element w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> wyliczającego lub po wywołaniu metody, należy <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie do pierwszego elementu kolekcji <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>przed odczytaniem <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> wartości; w przeciwnym razie jest niezdefiniowana .  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>zwraca również wyjątek, jeśli ostatnie wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> zwrócone `false`, które wskazuje koniec kolekcji.  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>nie przenosi pozycji modułu wyliczającego i kolejne wywołania do <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> zwrócenia tego samego obiektu <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> do momentu wywołania lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> .  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważniony, a następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> <xref:System.InvalidOperationException>wyrzuca. Jeśli kolekcja zostanie zmodyfikowana między <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> i <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>, <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> zwraca element, który jest ustawiony na, nawet jeśli moduł wyliczający jest już unieważniony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

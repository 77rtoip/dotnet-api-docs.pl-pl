<Type Name="AceEnumerator" FullName="System.Security.AccessControl.AceEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ffe177672b01ccd81c89f92f01f897ecca124233" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39801905" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AceEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AceEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.AceEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AceEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class AceEnumerator sealed : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type AceEnumerator = class&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Security.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Umożliwia iteracyjne przeglądanie wpisów kontroli dostępu (ACE) listy kontroli dostępu (ACL).</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.GenericAce Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.AccessControl.GenericAce Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As GenericAce" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::GenericAce ^ Current { System::Security::AccessControl::GenericAce ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Security.AccessControl.GenericAce" Usage="System.Security.AccessControl.AceEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.GenericAce</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji. Tej właściwości pobiera wersję przyjaznego dla typu obiektu.</summary>
        <value>Bieżący element w <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="aceEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa modułu wyliczającego do następnego elementu <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie zaawansowane do następnego elementu; <see langword="false" /> Jeśli moduł wyliczający został przekazany na końcu kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego lub po wywołaniu <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> metody, moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji, a pierwsze wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> metoda moduł wyliczający jest przemieszczane nad pierwszego elementu w kolekcji.  
  
 Po końcu kolekcji sukces, kolejne wywołania <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> zwracają `false` aż <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> jest wywoływana.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany, takie jak dodawanie, modyfikowanie lub usuwanie elementów, zostaną wprowadzone do kolekcji, moduł wyliczający jest nieodwracalnie unieważniany, a następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="aceEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia położenie początkowe, czyli przed pierwszym elementem w moduł wyliczający <see cref="T:System.Security.AccessControl.GenericAce" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli takie jak dodawanie, modyfikowanie lub usuwanie elementów, zostaną wprowadzone do kolekcji, moduł wyliczający jest nieodwracalnie unieważniany, a następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> metody lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> metoda zgłasza wyjątek <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
        <block subset="none" type="overrides">
          <para>Wszystkie wywołania do <see cref="M:System.Security.AccessControl.AceEnumerator.Reset" /> musi prowadzić do takiego samego stanu dla modułu wyliczającego. Preferowany implementacja jest przejść na początek, kolekcji, przed pierwszym elementem modułu wyliczającego. Unieważnia modułu wyliczającego, jeśli kolekcja została zmodyfikowana od momentu utworzenia moduł wyliczający, który jest spójny ze <see cref="M:System.Security.AccessControl.AceEnumerator.MoveNext" /> i <see cref="P:System.Security.AccessControl.AceEnumerator.Current" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element w kolekcji.</summary>
        <value>Zwraca bieżący element w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego lub po wywołaniu <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> metody, należy wywołać <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>; w przeciwnym razie <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> jest niezdefiniowana .  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> Ponadto zgłasza wyjątek, jeśli ostatnie wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> zwrócił `false`, co oznacza koniec kolekcji.  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> nie powoduje przeniesienia pozycji modułu wyliczającego i kolejnych wywołań <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> zwracać ten sam obiekt, do momentu <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> jest wywoływana.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany, takie jak dodawanie, modyfikowanie lub usuwanie elementów, zostaną wprowadzone do kolekcji, moduł wyliczający jest nieodwracalnie unieważniany, a następne wywołanie <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> lub <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. W przypadku modyfikowania kolekcji między <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> i <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>, <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> zwraca element, który jest ustawiony, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolekcja została zmodyfikowana po utworzeniu modułu wyliczającego.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
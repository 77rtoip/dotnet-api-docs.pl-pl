<Type Name="RegistryAccessRule" FullName="System.Security.AccessControl.RegistryAccessRule">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="62c3253705ce2579586fdcfa198c3e0977ef242d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30567670" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryAccessRule : System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistryAccessRule extends System.Security.AccessControl.AccessRule" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistryAccessRule" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryAccessRule&#xA;Inherits AccessRule" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryAccessRule sealed : System::Security::AccessControl::AccessRule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.AccessRule</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje zestaw praw dostępu dozwolony lub niedozwolony dla użytkownika lub grupy. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistryAccessRule> Klasa jest jeden zestaw klas, które umożliwiają zarządzanie Windows kontrolę dostępu dla kluczy rejestru programu .NET Framework. Omówienie tych klas i ich związek z podstawowej struktury kontroli dostępu do systemu Windows, temacie <xref:System.Security.AccessControl.RegistrySecurity>.  
  
> [!NOTE]
>  Kontrolę dostępu systemu Windows można zastosować tylko do kluczy rejestru. Nie można zastosować do pary poszczególnych klucz/wartość przechowywanych w kluczu.  
  
 Aby uzyskać listę reguł obecnie stosowane do klucza rejestru, należy użyć <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Security.AccessControl.RegistrySecurity> obiekt, a następnie użyć jego <xref:System.Security.AccessControl.CommonObjectSecurity.GetAccessRules%2A> metodę, aby uzyskać kolekcję <xref:System.Security.AccessControl.RegistryAccessRule> obiektów.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> obiekty nie mapowanie jeden do jednego z wpisów kontroli dostępu na liście podstawowej DACL kontroli dostępu (DACL). Po otrzymaniu zbiór wszystkich reguł dostępu do klucza rejestru zestaw zawiera minimalną liczbę reguł obecnie wymaganych do wyrażenia wszystkich wpisów kontroli dostępu.  
  
> [!NOTE]
>  Podstawowej wpisów kontroli dostępu zmieniać, jak dodać i usunąć reguły. Informacje w regułach są scalane, jeśli to możliwe, aby utrzymać najmniejszą liczbę wpisów kontroli dostępu. W związku z tym odczytu bieżącą listę reguł, może nie wygląda tak samo jak lista wszystkich reguł, które zostały dodane.  
  
 Użyj <xref:System.Security.AccessControl.RegistryAccessRule> obiektów, aby określić prawa dostępu, aby zezwolić lub odmówić użytkownikowi lub grupie. A <xref:System.Security.AccessControl.RegistryAccessRule> zawsze obiekt reprezentuje zezwolenie na dostęp lub odmowa dostępu, nigdy nie oba.  
  
 Aby zastosować regułę do klucza rejestru, użyj <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metodę, aby pobrać <xref:System.Security.AccessControl.RegistrySecurity> obiektu. Modyfikowanie <xref:System.Security.AccessControl.RegistrySecurity> obiektu za pomocą jej metod dodać regułę, a następnie użyć <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metody ponownie dołączyć obiektu zabezpieczeń.  
  
> [!IMPORTANT]
>  Zmiany wprowadzane do <xref:System.Security.AccessControl.RegistrySecurity> obiektu nie wpływają na poziomy dostępu do klucza rejestru do czasu wywołania <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metody można przypisać obiektu zmieniony zabezpieczeń do klucza rejestru.  
  
 <xref:System.Security.AccessControl.RegistryAccessRule> obiekty są niezmienne. Zabezpieczeń dla klucza rejestru jest zmodyfikowany za pomocą metody <xref:System.Security.AccessControl.RegistrySecurity> klasy można dodać ani usunąć reguły; zgodnie z tym podstawowej wpisów kontroli dostępu są modyfikowane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje reguły dostępu z dziedziczenia i propagacji. W przykładzie jest tworzony <xref:System.Security.AccessControl.RegistrySecurity> obiekt, tworzy i dodaje dwie reguły, które mają <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> flagi. Pierwsza reguła ma żadnych flag propagacji, podczas gdy druga <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> i <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Program wyświetla reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekt, a następnie używa obiektu, aby utworzyć podklucz. Program tworzy element podrzędny, podklucz i podklucz podwójnym, a następnie wyświetla zabezpieczeń każdy. Ponadto program usuwa klucze testu.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Użytkownik lub grupa, którego będzie stosowana ta reguła. Musi być typu <see cref="T:System.Security.Principal.SecurityIdentifier" /> lub typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="registryRights">Bitowe połączenie <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości, wskazując praw dozwolony lub niedozwolony.</param>
        <param name="type">Jeden z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartość wskazującą, czy prawa zezwolono na dostęp lub odmowa dostępu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> klasy Określanie użytkownika lub grupy, ta reguła ma zastosowanie do prawa dostępu i określa, czy prawa dostępu określonego zezwolono na dostęp lub odmowa dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor Określa domyślne propagacji i dziedziczenia. Oznacza to <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> i <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="type" /> Określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identity" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="eventRights" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> nie jest ani typu <see cref="T:System.Security.Principal.SecurityIdentifier" /> ani typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Nazwa użytkownika lub grupy, będzie stosowana ta reguła.</param>
        <param name="registryRights">Bitowe połączenie <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości, wskazując praw dozwolony lub niedozwolony.</param>
        <param name="type">Jeden z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartość wskazującą, czy prawa zezwolono na dostęp lub odmowa dostępu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> klasy, określając nazwę użytkownika lub grupy, ta reguła ma zastosowanie do prawa dostępu i określa, czy prawa dostępu określonego zezwolono na dostęp lub odmowa dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor Określa domyślne propagacji i dziedziczenia. Oznacza to <xref:System.Security.AccessControl.InheritanceFlags.None?displayProperty=nameWithType> i <xref:System.Security.AccessControl.PropagationFlags.None?displayProperty=nameWithType>.  
  
 Ten konstruktor jest odpowiednikiem tworzenie <xref:System.Security.Principal.NTAccount> obiektu, przekazując `identity` do <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> Konstruktor i przekazywanie nowo utworzony <xref:System.Security.Principal.NTAccount> do obiektu <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.AccessControlType%29> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy reguły dostępu do rejestru i dodaje je do <xref:System.Security.AccessControl.RegistrySecurity> są scalane obiektu przedstawiający sposób reguły zezwalania i odmowy uprawnień oddzielana, podczas reguły zgodne z tego samego rodzaju.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="type" /> Określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registryRights" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="identity" /> jest ciągiem o zerowej długości.  
  
 —lub—  
  
 <paramref name="identity" /> jest więcej niż 512 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.IdentityReference identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.Security.Principal.IdentityReference,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::Security::Principal::IdentityReference ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Użytkownik lub grupa, którego będzie stosowana ta reguła. Musi być typu <see cref="T:System.Security.Principal.SecurityIdentifier" /> lub typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</param>
        <param name="registryRights">Bitowe połączenie <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości określających prawa dozwolony lub niedozwolony.</param>
        <param name="inheritanceFlags">Bitowe połączenie <see cref="T:System.Security.AccessControl.InheritanceFlags" /> flagi określające, jak prawa dostępu są dziedziczone z innych obiektów.</param>
        <param name="propagationFlags">Bitowe połączenie <see cref="T:System.Security.AccessControl.PropagationFlags" /> flagi określające, jak prawa dostępu są propagowane do innych obiektów.</param>
        <param name="type">Jeden z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartości określający, czy prawa zezwolono na dostęp lub odmowa dostępu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> klasy Określanie użytkownika lub grupy, ta reguła ma zastosowanie do prawa dostępu flagi dziedziczenia flagi propagacji i określa, czy prawa dostępu określonego zezwolono na dostęp lub odmowa dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie klucze rejestru są kontenerami, tak aby tylko flagi dziedziczenia zrozumiały dla kluczy rejestru <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> flagi. Jeśli ta flaga nie zostanie określony, flagi propagacji są ignorowane, a dotyczy tylko natychmiastowe klucza. Jeśli flaga jest obecny, reguły są propagowane, jak pokazano w poniższej tabeli. Tabela przyjęto założenie, że istnieje podklucz S podklucz podrzędnych CS i podklucz podwójnym GS. Ścieżka podklucza podwójnym jest S\CS\GS.  
  
|Flagi propagacji|S|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 Wzorzec podklucza podwójnym reguluje wszystkich jego podkluczy zawarty w podkluczu podwójnym.  
  
 Na przykład jeśli <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> określono flagę `inheritanceFlags` i <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> określono flagi propagacji `propagationFlags`, ta zasada nie ma zastosowania do natychmiastowego podklucza, ale dotyczą wszystkich jego podkluczy bezpośrednio podrzędne i wszystkich jego podkluczy zawierają one.  
  
> [!NOTE]
>  Mimo że można określić <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flagę dla `inheritanceFlags`, nie ma żadnych punktu w ten sposób. Na potrzeby kontroli dostępu pary nazwa/wartość w podkluczu, nie są oddzielnych obiektów. Prawa dostępu do par nazwa/wartość są kontrolowane przez prawa podklucza. Ponadto ponieważ wszystkich jego podkluczy są kontenerami (to znaczy zawierają inne podklucze), nie jest narażony na <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flagi. Na koniec, określając <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flagi niepotrzebnie komplikuje konserwacji zasad, ponieważ zakłócać połączenie w przeciwnym razie niezgodne reguły.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="type" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="inheritanceFlags" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="propagationFlags" /> Określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identity" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="registryRights" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> nie jest ani typu <see cref="T:System.Security.Principal.SecurityIdentifier" />, ani typu, takich jak <see cref="T:System.Security.Principal.NTAccount" /> którego można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistryAccessRule (string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string identity, valuetype System.Security.AccessControl.RegistryRights registryRights, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistryAccessRule.#ctor(System.String,System.Security.AccessControl.RegistryRights,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistryAccessRule(System::String ^ identity, System::Security::AccessControl::RegistryRights registryRights, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="identity" Type="System.String" />
        <Parameter Name="registryRights" Type="System.Security.AccessControl.RegistryRights" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identity">Nazwa użytkownika lub grupy, będzie stosowana ta reguła.</param>
        <param name="registryRights">Bitowe połączenie <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości, wskazując praw dozwolony lub niedozwolony.</param>
        <param name="inheritanceFlags">Bitowe połączenie <see cref="T:System.Security.AccessControl.InheritanceFlags" /> flagi określające, jak prawa dostępu są dziedziczone z innych obiektów.</param>
        <param name="propagationFlags">Bitowe połączenie <see cref="T:System.Security.AccessControl.PropagationFlags" /> flagi określające, jak prawa dostępu są propagowane do innych obiektów.</param>
        <param name="type">Jeden z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartości określający, czy prawa zezwolono na dostęp lub odmowa dostępu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> klasy określający nazwę użytkownika lub grupy, ta reguła ma zastosowanie do prawa dostępu flagi dziedziczenia flagi propagacji i określa, czy prawa dostępu określonego zezwolono na dostęp lub odmowa dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie klucze rejestru są kontenerami, tak aby tylko flagi dziedziczenia zrozumiały dla kluczy rejestru <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType> flagi. Jeśli ta flaga nie zostanie określony, flagi propagacji są ignorowane, a dotyczy tylko natychmiastowe klucza. Jeśli flaga jest obecny, reguły są propagowane, jak pokazano w poniższej tabeli. Tabela przyjęto założenie, że istnieje podklucz S podklucz podrzędnych CS i podklucz podwójnym GS. Ścieżka podklucza podwójnym jest S\CS\GS.  
  
|Flagi propagacji|S|CS|GS|  
|-----------------------|-------|--------|--------|  
|<xref:System.Security.AccessControl.PropagationFlags.None>|X|X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>|X|X||  
|<xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X|X|  
|<xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit>, <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>||X||  
  
 Wzorzec podklucza podwójnym reguluje wszystkich jego podkluczy zawarty w podkluczu podwójnym.  
  
 Na przykład jeśli <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> określono flagę `inheritanceFlags` i <xref:System.Security.AccessControl.PropagationFlags.InheritOnly> określono flagi propagacji `propagationFlags`, ta zasada nie ma zastosowania do natychmiastowego podklucza, ale dotyczą wszystkich jego podkluczy bezpośrednio podrzędne i wszystkich jego podkluczy zawierają one.  
  
> [!NOTE]
>  Mimo że można określić <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flagę dla `inheritanceFlags`, nie ma żadnych punktu w ten sposób. Na potrzeby kontroli dostępu pary nazwa/wartość w podkluczu, nie są oddzielnych obiektów. Prawa dostępu do par nazwa/wartość są kontrolowane przez prawa podklucza. Ponadto ponieważ wszystkich jego podkluczy są kontenerami (to znaczy zawierają inne podklucze), nie jest narażony na <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flagi. Na koniec, określając <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> flagi niepotrzebnie komplikuje konserwacji zasad, ponieważ zakłócać połączenie w przeciwnym razie niezgodne reguły.  
  
 Ten konstruktor jest odpowiednikiem tworzenie <xref:System.Security.Principal.NTAccount> obiektu, przekazując `identity` do <xref:System.Security.Principal.NTAccount.%23ctor%28System.String%29?displayProperty=nameWithType> Konstruktor i przekazywanie nowo utworzony <xref:System.Security.Principal.NTAccount> do obiektu <xref:System.Security.AccessControl.RegistryAccessRule.%23ctor%28System.Security.Principal.IdentityReference%2CSystem.Security.AccessControl.RegistryRights%2CSystem.Security.AccessControl.InheritanceFlags%2CSystem.Security.AccessControl.PropagationFlags%2CSystem.Security.AccessControl.AccessControlType%29> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje reguły dostępu z dziedziczenia i propagacji. W przykładzie jest tworzony <xref:System.Security.AccessControl.RegistrySecurity> obiektu, a następnie tworzy i dodaje dwie reguły, które mają <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> flagi. Pierwsza reguła ma żadnych flag propagacji, podczas gdy druga <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> i <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 Program wyświetla reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiektu, a następnie używa <xref:System.Security.AccessControl.RegistrySecurity> obiekt, aby utworzyć podklucz. Program tworzy element podrzędny, podklucz i podklucz podwójnym, a następnie wyświetla reguły dla każdego podklucza. Ponadto program usuwa klucze testu.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="registryRights" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="type" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="inheritanceFlags" /> Określa nieprawidłową wartość.  
  
 —lub—  
  
 <paramref name="propagationFlags" /> Określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventRights" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identity" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="identity" /> jest ciągiem o zerowej długości.  
  
 —lub—  
  
 <paramref name="identity" /> jest więcej niż 512 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegistryRights">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistryRights RegistryRights { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.AccessControl.RegistryRights RegistryRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistryAccessRule.RegistryRights" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RegistryRights As RegistryRights" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::RegistryRights RegistryRights { System::Security::AccessControl::RegistryRights get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistryRights</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prawa dozwolony lub odrzucany przez regułę dostępu.</summary>
        <value>Bitowe połączenie <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości, wskazując praw dozwolony lub odrzucany przez regułę dostępu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistryAccessRule> obiekty są niezmienne. Można utworzyć nową regułę dostępu reprezentujący inny użytkownik, inne prawa lub innej <xref:System.Security.AccessControl.AccessControlType>, ale nie można zmodyfikować istniejącą regułę dostępu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
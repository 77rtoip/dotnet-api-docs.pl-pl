<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a1e573054d899d9ece24be60d9cd1af96043f0b2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69085986" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia zabezpieczenia kontroli dostępu systemu Windows dla klucza rejestru. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity> Obiekt określa prawa dostępu do klucza rejestru, a także określa sposób inspekcji prób dostępu. Prawa dostępu do klucza rejestru są wyrażane jako reguły, z każdą regułą dostępu reprezentowaną przez <xref:System.Security.AccessControl.RegistryAccessRule> obiekt. Każda reguła inspekcji jest reprezentowana przez <xref:System.Security.AccessControl.RegistryAuditRule> obiekt.  
  
 Odzwierciedla to podstawowy system zabezpieczeń systemu Windows, w którym każdy zabezpieczany obiekt ma co najwyżej jedną poufną listę kontroli dostępu (DACL), która kontroluje dostęp do bezpiecznego obiektu i co najwyżej jedną systemową listę kontroli dostępu (SACL), która określa dostęp próby są poddawane inspekcji. Lista DACL i SACL uporządkowane listy wpisów kontroli dostępu (ACE), które określają dostęp i inspekcję dla użytkowników i grup. Obiekt <xref:System.Security.AccessControl.RegistryAccessRule> lub<xref:System.Security.AccessControl.RegistryAuditRule> może reprezentować więcej niż jeden wpis ACE.  
  
> [!NOTE]
>  Zabezpieczenia kontroli dostępu do systemu Windows można stosować tylko do kluczy rejestru. Nie można jej zastosować do poszczególnych par klucz/wartość przechowywanych w kluczu.  
  
 Klasy <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule> i<xref:System.Security.AccessControl.RegistryAuditRule> ukrywają szczegóły implementacji list ACL i ACE. Umożliwiają one ignorowanie różnych typów ACE siedemnastu i złożoność prawidłowego zachowania dziedziczenia i propagacji praw dostępu. Te obiekty zostały również zaprojektowane tak, aby uniemożliwić następujące typowe błędy kontroli dostępu:  
  
-   Tworzenie deskryptora zabezpieczeń z LISTą DACL o wartości null. Odwołanie o wartości null do listy DACL pozwala każdemu użytkownikowi dodawać reguły dostępu do obiektu, co może spowodować atak typu "odmowa usługi". Nowy <xref:System.Security.AccessControl.RegistrySecurity> obiekt zawsze zaczyna się od pustej listy DACL, co spowoduje odmowę dostępu dla wszystkich użytkowników.  
  
-   Naruszanie porządku kanonicznego kontroli dostępu. Jeśli lista ACE w DACL nie jest zachowana w kolejności kanonicznej, użytkownicy mogą przypadkowo uzyskać dostęp do bezpiecznego obiektu. Na przykład odmowa uprawnień dostępu musi być zawsze wyświetlana przed dozwolonymi prawami dostępu. <xref:System.Security.AccessControl.RegistrySecurity>obiekty zachowują prawidłową kolejność wewnętrznie.  
  
-   Manipulowanie flagami deskryptora zabezpieczeń, które powinny znajdować się tylko w obszarze kontroli Menedżera zasobów.  
  
-   Tworzenie nieprawidłowych kombinacji flag ACE.  
  
-   Manipulowanie dziedziczonymi ACE. Dziedziczenie i Propagacja są obsługiwane przez Menedżera zasobów w odpowiedzi na zmiany wprowadzone w zasadach dostępu i inspekcji.  
  
-   Wstawianie bezużytecznego dostępu do list kontroli dostępu.  
  
 Jedynymi możliwościami, które nie są obsługiwane przez obiekty zabezpieczeń .NET, są niebezpieczne działania, które należy unikać większości deweloperów aplikacji, takich jak następujące:  
  
-   Zadania niskiego poziomu, które są zwykle wykonywane przez Menedżera zasobów.  
  
-   Dodawanie lub usuwanie wpisów kontroli dostępu w sposób, który nie zachowuje porządku kanonicznego.  
  
 Aby zmodyfikować zabezpieczenia kontroli dostępu systemu Windows dla klucza rejestru, użyj <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metody do <xref:System.Security.AccessControl.RegistrySecurity> pobrania obiektu. Zmodyfikuj obiekt zabezpieczeń, dodając i usuwając reguły, a następnie używając <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> metody, aby ponownie dołączyć.  
  
> [!IMPORTANT]
>  Zmiany wprowadzone w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie nie wpływają na poziomy dostępu klucza rejestru do momentu <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> wywołania metody przypisania zmienionego obiektu zabezpieczeń do klucza rejestru.  
  
 Aby skopiować zabezpieczenia kontroli dostępu z jednego klucza rejestru do innego, użyj <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> metody w celu <xref:System.Security.AccessControl.RegistrySecurity> uzyskania obiektu reprezentującego reguły dostępu i inspekcji dla pierwszego klucza rejestru <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> , a następnie użyj metody, aby przypisać te reguły do Drugi klucz rejestru. Można również przypisać reguły do drugiego klucza rejestru przy użyciu <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> metody lub <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> , która przyjmuje <xref:System.Security.AccessControl.RegistrySecurity> parametr obiektu.  
  
 Użytkownicy z inwestycją w język definicji deskryptora zabezpieczeń (SDDL) mogą używać <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metody do ustawiania reguł dostępu dla klucza rejestru <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> i metody uzyskiwania ciągu, który reprezentuje reguły dostępu w formacie SDDL. Nie jest to zalecane w przypadku nowych rozwiązań programistycznych.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje, jak reguły zgodności są scalane po dodaniu i usunięciu, a drugi pokazuje, jak flagi dziedziczenia i propagacji wpływają na dodawanie i usuwanie reguł.  
  
 Przykład 1  
  
 Poniższy przykład kodu pokazuje, jak <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> Metoda usuwa prawa z zgodnej reguły i <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> jak metoda scala prawa z zgodnymi regułami.  
  
 Przykład tworzy <xref:System.Security.AccessControl.RegistrySecurity> obiekt i dodaje regułę, która zezwala na bieżące prawa użytkownika <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> . W przykładzie zostanie utworzona reguła przyznająca użytkownika <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, z takimi samymi prawami dziedziczenia i propagacji jak pierwsza reguła, a następnie jest <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> stosowana metoda usuwania <xref:System.Security.AccessControl.RegistrySecurity> tej nowej reguły z obiektu. <xref:System.Security.AccessControl.RegistryRights.SetValue>jest składnikiem programu <xref:System.Security.AccessControl.RegistryRights.ReadKey>, dlatego jest usuwany z zgodnej reguły. Zostaną wyświetlone reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie, pokazujące pozostałe składniki. <xref:System.Security.AccessControl.RegistryRights.ReadKey>  
  
 Przykładowy kod wywołuje metodę, <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> aby scalić z <xref:System.Security.AccessControl.RegistryRights.SetValue> powrotem do reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. Drugi przykład w tej sekcji dołącza obiekt zabezpieczeń i dlatego przykłady w <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> i. <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu demonstruje reguły dostępu z dziedziczeniem i propagacją. Przykład tworzy <xref:System.Security.AccessControl.RegistrySecurity> obiekt, a następnie tworzy i dodaje dwie reguły, które <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> mają flagę. Pierwsza reguła nie ma flag propagacji, a drugi ma <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> i. <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>  
  
 Program wyświetla reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie, a następnie <xref:System.Security.AccessControl.RegistrySecurity> używa obiektu do utworzenia podklucza. Program tworzy podrzędny podklucz i podklucz grandchild, a następnie wyświetla zabezpieczenia dla każdego podklucza. Na koniec program usuwa klucze testowe.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.AccessControl.RegistrySecurity" /> klasy z wartościami domyślnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nowy <xref:System.Security.AccessControl.RegistrySecurity> obiekt zawsze zaczyna się od pustej listy arbitralnego dostępu (DACL), która odrzuca cały dostęp dla wszystkich użytkowników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ wyliczeniowy, którego <see cref="T:System.Security.AccessControl.RegistrySecurity" /> Klasa używa do reprezentowania praw dostępu.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący Wyliczenie. <see cref="T:System.Security.AccessControl.RegistryRights" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> przesłaniają Właściwość i zwracają typ, którego używają do reprezentowania praw dostępu. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ wyliczenia do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> Identyfikujący użytkownika lub grupę, do której odnosi się reguła.</param>
        <param name="accessMask">Bitowa kombinacja <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości określająca prawa dostępu do zezwalania lub odmowy, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Wartość logiczna określająca, czy reguła jest dziedziczona.</param>
        <param name="inheritanceFlags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.InheritanceFlags" /> wartości określająca sposób, w jaki reguła jest dziedziczona przez podklucze.</param>
        <param name="propagationFlags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.PropagationFlags" /> wartości modyfikujących sposób, w jaki reguła jest dziedziczona przez podklucze. Bez znaczenia, jeśli wartość <paramref name="inheritanceFlags" /> jest. <see cref="F:System.Security.AccessControl.InheritanceFlags.None" /></param>
        <param name="type">Jedna z <see cref="T:System.Security.AccessControl.AccessControlType" /> wartości określająca, czy prawa są dozwolone czy odrzucane.</param>
        <summary>Tworzy nową regułę kontroli dostępu dla określonego użytkownika, z określonymi prawami dostępu, kontrolą dostępu i flagami.</summary>
        <returns><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> Obiekt reprezentujący określone prawa dla określonego użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia reguł kontroli dostępu jest użycie konstruktorów <xref:System.Security.AccessControl.RegistryAccessRule> klasy.  
  
> [!NOTE]
>  Chociaż można określić <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flagę, nie ma żadnego punktu. Na potrzeby kontroli dostępu pary nazwa/wartość w podkluczu nie są oddzielnymi obiektami. Prawa dostępu do par nazwa/wartość są kontrolowane przez prawa podklucza. Ponadto, ponieważ wszystkie podklucze są kontenerami (to oznacza, że mogą zawierać inne podklucze), nie ma to <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> wpływ na flagę. Na <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> koniec określenie flagi niepotrzebnie komplikuje konserwację reguł, ponieważ zakłóca ona normalną kombinację zgodnych reguł.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> lub<paramref name="type" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="accessMask" />ma wartość zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" />nie jest typem <see cref="T:System.Security.Principal.SecurityIdentifier" />ani typu, takiego jak <see cref="T:System.Security.Principal.NTAccount" /> , który można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, którego <see cref="T:System.Security.AccessControl.RegistrySecurity" /> Klasa używa do reprezentowania reguł dostępu.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący klasę. <see cref="T:System.Security.AccessControl.RegistryAccessRule" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> przesłaniają Właściwość i zwracają typ używany do reprezentowania reguł dostępu. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ reguły dostępu do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła kontroli dostępu do dodania.</param>
        <summary>Wyszukuje pasującą kontrolę dostępu, z którą można scalić nową regułę. Jeśli nie zostanie znaleziona, program doda nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje reguły z tym samym użytkownikiem lub grupą, tak samo <xref:System.Security.AccessControl.AccessControlType> jak `rule`. <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> Jeśli żaden nie zostanie znaleziony `rule` , jest dodawany. Jeśli zostanie znaleziona zgodna reguła, prawa w programie `rule` są scalane z istniejącą regułą.  
  
 Nie można scalić reguł, jeśli mają różne flagi dziedziczenia. Na przykład, jeśli użytkownik może uzyskać dostęp do odczytu bez flag dziedziczenia i <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> służy do dodawania reguły uprawniającej do zapisu użytkownika z dziedziczeniem dla podkluczy (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), nie można scalić tych dwóch reguł.  
  
 Reguły o różnych <xref:System.Security.AccessControl.AccessControlType> wartościach nigdy nie są scalane.  
  
 Reguły Express — prawa w najbardziej ekonomiczny sposób. Na przykład, jeśli <xref:System.Security.AccessControl.RegistryRights.QueryValues>użytkownik ma <xref:System.Security.AccessControl.RegistryRights.Notify> uprawnienia i <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> Dodaj regułę zezwalającą <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> na prawa, użytkownik ma wszystkie części <xref:System.Security.AccessControl.RegistryRights.ReadKey> praw. Po zbadaniu praw użytkownika zostanie wyświetlona reguła zawierająca <xref:System.Security.AccessControl.RegistryRights.ReadKey> prawa. Analogicznie, jeśli usuniesz <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> prawa, inne składniki <xref:System.Security.AccessControl.RegistryRights.ReadKey> praw zostaną wyświetlone ponownie.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy reguły dostępu do rejestru i dodaje je do <xref:System.Security.AccessControl.RegistrySecurity> obiektu, pokazując, jak reguły zezwalające na prawa i Odmów pozostają oddzielone, chociaż scalane są zgodne reguły tego samego rodzaju.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. Przykłady służące do dołączania obiektów zabezpieczeń <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> znajdują się w i <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Przykład kodu, który demonstruje flagi dziedziczenia i propagacji, można znaleźć w <xref:System.Security.AccessControl.RegistryAccessRule> klasie.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Reguła inspekcji do dodania. Użytkownik określony przez tę regułę określa wyszukiwanie.</param>
        <summary>Wyszukuje regułę inspekcji, z którą można scalić nową regułę. Jeśli nie zostanie znaleziona, program doda nową regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje reguły z tym samym użytkownikiem lub grupą, `rule`co. <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> Jeśli żaden nie zostanie znaleziony `rule` , jest dodawany. W przypadku znalezienia pasującej reguły flagi w programie `rule` są scalane z istniejącą regułą.  
  
 Nie można scalić reguł, jeśli mają różne flagi dziedziczenia. Na przykład jeśli nieudane próby zapisu w kluczu są poddawane inspekcji dla określonego użytkownika, bez flag dziedziczenia i <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> służy do dodawania reguły, która określa, że nieudane próby zmiany uprawnień mają być poddane inspekcji dla tego samego użytkownika, ale z dziedziczeniem dla podklucze<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>(), nie można scalić dwóch reguł.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference"><see cref="T:System.Security.Principal.IdentityReference" /> Identyfikujący użytkownika lub grupę, do której odnosi się reguła.</param>
        <param name="accessMask">Bitowa kombinacja <see cref="T:System.Security.AccessControl.RegistryRights" /> wartości określająca prawa dostępu do inspekcji, rzutowania na liczbę całkowitą.</param>
        <param name="isInherited">Wartość logiczna określająca, czy reguła jest dziedziczona.</param>
        <param name="inheritanceFlags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.InheritanceFlags" /> wartości określająca sposób, w jaki reguła jest dziedziczona przez podklucze.</param>
        <param name="propagationFlags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.PropagationFlags" /> wartości modyfikujących sposób, w jaki reguła jest dziedziczona przez podklucze. Bez znaczenia, jeśli wartość <paramref name="inheritanceFlags" /> jest. <see cref="F:System.Security.AccessControl.InheritanceFlags.None" /></param>
        <param name="flags">Bitowa kombinacja <see cref="T:System.Security.AccessControl.AuditFlags" /> wartości określająca, czy należy przeprowadzać inspekcję pomyślnego dostępu, dostęp niepowodzeniem lub oba te elementy.</param>
        <summary>Tworzy nową regułę inspekcji określającą użytkownika, do którego odnosi się reguła, prawa dostępu do inspekcji, dziedziczenia i propagacji reguły oraz wynik wyzwalający regułę.</summary>
        <returns><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> Obiekt reprezentujący określoną regułę inspekcji dla określonego użytkownika z określonymi flagami. Zwracany typ metody jest klasą <see cref="T:System.Security.AccessControl.AuditRule" />bazową, ale zwracana wartość może być bezpiecznie rzutowana na klasę pochodną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecanym sposobem tworzenia reguł inspekcji jest użycie konstruktorów <xref:System.Security.AccessControl.RegistryAuditRule> klasy.  
  
> [!NOTE]
>  Chociaż można określić <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> flagę, nie ma żadnego punktu. Na potrzeby kontroli inspekcji pary nazwa/wartość w podkluczu nie są oddzielnymi obiektami. Prawa inspekcji do par nazwa/wartość są kontrolowane przez prawa podklucza. Ponadto, ponieważ wszystkie podklucze są kontenerami (to oznacza, że mogą zawierać inne podklucze), nie ma to <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> wpływ na flagę. Na <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> koniec określenie flagi niepotrzebnie komplikuje konserwację reguł, ponieważ zakłóca ona normalną kombinację zgodnych reguł.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> lub<paramref name="flags" /> określa nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="identityReference" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="accessMask" />ma wartość zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" />nie jest typem <see cref="T:System.Security.Principal.SecurityIdentifier" />ani typu, takiego jak <see cref="T:System.Security.Principal.NTAccount" /> , który można przekonwertować na typ <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, którego <see cref="T:System.Security.AccessControl.RegistrySecurity" /> Klasa używa do reprezentowania reguł inspekcji.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący klasę. <see cref="T:System.Security.AccessControl.RegistryAuditRule" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy, które pochodzą od <xref:System.Security.AccessControl.ObjectSecurity> klasy <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> przesłaniają Właściwość i zwracają typ używany do reprezentowania praw inspekcji. Podczas pracy z tablicami lub kolekcjami, które zawierają wiele typów obiektów zabezpieczeń, Użyj tej właściwości, aby określić poprawny typ reguły inspekcji do użycia z każdym obiektem zabezpieczeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> , który określa użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> wyszukiwanie, oraz zestaw flag dziedziczenia i propagacji, które są zgodne z regułą, jeśli znaleziono, musi być zgodny z. Określa prawa do usunięcia z zgodnej reguły, jeśli zostanie znaleziona.</param>
        <summary>Wyszukuje regułę kontroli dostępu z tym samym użytkownikiem i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jako określoną regułę dostępu oraz z zgodnymi flagami dziedziczenia i propagacji; jeśli taka reguła zostanie znaleziona, prawa zawarte w określonej regule dostępu są usuwane z niej .</summary>
        <returns><see langword="true" />Jeśli zostanie znaleziona zgodna reguła; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.RegistrySecurity> jest wyszukiwany dla reguły, która ma tego samego użytkownika i taką <xref:System.Security.AccessControl.AccessControlType> samą wartość `rule`jak. Jeśli nie zostanie znaleziona taka reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostaną znalezione pasujące reguły, ich dziedziczenie i flagi zgodności są sprawdzane pod kątem zgodności z `rule`flagami określonymi w. Jeśli nie zostanie znaleziona zgodna reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostanie znaleziona reguła z zgodnymi flagami, prawa określone `rule` w programie są usuwane z zgodnej reguły i zwraca `true`metodę. Jeśli `rule` określa prawa, które nie są zawarte w zgodnej regule, nie jest podejmowana żadna akcja w odniesieniu do tych praw. Jeśli wszystkie prawa zostaną usunięte z reguły zgodności, cała reguła zostanie usunięta z bieżącego <xref:System.Security.AccessControl.RegistrySecurity> obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> Metoda usuwa prawa z zgodnej reguły i <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> jak metoda scala prawa z zgodnymi regułami.  
  
 Przykład tworzy <xref:System.Security.AccessControl.RegistrySecurity> obiekt i dodaje regułę, która zezwala na bieżące prawa użytkownika <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> . W przykładzie zostanie utworzona reguła przyznająca użytkownika <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, z takimi samymi prawami dziedziczenia i propagacji jak pierwsza reguła, a następnie jest <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> stosowana metoda usuwania <xref:System.Security.AccessControl.RegistrySecurity> tej nowej reguły z obiektu. <xref:System.Security.AccessControl.RegistryRights.SetValue>jest składnikiem programu <xref:System.Security.AccessControl.RegistryRights.ReadKey>, dlatego jest usuwany z zgodnej reguły. Zostaną wyświetlone reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie, pokazujące pozostałe składniki. <xref:System.Security.AccessControl.RegistryRights.ReadKey>  
  
 Przykładowy kod wywołuje metodę, <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> aby scalić z <xref:System.Security.AccessControl.RegistryRights.SetValue> powrotem do reguły w <xref:System.Security.AccessControl.RegistrySecurity> obiekcie.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. Drugi przykład w tej sekcji dołącza obiekt zabezpieczeń i dlatego przykłady w <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType>. <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> , który określa użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> wyszukiwanie. Wszystkie prawa, flagi dziedziczenia lub flagi propagacji określone przez tę regułę są ignorowane.</param>
        <summary>Wyszukuje wszystkie reguły kontroli dostępu dla tego samego użytkownika i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jak określona reguła i, jeśli została znaleziona, usunie je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.RegistrySecurity> jest wyszukiwany dla reguł, które mają tego samego użytkownika i <xref:System.Security.AccessControl.AccessControlType> taką samą `rule`wartość jak. Wszystkie prawa, flagi dziedziczenia lub flagi propagacji określone przez `rule` są ignorowane podczas wykonywania tego wyszukiwania. Jeśli nie zostaną znalezione pasujące reguły, nie zostanie podjęta żadna akcja.  
  
 Na przykład jeśli użytkownik ma wiele reguł, które zezwalają na różne prawa z innymi flagami dziedziczenia i propagacji, można usunąć wszystkie te reguły przez <xref:System.Security.AccessControl.RegistryAccessRule> utworzenie obiektu, który określa użytkownika <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>i, z dowolnymi prawami i flagami, i przekazanie tej reguły do <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> Metoda usuwa wszystkie reguły, które pasują do użytkownika, i <xref:System.Security.AccessControl.AccessControlType>ignoruje prawa i flagi.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.RegistrySecurity> obiekt i dodawane są reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, z różnymi flagami dziedziczenia i propagacji. W przykładzie zostanie utworzona Nowa reguła umożliwiająca bieżącemu użytkownikowi przejęcie na własność i przekazanie tej reguły do <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> metody w celu usunięcia dwóch reguł zezwalających na dostęp.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> Zobacz metodę<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> i metodę.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> Do usunięcia.</param>
        <summary>Wyszukuje regułę kontroli dostępu, która dokładnie pasuje do określonej reguły i, jeśli zostanie znaleziona, usunie ją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła jest usuwana tylko wtedy, gdy dokładnie `rule` pasuje do wszystkich szczegółów, w tym flag. Inne reguły z tym samym użytkownikiem i <xref:System.Security.AccessControl.AccessControlType> nie wpływają na nie.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej z podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielone lub łączone w miarę potrzeb podczas modyfikowania reguł zabezpieczeń dostępu dla użytkownika. W ten sposób reguła może już nie istnieć w konkretnym formularzu, gdy została dodana, a w takim przypadku <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> Metoda nie może go usunąć.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> Metoda usuwa regułę tylko wtedy, gdy dokładnie pasuje.  
  
 Przykład tworzy dwie reguły, które zezwalają na inne prawa. Reguły mają zgodne flagi dziedziczenia i propagacji, więc gdy druga reguła zostanie dodana, Scala ją z pierwszym. Przykład wywołuje <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> metodę, określając pierwszą regułę, ale ponieważ reguły są scalane, nie ma reguł pasujących do. Przykład następnie wywołuje <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> metodę, aby usunąć drugą regułę z Scalonej reguły, a wreszcie <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> wywołuje metodę, aby usunąć pierwszą regułę.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> Zobacz metodę<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> i metodę.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> który określa użytkownika do wyszukania, a zestaw flag dziedziczenia i propagacji, które jest zgodna z regułą, jeśli znaleziono, musi być zgodny z. Określa prawa do usunięcia z zgodnej reguły, jeśli zostanie znaleziona.</param>
        <summary>Wyszukuje regułę kontroli inspekcji z tym samym użytkownikiem co określona reguła i ze zgodnymi flagami dziedziczenia i propagacji; Jeśli zostanie znaleziona zgodna reguła, prawa zawarte w określonej regule zostaną z niej usunięte.</summary>
        <returns><see langword="true" />Jeśli zostanie znaleziona zgodna reguła; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca <xref:System.Security.AccessControl.RegistrySecurity> jest przeszukiwana reguła inspekcji, która ma tego samego użytkownika co `rule`. Jeśli nie zostanie znaleziona taka reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostaną znalezione pasujące reguły, ich dziedziczenie i flagi zgodności są sprawdzane pod kątem zgodności z `rule`flagami określonymi w. Jeśli nie zostanie znaleziona zgodna reguła, nie zostanie podjęta żadna akcja, a `false`Metoda zwraca. Jeśli zostanie znaleziona reguła z zgodnymi flagami, prawa określone `rule` w programie są usuwane z zgodnej reguły i zwraca `true`metodę. Jeśli `rule` określa prawa, które nie są zawarte w zgodnej regule, nie jest podejmowana żadna akcja w odniesieniu do tych praw. Jeśli wszystkie prawa zostaną usunięte z reguły zgodności, cała reguła zostanie usunięta z bieżącego <xref:System.Security.AccessControl.RegistrySecurity> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> , który określa użytkownika do wyszukania. Wszystkie prawa, flagi dziedziczenia lub flagi propagacji określone przez tę regułę są ignorowane.</param>
        <summary>Wyszukuje wszystkie reguły inspekcji z tym samym użytkownikiem co określona reguła i, jeśli zostanie znaleziona, usunie je.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Security.AccessControl.RegistrySecurity> jest przeszukiwany dla reguł inspekcji, które mają tego samego `rule`użytkownika co. Wszystkie prawa, flagi dziedziczenia lub flagi propagacji określone przez `rule` są ignorowane podczas wykonywania tego wyszukiwania. Jeśli nie zostaną znalezione pasujące reguły, nie zostanie podjęta żadna akcja.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> Do usunięcia.</param>
        <summary>Wyszukuje regułę inspekcji dokładnie zgodną z określoną regułą i, jeśli zostanie znaleziona, usunie ją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reguła jest usuwana tylko wtedy, gdy dokładnie `rule` pasuje do wszystkich szczegółów, w tym flag. Nie dotyczy to innych reguł inspekcji dla tego samego użytkownika.  
  
> [!IMPORTANT]
>  Reguła reprezentuje jeden lub więcej z podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielone lub łączone w miarę potrzeb podczas modyfikowania reguł zabezpieczeń inspekcji dla użytkownika. W ten sposób reguła może już nie istnieć w konkretnym formularzu, gdy została dodana, a w takim przypadku <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> Metoda nie może go usunąć.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły kontroli dostępu z tym samym użytkownikiem co określona reguła, niezależnie od <see cref="T:System.Security.AccessControl.AccessControlType" />, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych reguł dostępu, których użytkownik jest zgodny z określoną `rule` regułą, zostanie dodany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> metoda zastępuje wszystkie reguły dla pasującego użytkownika regułą określoną dla dopasowania.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.RegistrySecurity> obiekt i dodawane są reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, z różnymi flagami dziedziczenia i propagacji. W przykładzie zostanie utworzona Nowa reguła, która zezwala bieżącemu użytkownikowi na odczytywanie klucza, i używa <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> metody do usuwania wszystkich reguł dla użytkownika i zastępowania ich nową regułą.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> Zobacz metodę<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> i metodę.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAccessRule" /> Do dodania. Użytkownik i <see cref="T:System.Security.AccessControl.AccessControlType" /> ta reguła określają reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły kontroli dostępu z tym samym użytkownikiem i <see cref="T:System.Security.AccessControl.AccessControlType" /> (Zezwalaj lub Odmów) jak określona reguła, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określona reguła ma <xref:System.Security.AccessControl.AccessControlType.Allow>, efekt tej metody polega na usunięciu wszystkich <xref:System.Security.AccessControl.AccessControlType.Allow> reguł dla określonego użytkownika, zastępując je określoną regułą. Jeśli określona reguła ma <xref:System.Security.AccessControl.AccessControlType.Deny>wartość, wszystkie <xref:System.Security.AccessControl.AccessControlType.Deny> reguły dla określonego użytkownika zostaną zastąpione określoną regułą.  
  
 Jeśli nie ma żadnych reguł, <xref:System.Security.AccessControl.AccessControlType> `rule` których użytkownik i zgodne z określoną regułą zostanie dodany.  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> pokazuje, że metoda usuwa wszystkie reguły, które pasują zarówno do użytkownika, <xref:System.Security.AccessControl.AccessControlType> jak i z z `rule`, ignorowanie `rule`praw i flag i zastępuje je.  
  
 W przykładzie tworzony jest <xref:System.Security.AccessControl.RegistrySecurity> obiekt i dodawane są reguły zezwalające i odmawiające różnych praw dla bieżącego użytkownika, z różnymi flagami dziedziczenia i propagacji. Przykład tworzy nową regułę, która zezwala bieżącemu użytkownikowi na odczytywanie klucza, i używa <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> metody do usuwania dwóch reguł, które zezwalają na dostęp i zastępują je nową regułą. Nie dotyczy reguły, która odmówi dostępu.  
  
> [!NOTE]
>  Ten przykład nie dołącza obiektu zabezpieczeń do <xref:Microsoft.Win32.RegistryKey> obiektu. <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> Zobacz metodę<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> i metodę.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.RegistryAuditRule" /> Do dodania. Użytkownik określony przez tę regułę określa reguły do usunięcia przed dodaniem tej reguły.</param>
        <summary>Usuwa wszystkie reguły inspekcji z tym samym użytkownikiem co określona reguła, niezależnie od <see cref="T:System.Security.AccessControl.AuditFlags" /> wartości, a następnie dodaje określoną regułę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych reguł inspekcji, których użytkownik jest zgodny z określoną `rule` regułą, jest dodawany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rule" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

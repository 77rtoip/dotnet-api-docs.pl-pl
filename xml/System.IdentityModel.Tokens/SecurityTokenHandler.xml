<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db6ee2647211996474244058d82b42c4ff2a279b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69279432" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Abstrakcyjna klasa bazowa dla programów obsługi tokenów zabezpieczających.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasa jest klasą bazową, z której pochodzą wszystkie programy obsługi tokenów zabezpieczających. Program obsługi tokenów zabezpieczających jest odpowiedzialny za:  
  
-   Sprawdzanie poprawności tokenów<xref:System.IdentityModel.Tokens.SecurityToken>zabezpieczeń () typu, który jest przeznaczony do przetwarzania i pakowania oświadczeń zawartych w tokenie <xref:System.Security.Claims.ClaimsIdentity> do obiektu.  
  
-   Serializacja i deserializacja tokenów zabezpieczających typu, który jest przeznaczony do przetworzenia.  
  
-   Serializacja i deserializacja klauzul identyfikatora klucza (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), które odnoszą się do tokenów typu, jest przeznaczony do przetworzenia do i z `<wsse:SecurityTokenReference>` elementów.  
  
-   Tworzenie tokenów zabezpieczających <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> na podstawie obiektu, który został <xref:System.IdentityModel.SecurityTokenService> przesłany przez implementacje klasy.  
  
-   Tworzenie klauzul identyfikatora klucza z tokenu zabezpieczającego dla implementacji <xref:System.IdentityModel.SecurityTokenService> klasy.  
  
 Platforma Windows Identity Foundation (WIF) dostarcza następujące programy obsługi tokenów zabezpieczających:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Większość z tych klas uwidacznia dodatkowe elementy członkowskie, które implementują funkcje specyficzne dla przetwarzania tokenów, dla których Klasa jest zaprojektowana. W wielu przypadkach lepszym rozwiązaniem może być pochodzenie z jednej z tych klas zamiast bezpośrednio z <xref:System.IdentityModel.Tokens.SecurityTokenHandler> klasy.  
  
 Program obsługi tokenów zabezpieczających można dodać lub usunąć z kolekcji obsługi tokenów, określając [ &lt;Dodaj&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;Usuń&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md)lub [ &lt;Wyczyść&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) elementy w elemencie [&gt; SecurityTokenHandler w pliku konfiguracji. &lt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) Do obiektu, który zawiera ustawienia konfiguracji dla kolekcji programu obsługi, można uzyskać dostęp <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> za pośrednictwem właściwości i kolekcji obsługi, do której jest członkiem programu obsługi tokenów, <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> można uzyskać dostęp z właściwości. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Można zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> metodę, aby przetwarzać wszelkie niestandardowe elementy konfiguracji, które zajmie program obsługi.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasa uwidacznia kilka innych właściwości i metod. W zależności od funkcji wybranych do zaimplementowania można zastąpić niektóre lub wszystkie te elementy.  
  
 Należy zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> Właściwość <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> i metodę, aby zapewnić infrastrukturę WIF z informacjami o typie tokenu zabezpieczającego, który ma być przetwarzany przez klasę.  
  
 Funkcje walidacji, serializacji i deserializacji są udostępniane za pomocą właściwości lub metod, które wskazują, czy program obsługi może wykonać konkretną funkcję w połączeniu z metodą lub metodami, które implementują funkcjonalność. Poniższa lista par właściwości lub metod, które wskazują funkcjonalność z metodami, które implementują tę funkcjonalność:  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> Właściwość<xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> i Metoda: Sprawdza poprawność tokenu i pakietów oświadczeń zawartych w tokenie do <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Właściwość<xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> i metody: Serializacja tokenu.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Metody<xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> i metody: Deserializacja tokenu.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> Metoda<xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> i Metoda: Deserializacja klauzul identyfikatora klucza.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Metoda<xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> i Metoda: Serializowanie klauzul identyfikatora klucza.  
  
 Metody i są wywoływane z <xref:System.IdentityModel.SecurityTokenService> potoku w implementacjach klasy. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A>  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Metoda jest wywoływana przez infrastrukturę WIF w celu określenia, czy określony token został już odebrany. Domyślnie ta metoda zwraca `false`, co oznacza, że token nie został jeszcze odebrany. Można zastąpić metodę i zapewnić logikę w celu wykrycia powtarzających się tokenów.  
  
   
  
## Examples  
 Przykłady kodu we wszystkich <xref:System.IdentityModel.Tokens.SecurityTokenHandler> tematach są pobierane `Custom Token` z przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md). W poniższym kodzie XML pokazano, jak dodać program obsługi tokenów SWT do kolekcji obsługi tokenów.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Wywoływana z konstruktorów w klasach pochodnych w <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> celu zainicjowania klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML umieszczony w elemencie początkowym. Czytnik nie powinien być zaawansowany przez tę metodę.</param>
        <summary>Zwraca wartość wskazującą, czy element XML, do którego odwołuje się określony obiekt odczytujący XML, to klauzula identyfikatora klucza, którą można deserializować przez to wystąpienie.</summary>
        <returns><see langword="true" />Jeśli metoda może odczytać element; <see langword="false" />w przeciwnym razie. <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślną implementację zwraca `false` , aby wskazać, że nie można odczytać klauzuli identyfikatora klucza.  
  
 Klasa pochodna sprawdza element, do którego odwołuje się czytnik, aby określić, czy wystąpienie może deserializować klauzulę identyfikatora klucza. Jest to zazwyczaj realizowane przez wywołanie <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> metody z odpowiednimi określonymi ciągami elementów i przestrzeni nazw. W przypadku przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>należy również <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> zastąpić metodę, aby zapewnić logikę do deserializacji klauzuli identyfikatora klucza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy określony token może być deserializowany jako token typu przetworzonego przez to wystąpienie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Ciąg tokenu, który ma zostać odczytany.</param>
        <summary>Zwraca wartość wskazującą, czy określony ciąg może być deserializowany jako token typu przetworzonego przez to wystąpienie.</summary>
        <returns><see langword="true" />Jeśli metoda może odczytać element; <see langword="false" />w przeciwnym razie. <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zawsze zwraca wartość `false`.  
  
 Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> metodę, aby zapewnić logikę do deserializacji tokenu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML umieszczony w elemencie początkowym. Czytnik nie powinien być zaawansowany przez tę metodę.</param>
        <summary>Zwraca wartość wskazującą, czy element XML, do którego odwołuje się określony czytnik XML, może być odczytywany jako token typu przetworzonego przez to wystąpienie.</summary>
        <returns><see langword="true" />Jeśli metoda może odczytać element; <see langword="false" />w przeciwnym razie. <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zawsze zwraca wartość `false`.  
  
 Klasa pochodna sprawdza element, do którego odwołuje się czytnik, aby określić, czy wystąpienie może deserializować token zabezpieczający. Jest to zazwyczaj realizowane przez wywołanie <xref:System.Xml.XmlReader.IsStartElement%2A> metody z odpowiednimi określonymi ciągami elementów i przestrzeni nazw. W przypadku przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>należy również <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> zastąpić metodę lub <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> metodę, aby zapewnić logikę do deserializacji klauzuli identyfikatora klucza.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób przesłania <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> metody w celu ustalenia, czy token może być odczytywany przez program obsługi. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy program obsługi obsługuje walidację tokenów zabezpieczających.</summary>
        <value><see langword="true" />Jeśli klasa może sprawdzać poprawność tokenów zabezpieczających; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować walidację w klasie pochodnej, Przesłoń tę właściwość w `true` celu zwrócenia i <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> zastąpienia metody w celu zaimplementowania logiki walidacji.  
  
   
  
## Examples  
 Poniższy kod pokazuje, jak zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> właściwość, aby wskazać, że obsługa niestandardowa może weryfikować tokeny. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Klauzula identyfikatora klucza do sprawdzenia.</param>
        <summary>Zwraca wartość wskazującą, czy określona klauzula identyfikatora klucza może być serializowana przez to wystąpienie.</summary>
        <returns><see langword="true" />Jeśli klauzula identyfikatora klucza może być serializowana; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zawsze zwraca wartość `false`.  
  
 W przypadku przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>należy również <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> zastąpić metodę, aby zapewnić logikę do serializacji klauzuli identyfikatora klucza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy program obsługi może serializować tokeny zabezpieczające.</summary>
        <value><see langword="true" />Jeśli klasa jest w stanie serializacji tokenów; w <see langword="false" />przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zaimplementować serializację w klasie pochodnej, Przesłoń tę właściwość w celu `true` zwrócenia i <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> zastąpienia metod w celu zaimplementowania logiki serializacji.  
  
   
  
## Examples  
 Poniższy kod pokazuje, jak zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> właściwość, aby wskazać, że obsługa niestandardowa może serializować tokeny. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" /> obiekt, który zapewnia konfigurację dla bieżącego wystąpienia.</summary>
        <value>Obiekt konfiguracji dla bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest zazwyczaj ustawiana przez infrastrukturę konfiguracji [ &lt;z elementu securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) w pliku konfiguracji podczas uruchamiania aplikacji. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>  
  
 W klasach pochodnych <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> właściwość służy do uzyskiwania dostępu do ustawień konfiguracji. na przykład <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> można uzyskać dostęp do rejestru nazwy wystawcy <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> , który ma być używany w metodzie, z właściwości obiektu konfiguracji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję obsługi tokenów zawierającą bieżące wystąpienie.</summary>
        <value>Kolekcja obsługi tokenów, która zawiera bieżące wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu programu obsługi tokenów do <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> wystąpienia ta właściwość jest ustawiana automatycznie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Token, dla którego ma zostać utworzone odwołanie.</param>
        <param name="attached"><see langword="true" />Jeśli dołączone odwołanie powinno zostać utworzone; <see langword="false" /> Jeśli nie dołączono odwołania, należy je utworzyć.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program tworzy odwołanie do tokenu zabezpieczającego dla tokenów przetworzonych przez tę klasę. Ta metoda jest zazwyczaj wywoływana przez usługę tokenu zabezpieczającego (STS).</summary>
        <returns>Klauzula identyfikatora klucza odwołująca się do określonego tokenu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Klasy pochodne przesłaniają tę metodę w celu zwrócenia klauzuli identyfikatora klucza<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>(), której można użyć do `<wsse:SecurityTokenReference>` utworzenia elementu dla określonego tokenu.  
  
 Wywoływane z implementacji <xref:System.IdentityModel.SecurityTokenService> klasy.  
  
 <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> Zazwyczaj nie trzeba używać innych niż podczas tworzenia niestandardowej usługi tokenów zabezpieczających. Gdy usługa tokenu zabezpieczającego zwraca token zabezpieczający, wystawiony token zabezpieczający zawiera odwołania do dołączonych i niedołączonych tokenów zabezpieczających. Dołączone odwołania odnoszą się do tokenów zabezpieczających, które znajdują się w nagłówku zabezpieczeń komunikatu protokołu SOAP, a niedołączone odwołania do tokenów zabezpieczających, które nie znajdują się w nagłówku zabezpieczeń komunikatu protokołu SOAP. Te odwołania zwykle potwierdzają autentyczność wystawionego tokenu zabezpieczającego.  
  
   
  
## Examples  
 Poniższy kod pokazuje, jak zastąpić metodę, <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> aby utworzyć klauzulę identyfikatora klucza z określonego tokenu. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Deskryptor tokenu zabezpieczającego, z którego ma zostać utworzony token. Właściwości deskryptora tokenu są ustawiane przed wywołaniem tej metody.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy token zabezpieczający przy użyciu określonego deskryptora tokenu. Ta metoda jest wywoływana przez usługę tokenu zabezpieczającego (STS).</summary>
        <returns>Token zabezpieczający, który jest zgodny z właściwościami deskryptora tokenu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Wywoływane z implementacji <xref:System.IdentityModel.SecurityTokenService> klasy.  
  
   
  
## Examples  
 Poniższy kod pokazuje, <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> jak zastąpić metodę, aby utworzyć i zwrócić token z deskryptora tokenu. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token, który ma zostać wyszukany.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zgłasza wyjątek, jeśli określony token zostanie wykryty jako odtwarzany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja nie robi nic.  
  
 Klasy pochodne powinny zgłosić <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> , czy token został już użyty.  
  
 Windows Identity Foundation (WIF) udostępnia <xref:System.IdentityModel.Tokens.TokenReplayCache> klasę, z której mogą być wyprowadzane pamięci podręczne powtarzania [ &lt;i element konfiguracji tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) , którego można użyć do skonfigurowania pamięci podręcznej odtwarzania używanej przez token programy obsługi w aplikacji; jednak dokładna implementacja <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> metody jest do projektanta klasy pochodnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca zestaw identyfikatorów URI, które są używane w żądaniach do identyfikowania tokenu typu przetworzonego przez klasę pochodną.</summary>
        <returns>Zestaw identyfikatorów URI, które identyfikują typ tokenu obsługiwanego przez tę procedurę obsługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token przetworzony przez bieżące wystąpienie jest dostępny <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> za pomocą właściwości. <xref:System.Type> <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Metoda zwraca zestaw akceptowalnych identyfikatorów, które mogą być używane w komunikatach w celu odwoływania się do typu tokenu. Na przykład wartość identyfikatora URI używana w `<wst:TokenType>` elemencie `<wst:RequestSecurityToken>` pod elementem do żądania określonego rodzaju <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> tokenu (reprezentowane przez właściwość w modelu obiektu).  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób przesłania <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> metody w celu zwrócenia identyfikatorów typu tokenu dla niestandardowego tokenu. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Elementy konfiguracji XML. Każdy węzeł na liście jest typu <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ładuje konfigurację niestandardową z pliku XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Metoda jest wywoływana przez infrastrukturę konfiguracji. Gdy ta metoda jest wywoływana, `nodelist` będzie zawierać elementy podrzędne najwyższego poziomu programu [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) obsługi tokenów z pliku konfiguracyjnego. Każdy z nich może z kolei zawierać atrybuty lub elementy podrzędne w zależności od schematu konfiguracji zdefiniowanego dla klasy pochodnej.  
  
 Domyślna implementacja zgłasza <xref:System.NotImplementedException>. Zastąp tę metodę w klasie pochodnej, aby włączyć inicjalizację programu obsługi tokenów zabezpieczających z pliku konfiguracji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML umieszczony w elemencie początkowym XML do deserializacji w klauzuli identyfikatora klucza.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, deserializacji XML, do którego odwołuje się określony czytnik XML, do klauzuli identyfikatora klucza, która odwołuje się do tokenu przetworzonego przez klasę pochodną.</summary>
        <returns>Klauzula identyfikatora klucza, która została odszeregowana z kodu XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić logikę do deserializacji klauzuli identyfikatora klucza z pliku XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, deserializacji określonego XML do tokenu typu przetworzonego przez klasę pochodną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Ciąg do deserializacji.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, deserializacji określonego ciągu do tokenu typu przetworzonego przez klasę pochodną.</summary>
        <returns>Token zabezpieczający, który został odszeregowany od określonego ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić funkcję, która może deserializować token zabezpieczający z ciągu. W przypadku przesłonięcia tej metody należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML został umieszczony w elemencie początkowym tokenu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, deserializacji XML, do którego odwołuje się określony czytnik XML, do tokenu typu przetworzonego przez klasę pochodną.</summary>
        <returns>Token zabezpieczający, który został odszeregowany z pliku XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić logikę deserializacji tokenu zabezpieczającego z pliku XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> metodę. Zazwyczaj w klasach pochodnych, jeśli metoda nie może zdeserializować tokenu z odwołania XML, wygeneruje <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób przesłania <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> metody odczytu niestandardowego tokenu z określonego czytnika XML. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Czytnik XML został umieszczony w elemencie początkowym tokenu.</param>
        <param name="tokenResolver">Program rozpoznawania tokenów, który zawiera tokeny poza pasmem i pamięci podręcznej.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, deserializacji XML, do którego odwołuje się określony czytnik XML, do tokenu typu przetworzonego przez klasę pochodną przy użyciu określonego mechanizmu rozwiązywania konfliktów tokenu.</summary>
        <returns>Token zabezpieczający, który został odszeregowany z pliku XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Domyślna implementacja ignoruje `tokenResolver` parametr i deleguje wywołanie <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> metody.  
  
 Zastąp tę metodę, aby zapewnić logikę deserializacji tokenu zabezpieczającego z pliku XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> metodę. Zazwyczaj w klasach pochodnych, jeśli metoda nie może zdeserializować tokenu z odwołania XML, wygeneruje <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera typ tokenu zabezpieczającego, który jest przetwarzany przez to wystąpienie.</summary>
        <value>Typ tokenu zabezpieczającego, który jest przetwarzany przez to wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zastąpić tę właściwość w klasach pochodnych i zwrócić <xref:System.Type> token zabezpieczający (<xref:System.IdentityModel.Tokens.SecurityToken>), który jest przetwarzany przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy kod pokazuje, jak zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> właściwość w celu <xref:System.Type> zwrócenia tokenów zabezpieczających, które są przetwarzane przez niestandardową procedurę obsługi. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Token zabezpieczający, który jest sprawdzany.</param>
        <param name="errorMessage">Komunikat do zapisu w śladzie.</param>
        <summary>Śledzi zdarzenie błędu podczas walidacji tokenów zabezpieczających, gdy śledzenie jest włączone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana z metody <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> , gdy Walidacja tokenu kończy się niepowodzeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token, który został sprawdzony.</param>
        <summary>Śledzi pomyślne sprawdzenie poprawności zdarzenia tokenów zabezpieczających po włączeniu śledzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna być wywoływana z <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> metody po pomyślnym sprawdzeniu tokenu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token do zweryfikowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, sprawdza poprawność określonego tokenu zabezpieczającego. Token musi być typu przetworzonego przez klasę pochodną.</summary>
        <returns>Tożsamości zawarte w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Metoda jest wywoływana przez infrastrukturę w celu weryfikacji i wyodrębnienia oświadczeń z deserializowanego tokenu zabezpieczającego. Te oświadczenia są zwracane w kolekcji <xref:System.Security.Claims.ClaimsIdentity> obiektów zwracanych przez metodę. W typowym przypadku ta kolekcja będzie zawierać jedną tożsamość.  
  
 W klasach pochodnych Walidacja zazwyczaj obejmuje sprawdzenie, czy zamierzone odbiorcy określone w tokenie odnoszą się do <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> identyfikatorów URI odbiorców określonych we właściwości obiektu konfiguracji programu obsługi <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> tokenu określonego we właściwości. Te identyfikatory URI są zazwyczaj ustawiane w pliku konfiguracji w [ &lt;ramach&gt; elementu audienceUris](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) . Jeśli nie można zweryfikować odbiorców, <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> należy zgłaszać wyjątek.  
  
 Podczas przetwarzania tokenu wystawcy jest zazwyczaj weryfikowany przez przekazanie tokenu wystawcy do jednej <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> z metod <xref:System.IdentityModel.Tokens.IssuerNameRegistry> na obiekcie skonfigurowanym <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> dla programu obsługi za pomocą właściwości. Rejestr nazwy wystawcy jest zazwyczaj konfigurowany za [ &lt;pomocą&gt; elementu issuerNameRegistry](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) w pliku konfiguracyjnym. <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Zwraca nazwę wystawcy. Ta nazwa powinna być używana do ustawiania <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> właściwości w oświadczeniach zawartych w tokenie. Jeśli rejestr nazwy wystawcy nie zawiera wpisu dla tokenu wystawcy, <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> zwraca `null`wartość. W tym przypadku <xref:System.IdentityModel.Tokens.SecurityTokenException> jest to zwykle zgłaszane w klasach pochodnych, ale to zachowanie jest do projektanta klasy.  
  
   
  
## Examples  
 Poniższy kod przedstawia zastąpienie <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> metody obsługi tokenów zabezpieczających, która przetwarza proste tokeny sieci Web (SWT). Kod jest pobierany z `CustomToken` przykładu. Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 Poniższy kod ilustruje `CreateClaims` metodę, która jest wywoływana z przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> metody w poprzednim przykładzie. Ta metoda zwraca <xref:System.Security.Claims.ClaimsIdentity> obiekt, który jest tworzony na podstawie oświadczeń w tokenie. Kod jest pobierany z `CustomToken` przykładu. Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 Poniższy kod ilustruje `ValidateSignature` metodę, która jest wywoływana z przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> metody w prostym obsłudze tokenów sieci Web. Ta metoda sprawdza poprawność podpisu tokenu przy użyciu skonfigurowanego <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Kod jest pobierany z `CustomToken` przykładu. Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 Poniższy kod ilustruje `ValidateAudience` metodę, która jest wywoływana z przesłonięcia <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> metody w prostym obsłudze tokenów sieci Web. Ta metoda sprawdza poprawność odbiorców zawartych w tokenie względem identyfikatorów URI odbiorców, które zostały określone w konfiguracji. Kod jest pobierany z `CustomToken` przykładu. Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Modułu zapisujący XML.</param>
        <param name="securityKeyIdentifierClause">Klauzula identyfikatora klucza do serializacji.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, serializować określoną klauzulę identyfikatora klucza do formatu XML. Klauzula identyfikatora klucza musi być typu obsługiwanego przez klasę pochodną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić logikę serializacji klauzuli identyfikatora klucza do formatu XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, serializować określony token zabezpieczający. Token musi być typu przetworzonego przez klasę pochodną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token do serializacji.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, serializować określony token zabezpieczający do ciągu. Token musi być typu przetworzonego przez klasę pochodną.</summary>
        <returns>Serializowany token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić logikę serializacji tokenu zabezpieczającego do formatu XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Modułu zapisujący XML.</param>
        <param name="token">Token do serializacji.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, serializacji określonego tokenu zabezpieczającego do formatu XML. Token musi być typu przetworzonego przez klasę pochodną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie ta metoda zgłasza <xref:System.NotImplementedException> wyjątek.  
  
 Zastąp tę metodę, aby zapewnić logikę serializacji tokenu zabezpieczającego do formatu XML. Jeśli zastąpisz tę metodę, należy również zastąpić <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> właściwość.  
  
   
  
## Examples  
 Poniższy kod pokazuje, <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> jak zastąpić metodę w celu serializacji niestandardowego tokenu. Kod jest pobierany z `Custom Token` przykładu. Ten przykład zawiera klasy niestandardowe, które umożliwiają przetwarzanie prostych tokenów sieci Web (SWT). Aby uzyskać informacje na temat tego przykładu i innych przykładów dostępnych dla WIF i miejsca ich pobrania, zobacz [przykładowy indeks kodu WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c115a52489fd77750e537edfe5b3127ffc36e982" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>A <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> która przetwarza tokeny zabezpieczające typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> Klasy serializuje deserializuje i weryfikuje tokeny sesji. Tokeny sesji są tokenami typu <xref:System.IdentityModel.Tokens.SessionSecurityToken>. <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> Klasy serializuje tokenów do i z formatu pliku cookie. Domyślnie klasa serializuje tokenów do zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` elementów. Tokeny sesji są używane przez <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> (WSFAM) i <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) do przechowywania informacji o sesji, to przede wszystkim <xref:System.Security.Claims.ClaimsPrincipal> skojarzone z uwierzytelnionego użytkownika i czasem rozpoczęcia i wygaśnięcia sesji.  
  
 W scenariuszach pasywnym <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> wywołano <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) z potoku uwierzytelniania do utworzenia tokenu sesji z <xref:System.Security.Claims.ClaimsPrincipal> reprezentujący uwierzytelnionego użytkownika. SAM używa skonfigurowanych <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> do utworzenia tokenu i do serializacji go w pliku cookie (i do deserializacji tokenu z plików cookie na kolejne żądania). SAM używa wystąpienia skonfigurowanych <xref:System.IdentityModel.Services.CookieHandler> klasy zapisania pliku cookie do odpowiedzi HTTP. Ten plik cookie jest następnie zwracany do klienta, a kolejne żądania klienta może ona powodować plik cookie zamiast wprowadzania podróż dostawcy tożsamości, aby ponownie uzyskać token zabezpieczeń. Aby uzyskać więcej informacji o sposób działania sesji z WIF, zobacz [WIF sesji zarządzania](~/docs/framework/security/wif-session-management.md).  
  
> [!NOTE]
>  \<SecurityTokenHandlers > element konfiguracji może służyć do określenia <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> mający odpowiedzialność za zabezpieczanie sesji aplikacji. Deweloperzy należy zachować ostrożność podczas zmiana tego ustawienia konfiguracji, ponieważ niepoprawnie skonfigurowany system może spowodować naruszenie aplikacji. Na przykład określenie pochodnej HYPERLINK "http://msdn.microsoft.com/library/hh193426%28v=vs.110%29.aspx" \t "_blank" <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> i przekazywanie pustą kolekcję transformacje (CookieTransform) z podstawową, spowodowałoby serializowana w pliku cookie, który nie był chroniony tożsamości użytkowników. Umożliwia to osobie atakującej zmodyfikować tożsamości i w związku z tym Zmień uprawnienia dostępu.  
  
 Jeśli tokenu sesji jest w trybie odniesienia, czyli jego <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> właściwość jest `true`, sesja programu obsługi tokenów serializuje tylko właściwości tokenu sesji, które są potrzebne, można ponownie wygenerować klucza jej w <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>. W przypadku domyślnej <xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey> klasa jest używana do reprezentowania kluczy pamięci podręcznej i zapisuje programu obsługi tokenów <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> i <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> właściwości tokenu. Jeśli token sesji nie ma Tryb odwołania, oznacza to, <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> właściwość jest `false`, następnie, oprócz właściwości wspomniano powyżej, program obsługi wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metody na tablicę bajtów uzyskany token i magazynów wartość wynikową w również plik cookie. Aby uzyskać więcej informacji na temat jak token jest serializowany zobacz <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> metody.  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> Właściwości pobiera listę przekształceń, które są stosowane do sesji jako tokenu w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metody. Wszystkie transformacje pochodzi od <xref:System.IdentityModel.CookieTransform> klasy. W przypadku domyślnej <xref:System.IdentityModel.DeflateCookieTransform> i <xref:System.IdentityModel.ProtectedDataCookieTransform> są stosowane. <xref:System.IdentityModel.ProtectedDataCookieTransform> Używa interfejsu API ochrony danych (DPAPI) do ochrony materiałów pliku cookie. DPAPI używa specyficzne dla komputera, na którym jest uruchomiony w jego algorytmy ochrony klucza. Z tego powodu programu obsługi tokenów sesji domyślny nie jest używany w scenariuszach kolektywu serwerów sieci Web, ponieważ w takich scenariuszach tokeny zapisywane na jednym komputerze może być konieczne można odczytać na innym komputerze. Aby obejść ten problem, można użyć wiele strategii. Możesz na przykład:  
  
-   Zastąp wartość domyślna <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> z <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>. <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> Umożliwia określenie klucze podpisywania i szyfrowania, w obszarze ASP.NET `<machineKey>` w pliku konfiguracji.  
  
-   Podaj obsługi dla <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> zdarzenia w pliku global.asax.cs i Zamień sesji domyślny token obsługi przy użyciu wystąpienia <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> mający lista przekształceń obejmuje <xref:System.IdentityModel.RsaSignatureCookieTransform> i <xref:System.IdentityModel.RsaEncryptionCookieTransform>. Nowe wystąpienie można utworzyć za pomocą jednego z konstruktorów, która przyjmuje listę przekształceń.  
  
-   Pochodzi przekształcenie niestandardowe z <xref:System.IdentityModel.CookieTransform> klasa podstawowa i dołącz ją na liście transformacje mają być stosowane przy użyciu metody powyżej.  
  
-   Pochodzi niestandardowego programu obsługi tokenów z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> i wdrożyć własny mechanizm.  
  
 Aby uzyskać więcej informacji o używaniu sesji w scenariuszach kolektywu serwerów sieci Web, zobacz [WIF i farmy serwerów sieci Web](~/docs/framework/security/wif-and-web-farms.md).  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> Znajduje się w domyślnej kolekcji programu obsługi tokenów; jednak można zastąpić go niestandardową sesję programu obsługi tokenów określając najpierw [ &lt;Usuń&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md) pod [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) elementu do usunięcia z kolekcji, a następnie dodanie przy użyciu programu obsługi tokenów niestandardowych domyślny program obsługi [ &lt;Dodaj&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) elementu. Domyślnie można określić domyślny okres istnienia tokenu, umieszczając w niej [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elementu w obszarze `<add>` elementu. Można zaprojektować programu obsługi tokenów niestandardowych podjęcie elementy konfiguracji niestandardowej w obszarze `<add>` elementu przez zastąpienie <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> metodę w celu zapewnienia logikę do ich przetworzenia.  
  
   
  
## Examples  
 Następujący kod XML pokazano, jak zastąpić domyślny sesji programu obsługi tokenów zabezpieczających w kolekcji programu obsługi tokenów wystąpienia <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> klasy w konfiguracji.  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy, która korzysta z domyślnego pliku cookie transformacji i okres ważności tokenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> właściwości są inicjowane na <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Przekształcenia do zastosowania podczas kodowania lub dekodowania pliku cookie. Ustawia <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> przekształca klasy, która korzysta z określonego pliku cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> Właściwość jest inicjowana na <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">Przekształcenia do zastosowania podczas kodowania lub dekodowania pliku cookie. Ustawia <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> właściwości.</param>
        <param name="tokenLifetime">Domyślny okres istnienia dla tokenu. Ustawia <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy, która korzysta z określonego pliku cookie transformacji i okres istnienia tokenu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="tokenLifetime" /> jest mniejsze niż lub równe <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">Plik cookie zostanie on przekształcony.</param>
        <param name="outbound">
          <see langword="true" /> Jeśli plik cookie powinien być kodowany; <see langword="false" /> Jeśli plik cookie powinien zostać zdekodowane.</param>
        <summary>Stosuje przekształcenia, określonego przez <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> właściwości do kodowania lub dekodowania określonego pliku cookie.</summary>
        <returns>Zakodowany lub dekodowane pliku cookie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kodowanie pliku cookie przekształca są stosowane w kolejności, w jakiej występują w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> właściwości. Podczas dekodowania pliku cookie, są one stosowane w odwrotnej kolejności.  
  
 Wywoływana z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> metody do kodowania i dekodowania materiałów pliku cookie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> Jest właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />. Czytnik powinien znajdować się na <see langword="&lt;wsc:SecurityContextToken&gt;" /> elementu.</param>
        <summary>Zwraca wartość wskazującą, czy czytnik znajduje się w <see langword="&lt;wsc:SecurityContextToken&gt;" /> elementu.</summary>
        <returns>
          <see langword="true" /> Jeśli czytnik wskazuje <see langword="&lt;wsc:SecurityContextToken&gt;" /> elementu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten program obsługi wspiera sprawdzania poprawności tokenów typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> Jeśli program obsługi wspiera sprawdzania poprawności tokenów typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; w przeciwnym razie <see langword="false" />. Zawsze <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten program obsługi może zapisywać tokeny typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> Jeśli program obsługi może zapisywać tokeny typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; w przeciwnym razie <see langword="false" />. Zawsze <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę elementu pliku cookie.</summary>
        <value>Nazwa elementu pliku cookie. Domyślna nazwa elementu to "Plik Cookie".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> metod umożliwiających ustalenie elementu, pod którym zakodowany token materiałów powinien zapisu lub odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar nazw dla elementu pliku cookie.</summary>
        <value>Przestrzeń nazw dla elementu pliku cookie. Rozpoznano domyślnej przestrzeni nazw "http://schemas.microsoft.com/ws/2006/05/security".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> metod umożliwiających ustalenie, przestrzeń nazw elementu, pod którym zakodowany token materiałów powinien zapisu lub odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">Podmiot zabezpieczeń oświadczeń.</param>
        <param name="context">Ciąg kontekstu zdefiniowane przez obiekt wywołujący.</param>
        <param name="endpointId">Identyfikator punktu końcowego, do których token ma zakres.</param>
        <param name="validFrom">Czas błyskawicznych jaką token zaczyna obowiązywać.</param>
        <param name="validTo">Czas błyskawicznych po którym token nie jest już prawidłowy.</param>
        <summary>Tworzy <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> na podstawie zakresu główna i czasu określone oświadczenia w którym token jest prawidłowy.</summary>
        <returns>Token zabezpieczający sesji, który został utworzony. Właściwości w tokenie nowej sesji są ustawione zgodnie z określonymi parametrami.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Jest właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Deskryptor tokenu z których można utworzyć tokenu.</param>
        <summary>Tworzy token zabezpieczeń oparte na określony token deskryptora.</summary>
        <returns>Token zabezpieczający, który został utworzony. Są to wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy i zwraca tokenu zabezpieczającego sesji przy użyciu następujących właściwości w deskryptorze tokenu: <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>, i <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType>. Jeśli <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType> ustawiono właściwość `true` w konfiguracji programu obsługi tokenów określony przez <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> właściwości kontekstu ładowania początkowego jest tworzona na podstawie <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType> właściwości i jest zapisywany w tokenu sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tokenDescriptor" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Jest właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A odczytać tylko kolekcji, który zawiera listę przekształceń domyślna ma być stosowany do plików cookie, <see cref="T:System.IdentityModel.DeflateCookieTransform" /> i <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stała, który określa domyślny czas istnienia plików cookie, dziesięć godzin.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny okres istnienia tokenu.</summary>
        <value>Domyślny okres istnienia tokenu. Zawsze <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ tokenu identyfikatorów URI dla typów tokenów, które mogą być przetwarzane przez ten program obsługi.</summary>
        <returns>Identyfikator typu tokenu identyfikatorów URI dla typów tokenów, które mogą być przetwarzane przez ten program obsługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujący typ identyfikatory URI są obsługiwane: "http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation","http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct", a "http://schemas.xmlsoap.org/ws/2005/02/sc/sct".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">Elementy konfiguracji niestandardowej.</param>
        <summary>Konfiguracja niestandardowa obciążeń z pliku XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane przez infrastrukturę konfiguracji zainicjować <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> wystąpienia. Inicjuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> właściwość z `lifetime` atrybutu [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) w pliku konfiguracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customConfigElements" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Konfiguracja określona przez <paramref name="customConfigElements" /> jest nieprawidłowy. Na przykład nie zawiera <see langword="&lt;sessionTokenRequirement&gt;" /> elementu, zawiera więcej niż jeden <see langword="&lt;sessionTokenRequirement&gt;" /> element, prawidłowy <see cref="T:System.TimeSpan" /> nie można odczytać wartości z <see langword="lifetime" /> atrybutu, lub <see langword="lifetime" /> atrybut określa wartość, która jest mniejsza niż <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja deserializuje token zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</param>
        <summary>Odczytuje <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> przy użyciu określonego modułu odczytującego XML.</summary>
        <returns>Token zabezpieczający sesji odczytano wystąpienia <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czytnik musi być umieszczony na zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` elementu.  
  
 Domyślna implementacja wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> metodę przy użyciu tokenu domyślny program rozpoznawania nazw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Czytnik nie znajduje się w <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> lub <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> nie można odczytać.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">Strumień bajtów, który zawiera token.</param>
        <param name="tokenResolver">Token mechanizm rozpoznawania do użycia.</param>
        <summary>Odczytuje <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ze strumienia bajtów przy użyciu określonego program rozpoznawania nazw tokenów.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Który została odczytana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tworzy <xref:System.Xml.XmlDictionaryReader> za pośrednictwem tokenu i wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</param>
        <param name="tokenResolver">A <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> tego mogą być używane do rozpoznawania <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Odczytuje <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> przy użyciu określonego XML tokenu i odczytywania program rozpoznawania nazw.</summary>
        <returns>Token zabezpieczający sesji odczytano wystąpienia <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czytnik musi być umieszczony na zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` elementu.  
  
 Jeśli token materiałów są buforowane, jest odczytu z pamięci podręcznej tokenu, który jest wystąpieniem programu <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache> klasy. W przeciwnym razie wartość tokenu materiałów są odczytywane z elementem podrzędnym `<wsc:SecurityContextToken>` element, który jest określony przez <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> właściwości i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metoda jest wywoływana w celu zdekodowania pliku cookie.  
  
 Aby uzyskać więcej informacji na temat sposobu tokeny sesji są serializowane w `<SecurityContextToken` elementu, zobacz <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="tokenResolver" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Czytnik nie znajduje się w <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> lub <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> nie można odczytać.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Przekształcenia do użycia.</param>
        <summary>Ustawia przekształcenia, które będą stosowane do plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia listę przekształceń zwrócony przez <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> właściwości. Transformacje będą stosowane w kolejności, w jakiej występują na liście podczas kodowania pliku cookie i w odwrotnej kolejności podczas dekodowania pliku cookie.  
  
> [!WARNING]
>  Jeśli `transforms` parametr jest `null`, zostanie wygenerowany wyjątek z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metody wywołanego do kodowania i dekodowania pliku cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres istnienia tokenu.</summary>
        <value>Okres istnienia tokenu. Wartość domyślna to <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie jeśli [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) w pliku konfiguracyjnym określono element <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> właściwości jest ustawiana na wartość `lifetime` atrybutu według <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Występuje, próba ustawienia przedział czasu, która jest mniejsza niż lub równa zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ tokeny, których ten program obsługi przetwarza.</summary>
        <value>
          <see cref="T:System.Type" /> z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przekształcenia, które zostaną zastosowane do pliku cookie.</summary>
        <value>Lista transformacji zastosowanych do pliku cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Są używane w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">Token, który ma być sprawdzany.</param>
        <summary>Określa, czy sesji skojarzonego z określonym tokenem jest nadal ważny. Ważność jest określany przez sprawdzenie <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> i <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> właściwości określony token. Jest zwracany wyjątek, jeśli sesja nie jest już prawidłowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token nie jest prawidłową jeśli jego <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> właściwości ustawiono wartość, która występuje później niż <xref:System.DateTime.UtcNow%2A>, lub, jeśli jego <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> właściwości ustawiono wartość, która występuje wcześniej niż <xref:System.DateTime.UtcNow%2A>.  
  
 Wywoływana z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A> metod, aby sprawdzić sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityToken" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Jest właściwość <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">
          <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> Właściwości tokenu jest nowsza niż <see cref="P:System.DateTime.UtcNow" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">
          <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> Właściwości tokenu jest starsza niż <see cref="P:System.DateTime.UtcNow" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza poprawność tokenu i zwraca jego oświadczeń.</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token, który ma zostać zweryfikowana. Musi istnieć możliwość przypisania z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Weryfikuje określony token i zwraca jego oświadczeń.</summary>
        <returns>Tożsamości, które są zawarte w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A> metodę weryfikacji tokenu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" />
          <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> Nie można przypisać elementu z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Token, który ma zostać zweryfikowana. Musi istnieć możliwość przypisania z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <param name="endpointId">Identyfikator punktu końcowego, do których token ma zakres.</param>
        <summary>Sprawdza poprawność tokenu sesji i zwraca jego oświadczeń.</summary>
        <returns>Tożsamości, które są zawarte w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdza, aby upewnić się, że określony token znajduje się w zakresie identyfikator określony punkt końcowy, a jeśli tak jest, wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> metody; w przeciwnym razie zwraca <xref:System.IdentityModel.Tokens.SecurityTokenException>.  
  
> [!IMPORTANT]
>  Tokeny sesji, które mają <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> właściwość, która jest `null` lub puste są traktowane jako zasięg globalny. Stanowi to potencjalne zagrożenie dla bezpieczeństwa. Z tego powodu należy upewnij się, że <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> właściwość jest ustawiona w tokenów sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="endpointId" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> Nie można przypisać elementu z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
          <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /> Właściwość określony token nie jest <see langword="null" /> lub pusta i jej wartość jest inna niż podana przez <paramref name="endpointId" /> parametru.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializuje token.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja serializuje token do zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token do zapisania.</param>
        <summary>Serializuje określony token do tablicy typu byte.</summary>
        <returns>Tablica bajtów zakodowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializuje określony token, tworząc i składnika zapisywania XML za pośrednictwem <xref:System.IO.MemoryStream> i wywoływanie <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> metody. Zobacz tego przeciążenia, aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessiontoken" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Edytora XML, z którą ma zostać serializacji tokenu.</param>
        <param name="token">Token do zserializowania. Wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Serializuje określony token przy użyciu określonego składnika zapisywania XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja serializuje określony token jako zabezpieczenia WS konwersacji Feb2005 lub zabezpieczenia WS konwersacji 1.3 `<wsc:SecurityContextToken>` element, w zależności od wartości <xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType> właściwości. <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType> Właściwości jest szeregowana jako `Id` atrybutu. <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> Właściwości jest szeregowana jako `<Identifier>` element podrzędny. Jeśli nie `null` <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> właściwości jest szeregowana jako `<Instance>` elementu. Ponadto jeśli <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> właściwość jest `false`, cały token jest serializowany w tablicy binarny, który jest przekazywany do <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metody mają być kodowane. Zakodowany token następnie są zapisywane jako wartość kodowany w standardzie base64 do elementu i przestrzeń nazw określona przez <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> właściwości. Jeśli <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> właściwość jest `true`, token nie jest serializowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="token" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> Nie można przypisać elementu z <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.  
  
 —lub—  
  
 <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> Tokenu Określa wersję zabezpieczenia WS konwersacji, która nie jest obsługiwana przez program obsługi.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>
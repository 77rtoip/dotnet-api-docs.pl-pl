<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a87da613926af9faf82add64d298b573be21ce43" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69119243" /></Metadata><TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <TypeSignature Language="F#" Value="type SessionSecurityTokenHandler = class&#xA;    inherit SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>, Który przetwarza tokeny zabezpieczające typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />. <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializacja <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> klasy, deserializacji i walidacji tokenów sesji. Tokeny sesji są tokenami <xref:System.IdentityModel.Tokens.SessionSecurityToken>typu. <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> Klasa serializować tokeny do i z formatu plików cookie. Domyślnie Klasa serializować tokeny do Feb2005 lub WS-Secure konwersację z elementami 1,3 `<wsc:SecurityContextToken>` . Tokeny sesji są używane przez <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> (WSFAM) <xref:System.IdentityModel.Services.SessionAuthenticationModule> i (sam) do przechowywania informacji o sesji <xref:System.Security.Claims.ClaimsPrincipal> , jest to przede wszystkim skojarzone z uwierzytelnionym użytkownikiem i godzinami rozpoczęcia i wygaśnięcia sesji.  
  
 W scenariuszach pasywnych <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> wywołania <xref:System.IdentityModel.Services.SessionAuthenticationModule> do obiektu (sam) z potoku uwierzytelniania, aby utworzyć token sesji na podstawie <xref:System.Security.Claims.ClaimsPrincipal> tego, który reprezentuje uwierzytelnionego użytkownika. SAM używa skonfigurowanego <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> do tworzenia tokenu i serializowania go do pliku cookie (oraz do deserializacji tokenu z pliku cookie na kolejnych żądaniach). SAM używa wystąpienia skonfigurowanej <xref:System.IdentityModel.Services.CookieHandler> klasy do zapisu pliku cookie z powrotem do odpowiedzi HTTP. Ten plik cookie jest następnie zwracany do klienta i w kolejnych żądaniach, które klient może przedstawić plik cookie, zamiast przeprowadzenia rundy z powrotem do dostawcy tożsamości w celu ponownego uzyskania tokenu zabezpieczającego. Aby uzyskać więcej informacji na temat sposobu działania sesji z usługą WIF, zobacz [Zarządzanie sesją WIF](~/docs/framework/security/wif-session-management.md).  
  
> [!NOTE]
>  Element konfiguracji obiektów <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> SecurityTokenHandler>możesłużyćdookreślenia,któryjestodpowiedzialnyzazabezpieczanie\<sesji aplikacji. Deweloperzy powinni zachować ostrożność w przypadku zmiany tego ustawienia konfiguracji, ponieważ nieprawidłowo skonfigurowany system może spowodować naruszenie zabezpieczeń aplikacji. Na przykład określenie pochodnej <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> i przekazanie pustej kolekcji przekształcenia (CookieTransform) na bazę danych spowoduje, że tożsamość użytkowników zostanie zserializowana do pliku cookie, który nie jest chroniony. Dzięki temu osoba atakująca może zmodyfikować tożsamość i w związku z tym zmienić uprawnienia dostępu.  
  
 Jeśli token sesji jest w trybie referencyjnym, oznacza to, że <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> jego właściwość `true`to, program obsługi token sesji tylko serializacji właściwości tokenu sesji, które są konieczne do ponownego <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>wygenerowania klucza w. W domyślnym przypadku <xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey> Klasa jest używana do reprezentowania kluczy pamięci podręcznej, a program obsługi tokenów <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> zapisuje właściwości <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> i tokenu. Jeśli token sesji nie znajduje się w trybie referencyjnym, oznacza to, <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> że `false`oprócz właściwości wymienionych wcześniej <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> , procedura obsługi wywołuje metodę na serializowanej tablicy bajtowej z tokenu i zapisuje również wartość w pliku cookie. Aby uzyskać więcej informacji o sposobie serializacji tokenu, zobacz <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> metodę.  
  
 Właściwość pobiera listę transformacji, które są stosowane do tokenu sesji <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> w metodzie. <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> Wszystkie przekształcenia pochodzą od <xref:System.IdentityModel.CookieTransform> klasy. W przypadku domyślnego przypadku <xref:System.IdentityModel.DeflateCookieTransform> stosowane <xref:System.IdentityModel.ProtectedDataCookieTransform> są i. Program <xref:System.IdentityModel.ProtectedDataCookieTransform> używa interfejsu API ochrony danych (DPAPI) do ochrony materiału plików cookie. Funkcja DPAPI używa klucza specyficznego dla komputera, na którym jest uruchomiony w algorytmach ochrony. Z tego powodu program obsługi tokenów sesji domyślnej nie jest użyteczny w scenariuszach farmy sieci Web, ponieważ w takich scenariuszach tokeny zapisywane na jednym komputerze mogą wymagać odczytu na innym komputerze. Aby obejść ten problem, można użyć wielu strategii. Możesz na przykład:  
  
-   Zastąp wartość <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> domyślną wartością <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>. Umożliwia określenie kluczy podpisywania i szyfrowania w elemencie ASP.NET `<machineKey>` w pliku konfiguracji. <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   Podaj <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> procedurę obsługi dla zdarzenia w pliku Global.asax.cs i Zastąp domyślną procedurę obsługi tokena sesji <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> wystąpieniem, które zawiera listę <xref:System.IdentityModel.RsaSignatureCookieTransform> przekształceń, <xref:System.IdentityModel.RsaEncryptionCookieTransform>które zawierają i. Nowe wystąpienie można utworzyć, wywołując jeden z konstruktorów, które pobierają listę transformacji.  
  
-   Utwórz niestandardową transformację <xref:System.IdentityModel.CookieTransform> z klasy bazowej i użyj powyższej metody, aby dołączyć ją do listy przekształceń, które mają zostać zastosowane.  
  
-   Utwórz program obsługi tokenów niestandardowych <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> z i zaimplementuj własny mechanizm.  
  
 Aby uzyskać więcej informacji na temat korzystania z sesji w scenariuszach farmy sieci Web, zobacz [WIF i farmy serwerów sieci Web](~/docs/framework/security/wif-and-web-farms.md).  
  
 Jest uwzględniona w domyślnej kolekcji programu obsługi tokenów, ale można ją zastąpić za pomocą programu obsługi token sesji niestandardowej, najpierw [ &lt;określając element Remove&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md) w obszarze <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> [ &lt; element&gt; securityTokenHandlers](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) , aby usunąć domyślną procedurę obsługi z kolekcji, a następnie dodać [ &lt;&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) program obsługi tokenów niestandardowych przy użyciu elementu Add. Domyślnie można określić domyślny okres istnienia tokenu, dołączając do `<add>` [ &lt;elementu sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) element. Program obsługi tokenów niestandardowych można zaprojektować, aby przyjmować niestandardowe elementy `<add>` konfiguracji w ramach elementu <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> przez zastąpienie metody w celu zapewnienia logiki przetwarzania ich.  
  
   
  
## Examples  
 W poniższym kodzie XML pokazano, jak zastąpić domyślną procedurę obsługi tokenu zabezpieczeń sesji w kolekcji obsługi tokenów z wystąpieniem <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> klasy w konfiguracji.  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
    <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
    <related type="Article" href="https://msdn.microsoft.com/library/fc3cd7fa-2b45-4614-a44f-8fa9b9d15284">Program WIF i farmy serwerów internetowych</related>
    <related type="Article" href="https://msdn.microsoft.com/library/98bce126-18a9-401b-b20d-67ee462a5f8a">Zarządzanie sesjami programu WIF</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy, które używa domyślnego przekształcenia plików cookie i okresu istnienia tokenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime> <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>Właściwości <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> i<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> są inicjowane do i.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler transforms" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformacje do zastosowania podczas kodowania lub dekodowania pliku cookie. <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> Ustawia właściwość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy, która używa określonego przekształcenia plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest inicjowana do <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>. <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transforms" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; * TimeSpan -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler (transforms, tokenLifetime)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformacje do zastosowania podczas kodowania lub dekodowania pliku cookie. <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> Ustawia właściwość.</param>
        <param name="tokenLifetime">Domyślny okres istnienia tokenu. <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" /> Ustawia właściwość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> klasy, która używa określonego przekształcenia plików cookie i okresu istnienia tokenu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transforms" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="tokenLifetime" />jest mniejsze lub równe <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberSignature Language="F#" Value="abstract member ApplyTransforms : byte[] * bool -&gt; byte[]&#xA;override this.ApplyTransforms : byte[] * bool -&gt; byte[]" Usage="sessionSecurityTokenHandler.ApplyTransforms (cookie, outbound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">Plik cookie, który zostanie przekształcony.</param>
        <param name="outbound"><see langword="true" />Jeśli plik cookie powinien zostać zakodowany; <see langword="false" /> Jeśli plik cookie powinien zostać zdekodowany.</param>
        <summary>Stosuje transformacje określone przez <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> właściwość w celu kodowania lub dekodowania określonego pliku cookie.</summary>
        <returns>Zakodowany lub zdekodowany plik cookie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas kodowania przekształcenia plików cookie są stosowane w kolejności, w jakiej są wyświetlane we <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> właściwości. Podczas dekodowania pliku cookie są one stosowane w odwrotnej kolejności.  
  
 Wywoływana z <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> metod i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> do kodowania i dekodowania materiału cookie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> Właściwość jest<see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="sessionSecurityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />. <see cref="T:System.Xml.XmlReader" /> Czytnik powinien być umieszczony w <see langword="&lt;wsc:SecurityContextToken&gt;" /> elemencie.</param>
        <summary>Zwraca wartość wskazującą, czy czytnik jest umieszczony w <see langword="&lt;wsc:SecurityContextToken&gt;" /> elemencie.</summary>
        <returns><see langword="true" />Jeśli czytnik wskazuje <see langword="&lt;wsc:SecurityContextToken&gt;" /> element; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ta obsługa obsługuje walidację tokenów typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value><see langword="true" />Jeśli program obsługi obsługuje walidację tokenów typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; <see langword="false" />w przeciwnym razie. Zawsze <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten program obsługi może pisać tokeny typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value><see langword="true" />Jeśli program obsługi może pisać tokeny typu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; w przeciwnym <see langword="false" />razie,. Zawsze <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieElementName : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę elementu cookie.</summary>
        <value>Nazwa elementu plików cookie. Domyślna nazwa elementu to "cookie".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> metodach i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> do określenia elementu, w którym należy zapisać lub odczytać zakodowany materiał tokenu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieNamespace : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przestrzeń nazw dla elementu cookie.</summary>
        <value>Przestrzeń nazw dla elementu cookie. Domyślną przestrzenią nazw <c>jesthttp://schemas.microsoft.com/ws/2006/05/security""</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest używana w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> metodach i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> do określenia przestrzeni nazw elementu, w którym należy zapisać lub odczytać zakodowany materiał tokenu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="F#" Value="abstract member CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken&#xA;override this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionSecurityTokenHandler.CreateSessionSecurityToken (principal, context, endpointId, validFrom, validTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">Podmiot zabezpieczeń oświadczeń.</param>
        <param name="context">Ciąg kontekstu zdefiniowany przez proces wywołujący.</param>
        <param name="endpointId">Identyfikator punktu końcowego, do którego odnosi się zakres tokenu.</param>
        <param name="validFrom">Czas, w którym token stał się ważny.</param>
        <param name="validTo">Czas natychmiast, po którym token nie jest już ważny.</param>
        <summary>Tworzy na <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> podstawie określonego podmiotu zabezpieczeń oświadczeń i zakresu czasu, w którym token jest prawidłowy.</summary>
        <returns>Utworzono token zabezpieczeń sesji. Właściwości nowego tokenu sesji są ustawiane zgodnie z określonymi parametrami.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="principal" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Właściwość jest<see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Deskryptor tokenu, z którego ma zostać utworzony token.</param>
        <summary>Tworzy token zabezpieczający na podstawie określonego deskryptora tokenu.</summary>
        <returns>Utworzony token zabezpieczający. Będzie to wystąpienie <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy i zwraca token zabezpieczający sesji przy użyciu następujących właściwości w deskryptorze tokenu: <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>, i. <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType> Jeśli właściwość jest ustawiona `true` w konfiguracji <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> programu obsługi tokenów określonej przez właściwość <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType> , kontekst ładowania początkowego jest tworzony na podstawie właściwości i jest zapisywany w tokenie sesji. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tokenDescriptor" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Właściwość jest<see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultCookieTransforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kolekcja tylko do odczytu zawierająca listę domyślnych przekształceń, które mają być stosowane do plików cookie, <see cref="T:System.IdentityModel.DeflateCookieTransform" /> <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />i.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stała określająca domyślny okres istnienia plików cookie, dziesięć godzin.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTokenLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny okres istnienia tokenu.</summary>
        <value>Domyślny okres istnienia tokenu. Zawsze <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="override this.GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="sessionSecurityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera identyfikatory URI typu tokenu dla typów tokenów, które mogą być przetwarzane przez tę procedurę obsługi.</summary>
        <returns>Identyfikatory URI identyfikatora typu tokenu dla typów tokenów, które mogą być przetwarzane przez tę procedurę obsługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługiwane są następujące identyfikatory URI: 
 
 - `http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation`
 - `http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct`
 - `http://schemas.xmlsoap.org/ws/2005/02/sc/sct`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberSignature Language="F#" Value="override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="sessionSecurityTokenHandler.LoadCustomConfiguration customConfigElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">Elementy konfiguracji niestandardowej.</param>
        <summary>Ładuje konfigurację niestandardową z pliku XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływane przez infrastrukturę konfiguracji w celu zainicjowania <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> wystąpienia. Inicjuje Właściwość z atrybutu elementu [sessionTokenRequirement&gt;w pliku konfiguracyjnym. &lt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) `lifetime` <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="customConfigElements" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Konfiguracja określona przez <paramref name="customConfigElements" /> jest nieprawidłowa. Na przykład <see langword="&lt;sessionTokenRequirement&gt;" /> nie zawiera elementu, zawiera więcej niż jeden <see langword="&lt;sessionTokenRequirement&gt;" /> element, nie można odczytać prawidłowej <see cref="T:System.TimeSpan" /> wartości z <see langword="lifetime" /> atrybutu lub <see langword="lifetime" /> atrybut określa wartość, która jest mniejsza niż <see cref="F:System.TimeSpan.Zero" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje a <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Domyślna implementacja deserializacji tokena z Feb2005 "WS-Secure konwersacja" lub "WS-Secure conversation" `<wsc:SecurityContextToken>` 1,3.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />. <see cref="T:System.Xml.XmlReader" /></param>
        <summary><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Odczytuje przy użyciu określonego czytnika XML.</summary>
        <returns>Odczytany token zabezpieczeń sesji, wystąpienie elementu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Czytnik musi być umieszczony na Feb2005 konwersacji WS-Secure lub w trybie WS-Secure konwersacji z 1,3 `<wsc:SecurityContextToken>` .  
  
 Implementacja domyślna wywołuje <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> metodę przy użyciu domyślnego programu rozpoznawania tokenów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Czytnik nie jest umieszczony w <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> lub nie można go odczytać.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : byte[] * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (token, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">Strumień bajtów, który zawiera token.</param>
        <param name="tokenResolver">Program rozpoznawania tokenów do użycia.</param>
        <summary><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Odczytuje ze strumienia bajtów przy użyciu określonego mechanizmu rozwiązywania konfliktów tokenu.</summary>
        <returns><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Odczytano.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Domyślna implementacja tworzy <xref:System.Xml.XmlDictionaryReader> za pośrednictwem tokenu i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> wywołuje metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Za pośrednictwem przychodzącego <see cref="T:System.IdentityModel.Tokens.SecurityToken" />. <see cref="T:System.Xml.XmlReader" /></param>
        <param name="tokenResolver">, Który może służyć do <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />rozwiązania. <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /></param>
        <summary><see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> Odczytuje przy użyciu określonego czytnika XML i programu rozpoznawania tokenów.</summary>
        <returns>Odczytany token zabezpieczeń sesji, wystąpienie elementu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Czytnik musi być umieszczony na Feb2005 konwersacji WS-Secure lub w trybie WS-Secure konwersacji z 1,3 `<wsc:SecurityContextToken>` .  
  
 Jeśli materiał tokenu jest buforowany, jest odczytywany z pamięci podręcznej tokenów, która jest wystąpieniem <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache> klasy. W przeciwnym razie materiał tokenu jest `<wsc:SecurityContextToken>` odczytywany z elementu podrzędnego elementu, który jest określony <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> przez właściwości i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> i <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> wywoływana jest metoda, aby zdekodować plik cookie.  
  
 Aby uzyskać więcej informacji na temat sposobu serializacji tokenów sesji `<SecurityContextToken` do elementu, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> Zobacz metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="tokenResolver" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Czytnik nie jest umieszczony w <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> lub nie można go odczytać.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="member this.SetTransforms : seq&lt;System.IdentityModel.CookieTransform&gt; -&gt; unit" Usage="sessionSecurityTokenHandler.SetTransforms transforms" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformacje do użycia.</param>
        <summary>Ustawia przekształcenia, które będą stosowane do plików cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia listę przekształceń zwracanych przez <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> właściwość. Przekształcenia zostaną zastosowane w kolejności, w jakiej występują na liście podczas kodowania pliku cookie i w odwrotnej kolejności podczas dekodowania pliku cookie.  
  
> [!WARNING]
>  Jeśli parametr ma `null`wartość, wyjątek <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> zostanie wygenerowany z metody, gdy zostanie wywołana w celu kodowania lub dekodowania pliku cookie. `transforms`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TokenLifetime : TimeSpan with get, set" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia okres istnienia tokenu.</summary>
        <value>Okres istnienia tokenu. Wartość domyślna to <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie, `lifetime` Jeśli <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> [ &lt;element sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) jest określony w pliku konfiguracji, właściwość jest inicjowana do wartości atrybutu przez metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podjęto próbę ustawienia przedziału czasu, który jest mniejszy niż lub równy zero.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ tokenów, które są przetwarzane przez ten program obsługi.</summary>
        <value><see cref="T:System.Type" /> . <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przekształcenia, które zostaną zastosowane do pliku cookie.</summary>
        <value>Lista przekształceń, która zostanie zastosowana do pliku cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacje są stosowane w <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> metodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberSignature Language="F#" Value="abstract member ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.ValidateSession securityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">Token, który ma zostać sprawdzony.</param>
        <summary>Określa, czy sesja skojarzona z określonym tokenem jest nadal ważna. Ważność jest określana przez sprawdzenie <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> właściwości <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> i określonego tokenu. Wyjątek jest generowany, jeśli sesja nie jest już prawidłowa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Token <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> jest nieprawidłowy <xref:System.DateTime.UtcNow%2A>, jeśli jego właściwość jest ustawiona na wartość, która występuje później, lub jeśli jej <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> właściwość jest ustawiona na wartość, która występuje wcześniej niż <xref:System.DateTime.UtcNow%2A>.  
  
 Wywoływana z metod <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A> , aby zweryfikować sesję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="securityToken" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> Właściwość jest<see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">Właściwość tokenu jest późniejsza niż <see cref="P:System.DateTime.UtcNow" />. <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /></exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">Właściwość tokenu jest wcześniejsza niż <see cref="P:System.DateTime.UtcNow" />. <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weryfikuje token i zwraca jego oświadczenia.</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token, który ma zostać sprawdzony. Musi być możliwy do przypisania <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />z.</param>
        <summary>Sprawdza poprawność określonego tokenu i zwraca jego oświadczenia.</summary>
        <returns>Tożsamości zawarte w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A> Wywołuje metodę w celu sprawdzenia poprawności tokenu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="token" />
          <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="token" />nie można przypisać do <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />elementu.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SessionSecurityToken * string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken (token, endpointId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Token, który ma zostać sprawdzony. Musi być możliwy do przypisania <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />z.</param>
        <param name="endpointId">Identyfikator punktu końcowego, do którego odnosi się zakres tokenu.</param>
        <summary>Sprawdza poprawność określonego tokenu sesji i zwraca jego oświadczenia.</summary>
        <returns>Tożsamości zawarte w tokenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonuje kontrolę, aby upewnić się, że określony token jest objęty zakresem dla określonego identyfikatora punktu końcowego i, jeśli tak <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> , wywołuje metodę; w przeciwnym <xref:System.IdentityModel.Tokens.SecurityTokenException>razie zwraca wartość.  
  
> [!IMPORTANT]
>  Tokeny sesji, które <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> mają właściwość lub `null` wartość pustą, są uznawane za objęte zakresem globalnym. Stanowi to potencjalne ryzyko dla bezpieczeństwa. Z tego powodu należy upewnić się, że <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> właściwość jest ustawiona w tokenach sesji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="token" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="endpointId" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="token" />nie można przypisać do <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />elementu.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Właściwość określonego tokenu nie <see langword="null" /> jest pusta lub jej wartość jest inna <paramref name="endpointId" /> niż określona przez parametr. <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /></exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserializacji tokenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja serializacji tokenu do elementu WS-Secure konwersacja Feb2005 lub WS-Secure konwersacja 1,3 `<wsc:SecurityContextToken>` .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; byte[]" Usage="sessionSecurityTokenHandler.WriteToken sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token do zapisu.</param>
        <summary>Serializować określony token do tablicy bajtów.</summary>
        <returns>Tablica zakodowanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializować określony token przez utworzenie i <xref:System.IO.MemoryStream> <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> wywywoływanie metody w składniku zapisywania XML. Aby uzyskać więcej informacji, zobacz Przeciążenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sessiontoken" />jest <see langword="null" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Składnik zapisywania XML, za pomocą którego ma zostać Zserializowany token.</param>
        <param name="token">Token do serializacji. Wystąpienie elementu <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Serializować określony token przy użyciu określonego składnika zapisywania XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja serializować określony token jako element Feb2005 lub 1,3 `<wsc:SecurityContextToken>` WS-Secure konwersacja w trybie WS-Secure w zależności od wartości <xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType> właściwości. Właściwość jest serializowana `Id` jako atrybut. <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType> Właściwość jest serializowana `<Identifier>` jako element podrzędny. <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> Jeśli nie `null` , <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> Właściwośćjestserializowanajakoelement.`<Instance>` Na koniec, jeśli <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> właściwość jest `false`, cały token jest serializowany do tablicy binarnej, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> która jest przenoszona do metody, która ma zostać zaszyfrowana. Zakodowany token jest następnie zapisywana jako wartość zakodowana algorytmem Base64 do elementu i przestrzeni nazw <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> określonych <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> przez właściwości i. Jeśli właściwość ma `true`wartość, token nie jest serializowany. <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="writer" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="token" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="token" />nie można przypisać do <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />elementu.  
  
—lub— 
<see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> Token Określa wersję usługi WS-Secure Konwersacja, która nie jest obsługiwana przez program obsługi.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>

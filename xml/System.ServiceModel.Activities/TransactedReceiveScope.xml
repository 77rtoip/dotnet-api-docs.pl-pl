<Type Name="TransactedReceiveScope" FullName="System.ServiceModel.Activities.TransactedReceiveScope">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc64e617b7fa3fd7672cda21b5bb3d3e4a95717d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69157943" /></Metadata><TypeSignature Language="C#" Value="public sealed class TransactedReceiveScope : System.Activities.NativeActivity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TransactedReceiveScope extends System.Activities.NativeActivity" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Activities.TransactedReceiveScope" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TransactedReceiveScope&#xA;Inherits NativeActivity" />
  <TypeSignature Language="C++ CLI" Value="public ref class TransactedReceiveScope sealed : System::Activities::NativeActivity" />
  <TypeSignature Language="F#" Value="type TransactedReceiveScope = class&#xA;    inherit NativeActivity" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.NativeActivity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Body")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Działanie, które określa zakres okresu istnienia transakcji zainicjowanej przez odebraną wiadomość. Transakcja może zostać przetworzona do przepływu pracy w komunikacie inicjującym lub utworzona przez dyspozytora, gdy wiadomość zostanie odebrana.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Activities.TransactedReceiveScope> Działanie pozwala kontrolować okres istnienia transakcji przepływu.  
  
> [!WARNING]
>  W przypadku działania <xref:System.ServiceModel.Activities.TransactedReceiveScope> <xref:System.ServiceModel.Activities.TransactedReceiveScope> inicjującego (które zawiera <xref:System.ServiceModel.Activities.Receive> działanie z <xref:System.ServiceModel.Activities.Receive.CanCreateInstance%2A> ustawioną na `true`) transakcja jest tworzona przed rozpoczęciem wykonywania <xref:System.ServiceModel.Activities.TransactedReceiveScope> działania przez środowisko uruchomieniowe. Ta transakcja nie jest w otoczeniu warstwy działania przepływu pracy, ale jest otoczenia w podstawowych warstwach trwałości. Jeśli wykonanie przepływu pracy napotka <xref:System.Activities.Statements.Persist> działanie <xref:System.ServiceModel.Activities.TransactedReceiveScope> przed działaniem, środowisko uruchomieniowe próbuje utrzymać się w otaczającej transakcji. To zachowanie powoduje blokowanie do momentu ukończenia transakcji. Ponieważ wykonywanie przepływu pracy nie osiągnęło <xref:System.ServiceModel.Activities.TransactedReceiveScope.Body%2A> sekcji, transakcja nie może zostać zakończona. To zakleszczenie powoduje, że przepływ pracy przestaje odpowiadać do momentu przekroczenia limitu czasu transakcji. Gdy transakcja przetrwa limit czasu, nowo utworzone wystąpienie jest przerywane.  
  
> [!IMPORTANT]
>  Za każdym razem, <xref:System.ServiceModel.Activities.TransactedReceiveScope> gdy jest używany, zaleca się umieszczenie wszystkich odbiorów w <xref:System.ServiceModel.Activities.TransactedReceiveScope> przepływie pracy w ramach działań.  
  
> [!IMPORTANT]
>  Gdy użycie <xref:System.ServiceModel.Activities.TransactedReceiveScope> i komunikaty docierają w niepoprawnej kolejności, przepływ pracy zostanie przerwany przy próbie dostarczenia pierwszego komunikatu poza kolejnością. Musisz się upewnić, że przepływ pracy zawsze ma spójny punkt zatrzymania, gdy przepływ pracy jest bezczynny. Umożliwi to ponowne uruchomienie przepływu pracy z poprzedniego punktu trwałości, jeśli przepływ pracy zostanie przerwany.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.ServiceModel.Activities.TransactedReceiveScope> jak używać klasy <xref:System.Activities.Statements.Sequence> w działaniu.  
  
 [!code-csharp[TransactedReceiveScope#0](~/samples/snippets/csharp/VS_Snippets_CFX/transactedreceivescope/cs/common/codeserviceworkflow.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TransactedReceiveScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Activities.TransactedReceiveScope.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TransactedReceiveScope();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Activities.TransactedReceiveScope" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Activities.Activity Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Activity Body" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Activities.TransactedReceiveScope.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Activity ^ Body { System::Activities::Activity ^ get(); void set(System::Activities::Activity ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : System.Activities.Activity with get, set" Usage="System.ServiceModel.Activities.TransactedReceiveScope.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Activities.Activity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Activities.Activity" /> , który tworzy treść <see cref="T:System.ServiceModel.Activities.TransactedReceiveScope" /> działania.</summary>
        <value>Treść transakcyjnego zakresu odbierania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transakcja jest otaczająca cały czas trwania treści.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.ServiceModel.Activities.TransactedReceiveScope.Body%2A> jak ustawić właściwość.  
  
 [!code-csharp[TransactedReceiveScope#0](~/samples/snippets/csharp/VS_Snippets_CFX/transactedreceivescope/cs/common/codeserviceworkflow.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMetadata">
      <MemberSignature Language="C#" Value="protected override void CacheMetadata (System.Activities.NativeActivityMetadata metadata);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CacheMetadata(valuetype System.Activities.NativeActivityMetadata metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Activities.TransactedReceiveScope.CacheMetadata(System.Activities.NativeActivityMetadata)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CacheMetadata (metadata As NativeActivityMetadata)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CacheMetadata(System::Activities::NativeActivityMetadata metadata);" />
      <MemberSignature Language="F#" Value="override this.CacheMetadata : System.Activities.NativeActivityMetadata -&gt; unit" Usage="transactedReceiveScope.CacheMetadata metadata" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadata" Type="System.Activities.NativeActivityMetadata" />
      </Parameters>
      <Docs>
        <param name="metadata">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="protected override void Execute (System.Activities.NativeActivityContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Execute(class System.Activities.NativeActivityContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Activities.TransactedReceiveScope.Execute(System.Activities.NativeActivityContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Execute (context As NativeActivityContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Execute(System::Activities::NativeActivityContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.Execute : System.Activities.NativeActivityContext -&gt; unit" Usage="transactedReceiveScope.Execute context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.NativeActivityContext" />
      </Parameters>
      <Docs>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Activities.Receive Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Activities.Receive Request" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Activities.TransactedReceiveScope.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As Receive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Activities::Receive ^ Request { System::ServiceModel::Activities::Receive ^ get(); void set(System::ServiceModel::Activities::Receive ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.ServiceModel.Activities.Receive with get, set" Usage="System.ServiceModel.Activities.TransactedReceiveScope.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Activities.Receive</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ServiceModel.Activities.Receive" /> działanie skojarzone z tym <see cref="T:System.ServiceModel.Activities.TransactedReceiveScope" /> działaniem.</summary>
        <value>Działanie Receive skojarzone z zakresem odbieranych transakcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.ServiceModel.Activities.TransactedReceiveScope.Request%2A> jak ustawić właściwość.  
  
 [!code-csharp[TransactedReceiveScope#0](~/samples/snippets/csharp/VS_Snippets_CFX/transactedreceivescope/cs/common/codeserviceworkflow.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Variables">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Activities.Variable&gt; Variables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Activities.Variable&gt; Variables" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Activities.TransactedReceiveScope.Variables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Variables As Collection(Of Variable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Activities::Variable ^&gt; ^ Variables { System::Collections::ObjectModel::Collection&lt;System::Activities::Variable ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Variables : System.Collections.ObjectModel.Collection&lt;System.Activities.Variable&gt;" Usage="System.ServiceModel.Activities.TransactedReceiveScope.Variables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Activities.Variable&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Activities.Variable" /> skojarzoną z tym <see cref="T:System.ServiceModel.Activities.TransactedReceiveScope" />elementem.</summary>
        <value>Zmienne skojarzone z zakresem odbieranych transakcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.ServiceModel.Activities.TransactedReceiveScope.Variables%2A> jak ustawić właściwość.  
  
 [!code-csharp[TransactedReceiveScope#0](~/samples/snippets/csharp/VS_Snippets_CFX/transactedreceivescope/cs/common/codeserviceworkflow.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

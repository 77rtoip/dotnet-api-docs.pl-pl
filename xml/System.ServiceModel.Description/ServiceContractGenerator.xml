<Type Name="ServiceContractGenerator" FullName="System.ServiceModel.Description.ServiceContractGenerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e34052c22fe733847a63075ba1df58fa01d51f3e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39784885" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceContractGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceContractGenerator extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Description.ServiceContractGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceContractGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceContractGenerator" />
  <TypeSignature Language="F#" Value="type ServiceContractGenerator = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> Typu generuje kontraktu kodu i powiązanie konfiguracje usługi z <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> opisu obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceModel.Description.ServiceContractGenerator> twórz narzędzi lub modyfikowanie domyślnej umowy generowania procesu za pomocą <xref:System.ServiceModel.Description.IWsdlImportExtension?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje użycie <xref:System.ServiceModel.Description.ServiceContractGenerator> do konwertowania metadanych pobrany do kodu.  
  
 [!code-csharp[C_CustomWSDLExtensions#8](~/samples/snippets/csharp/VS_Snippets_CFX/c_customwsdlextensions/cs/client.cs#8)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractGenerator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> klasy z nową <see cref="T:System.CodeDom.CodeCompileUnit" /> wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractGenerator (System.CodeDom.CodeCompileUnit targetCompileUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.CodeDom.CodeCompileUnit targetCompileUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.#ctor(System.CodeDom.CodeCompileUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetCompileUnit As CodeCompileUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractGenerator(System::CodeDom::CodeCompileUnit ^ targetCompileUnit);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Description.ServiceContractGenerator : System.CodeDom.CodeCompileUnit -&gt; System.ServiceModel.Description.ServiceContractGenerator" Usage="new System.ServiceModel.Description.ServiceContractGenerator targetCompileUnit" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="targetCompileUnit" Type="System.CodeDom.CodeCompileUnit" />
      </Parameters>
      <Docs>
        <param name="targetCompileUnit">
          <see cref="T:System.CodeDom.CodeCompileUnit" /> Wystąpienia służące do generowania kodu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> klasy z określonym <see cref="T:System.CodeDom.CodeCompileUnit" /> wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractGenerator (System.Configuration.Configuration targetConfig);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Configuration.Configuration targetConfig) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.#ctor(System.Configuration.Configuration)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetConfig As Configuration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractGenerator(System::Configuration::Configuration ^ targetConfig);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Description.ServiceContractGenerator : System.Configuration.Configuration -&gt; System.ServiceModel.Description.ServiceContractGenerator" Usage="new System.ServiceModel.Description.ServiceContractGenerator targetConfig" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="targetConfig" Type="System.Configuration.Configuration" />
      </Parameters>
      <Docs>
        <param name="targetConfig">
          <see cref="T:System.Configuration.Configuration" /> Wystąpienia w celu wygenerowania konfiguracji powiązania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> klasy z określonym <see cref="T:System.Configuration.Configuration" /> wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceContractGenerator (System.CodeDom.CodeCompileUnit targetCompileUnit, System.Configuration.Configuration targetConfig);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.CodeDom.CodeCompileUnit targetCompileUnit, class System.Configuration.Configuration targetConfig) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.#ctor(System.CodeDom.CodeCompileUnit,System.Configuration.Configuration)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetCompileUnit As CodeCompileUnit, targetConfig As Configuration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceContractGenerator(System::CodeDom::CodeCompileUnit ^ targetCompileUnit, System::Configuration::Configuration ^ targetConfig);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Description.ServiceContractGenerator : System.CodeDom.CodeCompileUnit * System.Configuration.Configuration -&gt; System.ServiceModel.Description.ServiceContractGenerator" Usage="new System.ServiceModel.Description.ServiceContractGenerator (targetCompileUnit, targetConfig)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetCompileUnit" Type="System.CodeDom.CodeCompileUnit" />
        <Parameter Name="targetConfig" Type="System.Configuration.Configuration" />
      </Parameters>
      <Docs>
        <param name="targetCompileUnit">
          <see cref="T:System.CodeDom.CodeCompileUnit" /> Wystąpienia służące do generowania kodu.</param>
        <param name="targetConfig">
          <see cref="T:System.Configuration.Configuration" /> Wystąpienia w celu wygenerowania konfiguracji powiązania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ServiceModel.Description.ServiceContractGenerator" /> klasy z określonym <see cref="T:System.CodeDom.CodeCompileUnit" /> wystąpienie oraz określony <see cref="T:System.Configuration.Configuration" /> wystąpienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.Configuration.Configuration Configuration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.Configuration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Configuration As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::Configuration ^ Configuration { System::Configuration::Configuration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.Configuration.Configuration" Usage="System.ServiceModel.Description.ServiceContractGenerator.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Configuration.Configuration" /> wystąpienia, które zawiera konfiguracje wygenerowanego powiązania.</summary>
        <value>A <see cref="T:System.Configuration.Configuration" /> wystąpienia, które zawiera konfiguracje wygenerowanego punktu końcowego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Errors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.MetadataConversionError&gt; Errors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.MetadataConversionError&gt; Errors" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.Errors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Errors As Collection(Of MetadataConversionError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::MetadataConversionError ^&gt; ^ Errors { System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::MetadataConversionError ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Errors : System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.MetadataConversionError&gt;" Usage="System.ServiceModel.Description.ServiceContractGenerator.Errors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.MetadataConversionError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.ServiceModel.Description.MetadataConversionError" /> obiektów wygenerowanych podczas generowania konfiguracje kodu i punktu końcowego kontraktu usługi.</summary>
        <value>Kolekcja <see cref="T:System.ServiceModel.Description.MetadataConversionError" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tych błędów i komunikaty ostrzegawcze można używana przez narzędzia, aby wyświetlić informacje o debugowaniu dla użytkowników.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateBinding">
      <MemberSignature Language="C#" Value="public void GenerateBinding (System.ServiceModel.Channels.Binding binding, out string bindingSectionName, out string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GenerateBinding(class System.ServiceModel.Channels.Binding binding, [out] string&amp; bindingSectionName, [out] string&amp; configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.GenerateBinding(System.ServiceModel.Channels.Binding,System.String@,System.String@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GenerateBinding(System::ServiceModel::Channels::Binding ^ binding, [Runtime::InteropServices::Out] System::String ^ % bindingSectionName, [Runtime::InteropServices::Out] System::String ^ % configurationName);" />
      <MemberSignature Language="F#" Value="member this.GenerateBinding : System.ServiceModel.Channels.Binding *  *  -&gt; unit" Usage="serviceContractGenerator.GenerateBinding (binding, bindingSectionName, configurationName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="bindingSectionName" Type="System.String" RefType="out" />
        <Parameter Name="configurationName" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binding">
          <see cref="T:System.ServiceModel.Channels.Binding" /> Do użycia w celu wygenerowania konfiguracji powiązania.</param>
        <param name="bindingSectionName">Nazwa sekcji wygenerowanego wiązania.</param>
        <param name="configurationName">Nazwa konfiguracji powiązania wygenerowany.</param>
        <summary>Generuje konfigurację powiązania w określonym <see cref="T:System.ServiceModel.Channels.Binding" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa konfiguracji dla powiązania jest pobierana z <xref:System.ServiceModel.Channels.Binding.Name%2A> właściwości. Unikatowe nazwy konfiguracji powiązania są wprowadzane przez dodanie liczby całkowite na nazwę konfiguracji powiązania.  
  
 Nazwa sekcji powiązania jest nazwa sekcji konfiguracji powiązania dodaną do konfiguracji powiązania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateServiceContractType">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReference GenerateServiceContractType (System.ServiceModel.Description.ContractDescription contractDescription);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CodeDom.CodeTypeReference GenerateServiceContractType(class System.ServiceModel.Description.ContractDescription contractDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.GenerateServiceContractType(System.ServiceModel.Description.ContractDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::CodeDom::CodeTypeReference ^ GenerateServiceContractType(System::ServiceModel::Description::ContractDescription ^ contractDescription);" />
      <MemberSignature Language="F#" Value="member this.GenerateServiceContractType : System.ServiceModel.Description.ContractDescription -&gt; System.CodeDom.CodeTypeReference" Usage="serviceContractGenerator.GenerateServiceContractType contractDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contractDescription" Type="System.ServiceModel.Description.ContractDescription" />
      </Parameters>
      <Docs>
        <param name="contractDescription">
          <see cref="T:System.ServiceModel.Description.ContractDescription" /> Służące do generowania typ kontraktu.</param>
        <summary>Generuje typ kontraktu usługi z określonego <see cref="T:System.ServiceModel.Description.ContractDescription" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.CodeDom.CodeTypeReference" /> wystąpienie typu kontraktu wygenerowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inne artefakty kodu może również wygenerowanie określone za pomocą <xref:System.ServiceModel.Description.ServiceContractGenerator.Options%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReference GenerateServiceEndpoint (System.ServiceModel.Description.ServiceEndpoint endpoint, out System.ServiceModel.Configuration.ChannelEndpointElement channelElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CodeDom.CodeTypeReference GenerateServiceEndpoint(class System.ServiceModel.Description.ServiceEndpoint endpoint, [out] class System.ServiceModel.Configuration.ChannelEndpointElement&amp; channelElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Description.ServiceContractGenerator.GenerateServiceEndpoint(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Configuration.ChannelEndpointElement@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GenerateServiceEndpoint (endpoint As ServiceEndpoint, ByRef channelElement As ChannelEndpointElement) As CodeTypeReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::CodeDom::CodeTypeReference ^ GenerateServiceEndpoint(System::ServiceModel::Description::ServiceEndpoint ^ endpoint, [Runtime::InteropServices::Out] System::ServiceModel::Configuration::ChannelEndpointElement ^ % channelElement);" />
      <MemberSignature Language="F#" Value="member this.GenerateServiceEndpoint : System.ServiceModel.Description.ServiceEndpoint *  -&gt; System.CodeDom.CodeTypeReference" Usage="serviceContractGenerator.GenerateServiceEndpoint (endpoint, channelElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.ServiceModel.Description.ServiceEndpoint" />
        <Parameter Name="channelElement" Type="System.ServiceModel.Configuration.ChannelEndpointElement" RefType="out" />
      </Parameters>
      <Docs>
        <param name="endpoint">
          <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> Służące do generowania typ kontraktu.</param>
        <param name="channelElement">Konfiguracja punktu końcowego wygenerowany.</param>
        <summary>Generuje typ kontraktu usługi i konfiguracji punktu końcowego z określonego <see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.CodeDom.CodeTypeReference" /> wystąpienie typu kontraktu wygenerowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inne artefakty kodu może również wygenerowanie określone za pomocą <xref:System.ServiceModel.Description.ServiceContractGenerator.Options%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceMappings">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;string,string&gt; NamespaceMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2&lt;string, string&gt; NamespaceMappings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.NamespaceMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NamespaceMappings As Dictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;System::String ^, System::String ^&gt; ^ NamespaceMappings { System::Collections::Generic::Dictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceMappings : System.Collections.Generic.Dictionary&lt;string, string&gt;" Usage="System.ServiceModel.Description.ServiceContractGenerator.NamespaceMappings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera mapowanie z przestrzeni nazw Opis kontraktu do zarządzanej przestrzeni nazw, która jest używana podczas generowania kodu.</summary>
        <value>Mapowanie z obszary nazw Opis kontraktu, aby zarządzać przestrzeni nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia skojarzony opis przestrzeni nazw kontraktu zarządzanej przestrzeni nazw, która jest używana podczas generowania kodu.  
  
 Można użyć znaku wieloznacznego "*" jako klucza słownika do określenia zarządzanej przestrzeni nazw do użycia dla przestrzeni nazw opis, który nie jest jawnie mapowany do zarządzanej przestrzeni nazw.  
  
 Zarządzane domyślny obszar nazw jest używana, jeśli nie określono żadnego mapowania przestrzeni nazw dla konkretnego opis przestrzeni nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceContractGenerationOptions Options { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Description.ServiceContractGenerationOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.Options" />
      <MemberSignature Language="VB.NET" Value="Public Property Options As ServiceContractGenerationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::ServiceContractGenerationOptions Options { System::ServiceModel::Description::ServiceContractGenerationOptions get(); void set(System::ServiceModel::Description::ServiceContractGenerationOptions value); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.ServiceModel.Description.ServiceContractGenerationOptions with get, set" Usage="System.ServiceModel.Description.ServiceContractGenerator.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceContractGenerationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opcje generowania kodu kontraktu usługi.</summary>
        <value>Element <see cref="T:System.ServiceModel.Description.ServiceContractGenerationOptions" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie różnych opcji dla generowania kodu. To wyliczenie ma <xref:System.FlagsAttribute?displayProperty=nameWithType> atrybut, który zezwala na bitową kombinację jego wartości składowych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferencedTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;System.ServiceModel.Description.ContractDescription,Type&gt; ReferencedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2&lt;class System.ServiceModel.Description.ContractDescription, class System.Type&gt; ReferencedTypes" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferencedTypes As Dictionary(Of ContractDescription, Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;System::ServiceModel::Description::ContractDescription ^, Type ^&gt; ^ ReferencedTypes { System::Collections::Generic::Dictionary&lt;System::ServiceModel::Description::ContractDescription ^, Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReferencedTypes : System.Collections.Generic.Dictionary&lt;System.ServiceModel.Description.ContractDescription, Type&gt;" Usage="System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;System.ServiceModel.Description.ContractDescription,System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera mapowanie z kontraktu opisy typów kontraktu odwołania.</summary>
        <value>Mapowanie z kontraktu opisy typów kontraktu odwołania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kod nie jest generowany dla typów odwołania kontraktu. Zamiast tego jest używany typ odwołania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetCompileUnit">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeCompileUnit TargetCompileUnit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeCompileUnit TargetCompileUnit" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Description.ServiceContractGenerator.TargetCompileUnit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetCompileUnit As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeCompileUnit ^ TargetCompileUnit { System::CodeDom::CodeCompileUnit ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetCompileUnit : System.CodeDom.CodeCompileUnit" Usage="System.ServiceModel.Description.ServiceContractGenerator.TargetCompileUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element docelowy <see cref="T:System.CodeDom.CodeCompileUnit" /> obiektu podczas generowania kodu kontraktu usługi.</summary>
        <value>Element <see cref="T:System.CodeDom.CodeCompileUnit" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
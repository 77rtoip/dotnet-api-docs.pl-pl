<Type Name="SqlCommandBuilder" FullName="System.Data.SqlClient.SqlCommandBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f98e8b8a8201db8545a634c3df54306e188ae9f9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36680175" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlCommandBuilder : System.Data.Common.DbCommandBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlCommandBuilder extends System.Data.Common.DbCommandBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlCommandBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlCommandBuilder&#xA;Inherits DbCommandBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlCommandBuilder sealed : System::Data::Common::DbCommandBuilder" />
  <TypeSignature Language="F#" Value="type SqlCommandBuilder = class&#xA;    inherit DbCommandBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbCommandBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Automatycznie generuje polecenia pojedynczej tabeli, które są używane do zmian do uzgodnienia <see cref="T:System.Data.DataSet" /> z skojarzonej bazie danych programu SQL Server. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlDataAdapter> Nie automatycznie wygenerować instrukcji języka Transact-SQL wymagane do uzgodnienia zmian <xref:System.Data.DataSet> z skojarzonego wystąpienia programu SQL Server. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji języka Transact-SQL aktualizacje pojedynczej tabeli, jeśli ustawisz <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> właściwość <xref:System.Data.SqlClient.SqlDataAdapter>. Następnie żadnych dodatkowych instrukcji języka Transact-SQL, które nie zostały ustawione są generowane przez <xref:System.Data.SqlClient.SqlCommandBuilder>.  
  
 <xref:System.Data.SqlClient.SqlCommandBuilder> Rejestrowane jako odbiornika dla <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> zdarzenia przy każdym ustawieniu <xref:System.Data.SqlClient.SqlCommandBuilder.DataAdapter%2A> właściwości. Można skojarzyć tylko jedną <xref:System.Data.SqlClient.SqlDataAdapter> lub <xref:System.Data.SqlClient.SqlCommandBuilder> obiektu ze sobą w tym samym czasie.  
  
 Aby wygenerować instrukcje INSERT, UPDATE lub DELETE, <xref:System.Data.SqlClient.SqlCommandBuilder> używa <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> właściwość, aby automatycznie pobrać wymagane zestawu metadanych. Jeśli zmienisz <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> po ma zostały pobrane metadane, takie jak po pierwszej aktualizacji, należy wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> metody w celu zaktualizowania metadanych.  
  
 `SelectCommand` Musi także zwracać co najmniej jeden klucz podstawowy lub unikatowy kolumny. Jeśli nie są obecne, **InvalidOperation** wygenerowany wyjątek i nie są generowane polecenia.  
  
 <xref:System.Data.SqlClient.SqlCommandBuilder> Używa również <xref:System.Data.SqlClient.SqlCommand.Connection%2A>, <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A>, i <xref:System.Data.SqlClient.SqlCommand.Transaction%2A> właściwości odwołuje się <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A>. Użytkownik powinien wywoływać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> czy co najmniej jeden z tych właściwości są modyfikowane, czy <xref:System.Data.SqlClient.SqlDataAdapter.SelectCommand%2A> sam zostanie zastąpiony. W przeciwnym razie <xref:System.Data.SqlClient.SqlDataAdapter.InsertCommand%2A>, <xref:System.Data.SqlClient.SqlDataAdapter.UpdateCommand%2A>, i <xref:System.Data.SqlClient.SqlDataAdapter.DeleteCommand%2A> właściwości zachowują swoje poprzedniej wartości.  
  
 Jeśli należy wywołać <xref:System.ComponentModel.Component.Dispose%2A>, <xref:System.Data.SqlClient.SqlCommandBuilder> są oddzielone od <xref:System.Data.SqlClient.SqlDataAdapter>, i generowane polecenia nie są już używane.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.SqlClient.SqlCommand>, wraz <xref:System.Data.SqlClient.SqlDataAdapter> i <xref:System.Data.SqlClient.SqlConnection>, aby wybrać wierszy ze źródła danych. Przykład jest przekazywany z parametrów połączenia, ciąg zapytania, który jest instrukcji języka Transact-SQL SELECT i ciąg, który jest nazwa tabeli bazy danych. Następnie tworzony <xref:System.Data.SqlClient.SqlCommandBuilder>.  
  
 [!code-csharp[Classic WebData SqlCommandBuilder#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlCommandBuilder/CS/Source.cs#1)]
 [!code-vb[Classic WebData SqlCommandBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlCommandBuilder/VB/Source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlCommandBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlCommandBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlCommandBuilder (System.Data.SqlClient.SqlDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.SqlClient.SqlDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.#ctor(System.Data.SqlClient.SqlDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (adapter As SqlDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlCommandBuilder(System::Data::SqlClient::SqlDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlClient.SqlCommandBuilder : System.Data.SqlClient.SqlDataAdapter -&gt; System.Data.SqlClient.SqlCommandBuilder" Usage="new System.Data.SqlClient.SqlCommandBuilder adapter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.SqlClient.SqlDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">Nazwa <see cref="T:System.Data.SqlClient.SqlDataAdapter" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasa ze skojarzonym <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlCommandBuilder> Rejestrowane jako odbiornika dla <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> zdarzeń generowanych przez <xref:System.Data.SqlClient.SqlDataAdapter> określone w tej właściwości.  
  
 Po utworzeniu nowego wystąpienia <xref:System.Data.SqlClient.SqlCommandBuilder>, wszelkie istniejące <xref:System.Data.SqlClient.SqlCommandBuilder> skojarzony z tym <xref:System.Data.SqlClient.SqlDataAdapter> zostanie zwolniony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyParameterInfo">
      <MemberSignature Language="C#" Value="protected override void ApplyParameterInfo (System.Data.Common.DbParameter parameter, System.Data.DataRow datarow, System.Data.StatementType statementType, bool whereClause);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ApplyParameterInfo(class System.Data.Common.DbParameter parameter, class System.Data.DataRow datarow, valuetype System.Data.StatementType statementType, bool whereClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.ApplyParameterInfo(System.Data.Common.DbParameter,System.Data.DataRow,System.Data.StatementType,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ApplyParameterInfo(System::Data::Common::DbParameter ^ parameter, System::Data::DataRow ^ datarow, System::Data::StatementType statementType, bool whereClause);" />
      <MemberSignature Language="F#" Value="override this.ApplyParameterInfo : System.Data.Common.DbParameter * System.Data.DataRow * System.Data.StatementType * bool -&gt; unit" Usage="sqlCommandBuilder.ApplyParameterInfo (parameter, datarow, statementType, whereClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Data.Common.DbParameter" />
        <Parameter Name="datarow" Type="System.Data.DataRow" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="whereClause" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parameter">To be added.</param>
        <param name="datarow">To be added.</param>
        <param name="statementType">To be added.</param>
        <param name="whereClause">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogLocation">
      <MemberSignature Language="C#" Value="public override System.Data.Common.CatalogLocation CatalogLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.Common.CatalogLocation CatalogLocation" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.CatalogLocation" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CatalogLocation As CatalogLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::Common::CatalogLocation CatalogLocation { System::Data::Common::CatalogLocation get(); void set(System::Data::Common::CatalogLocation value); };" />
      <MemberSignature Language="F#" Value="member this.CatalogLocation : System.Data.Common.CatalogLocation with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.CatalogLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.CatalogLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia lub pobiera <see cref="T:System.Data.Common.CatalogLocation" /> dla wystąpienia <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasy.</summary>
        <value>A <see cref="T:System.Data.Common.CatalogLocation" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogSeparator">
      <MemberSignature Language="C#" Value="public override string CatalogSeparator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CatalogSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CatalogSeparator As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CatalogSeparator { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CatalogSeparator : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.CatalogSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ustawia lub pobiera ciąg używany jako separator katalogu dla wystąpienia <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasy.</summary>
        <value>Ciąg separatora katalogu do użytku z wystąpieniem <see cref="T:System.Data.SqlClient.SqlCommandBuilder" /> klasy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataAdapter">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlDataAdapter DataAdapter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlDataAdapter DataAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.DataAdapter" />
      <MemberSignature Language="VB.NET" Value="Public Property DataAdapter As SqlDataAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlDataAdapter ^ DataAdapter { System::Data::SqlClient::SqlDataAdapter ^ get(); void set(System::Data::SqlClient::SqlDataAdapter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataAdapter : System.Data.SqlClient.SqlDataAdapter with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.DataAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlDataAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> obiektu języka Transact-SQL, które instrukcje są generowane automatycznie.</summary>
        <value>A <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlCommandBuilder> Rejestrowane jako odbiornika dla <xref:System.Data.SqlClient.SqlDataAdapter.RowUpdating> zdarzeń generowanych przez <xref:System.Data.SqlClient.SqlDataAdapter> określone w tej właściwości.  
  
 Po utworzeniu nowego wystąpienia <xref:System.Data.SqlClient.SqlCommandBuilder>, wszelkie istniejące <xref:System.Data.SqlClient.SqlCommandBuilder> skojarzony z tym <xref:System.Data.SqlClient.SqlDataAdapter> zostanie zwolniony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveParameters">
      <MemberSignature Language="C#" Value="public static void DeriveParameters (System.Data.SqlClient.SqlCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeriveParameters(class System.Data.SqlClient.SqlCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.DeriveParameters(System.Data.SqlClient.SqlCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeriveParameters (command As SqlCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeriveParameters(System::Data::SqlClient::SqlCommand ^ command);" />
      <MemberSignature Language="F#" Value="static member DeriveParameters : System.Data.SqlClient.SqlCommand -&gt; unit" Usage="System.Data.SqlClient.SqlCommandBuilder.DeriveParameters command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.SqlClient.SqlCommand" />
      </Parameters>
      <Docs>
        <param name="command">
          <see cref="T:System.Data.SqlClient.SqlCommand" /> Odwołuje się do procedury składowanej, z którego ma pochodzić informacje o parametrach. Pochodne parametry są dodawane do <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" /> kolekcji <see cref="T:System.Data.SqlClient.SqlCommand" />.</param>
        <summary>Pobiera informacje o parametrach z procedury składowanej określone w <see cref="T:System.Data.SqlClient.SqlCommand" /> i wypełnia <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" /> kolekcji z określonym <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DeriveParameters` zastępuje wszelkie istniejące informacje o parametrach dla `SqlDbCommand`.  
  
 `DeriveParameters` wymaga dodatkowych wywołania do bazy danych w celu uzyskania informacji. Jeśli informacje o parametrach jest znana wcześniej, jest bardziej wydajne, aby wypełnić kolekcji parametrów, jawnie ustawiając informacje.  
  
 Można używać tylko `DeriveParameters` z procedur składowanych. Nie można użyć `DeriveParameters` o rozszerzonych procedur składowanych. Nie można użyć `DeriveParameters` do wypełnienia <xref:System.Data.SqlClient.SqlParameterCollection> z dowolnego instrukcje języka Transact-SQL, na przykład sparametryzowanych instrukcji SELECT.  
  
 Aby uzyskać więcej informacji, zobacz [konfigurowania parametrów i typ danych parametru](~/docs/framework/data/adonet/configuring-parameters-and-parameter-data-types.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tekst polecenia nie jest nazwą prawidłową procedury składowanej.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDeleteCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia usunięć w bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcje SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetDeleteCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetDeleteCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeleteCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetDeleteCommand();" />
      <MemberSignature Language="F#" Value="override this.GetDeleteCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetDeleteCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia usunięć w bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia usunięć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcje SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetDeleteCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetDeleteCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDeleteCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetDeleteCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetDeleteCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetDeleteCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Jeśli <see langword="true" />, generowanie nazwy parametrów, jeśli to możliwe pasujące nazwy kolumny. Jeśli <see langword="false" />, generowanie @p1, @p2i tak dalej.</param>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagany do wykonania usunięć w bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagany do wykonania usunięć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcje SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetDeleteCommand%2A>.  
  
 Domyślnie podczas generowania nazwy parametrów, jest użycie @p1, @p2, i tak dalej dla różnych parametrów. Przekazywanie `true` dla `useColumnsForParameterNames` parametr umożliwia wymuszenie <xref:System.Data.OleDb.OleDbCommandBuilder> wygenerować parametrów na podstawie nazwy kolumny. To się powiedzie, tylko wtedy, gdy są spełnione następujące warunki:  
  
-   <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> Zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji została określona, a jego długość jest równa lub większa niż nazwa parametru wygenerowany.  
  
-   Nazwa parametru wygenerowanego spełnia kryteria określone w <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji wyrażenia regularnego.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> określono kolekcji.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInsertCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagane do przeprowadzenia operacji wstawienia na bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetInsertCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetInsertCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetInsertCommand();" />
      <MemberSignature Language="F#" Value="override this.GetInsertCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetInsertCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia operacji wstawienia na bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia operacji wstawienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetInsertCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetInsertCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetInsertCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetInsertCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetInsertCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Jeśli <see langword="true" />, generowanie nazwy parametrów, jeśli to możliwe pasujące nazwy kolumny. Jeśli <see langword="false" />, generowanie @p1, @p2i tak dalej.</param>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagane do przeprowadzenia operacji wstawienia na bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagany do wykonania operacji wstawienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetInsertCommand%2A>.  
  
 Domyślnie podczas generowania nazwy parametrów, jest użycie @p1, @p2, i tak dalej dla różnych parametrów. Przekazywanie `true` dla `useColumnsForParameterNames` parametr umożliwia wymuszenie <xref:System.Data.OleDb.OleDbCommandBuilder> wygenerować parametrów na podstawie nazwy kolumny. To się powiedzie, tylko wtedy, gdy są spełnione następujące warunki:  
  
-   <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> Zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji została określona, a jego długość jest równa lub większa niż nazwa parametru wygenerowany.  
  
-   Nazwa parametru wygenerowanego spełnia kryteria określone w <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji wyrażenia regularnego.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> określono kolekcji.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterName">
      <MemberSignature Language="C#" Value="protected override string GetParameterName (int parameterOrdinal);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterName(int32 parameterOrdinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterName (parameterOrdinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterName(int parameterOrdinal);" />
      <MemberSignature Language="F#" Value="override this.GetParameterName : int -&gt; string" Usage="sqlCommandBuilder.GetParameterName parameterOrdinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterOrdinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterOrdinal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterName">
      <MemberSignature Language="C#" Value="protected override string GetParameterName (string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterName(string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterName (parameterName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterName(System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="override this.GetParameterName : string -&gt; string" Usage="sqlCommandBuilder.GetParameterName parameterName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parameterName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameterPlaceholder">
      <MemberSignature Language="C#" Value="protected override string GetParameterPlaceholder (int parameterOrdinal);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string GetParameterPlaceholder(int32 parameterOrdinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetParameterPlaceholder(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetParameterPlaceholder (parameterOrdinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::String ^ GetParameterPlaceholder(int parameterOrdinal);" />
      <MemberSignature Language="F#" Value="override this.GetParameterPlaceholder : int -&gt; string" Usage="sqlCommandBuilder.GetParameterPlaceholder parameterOrdinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterOrdinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterOrdinal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="protected override System.Data.DataTable GetSchemaTable (System.Data.Common.DbCommand srcCommand);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.DataTable GetSchemaTable(class System.Data.Common.DbCommand srcCommand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetSchemaTable(System.Data.Common.DbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetSchemaTable (srcCommand As DbCommand) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::DataTable ^ GetSchemaTable(System::Data::Common::DbCommand ^ srcCommand);" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : System.Data.Common.DbCommand -&gt; System.Data.DataTable" Usage="sqlCommandBuilder.GetSchemaTable srcCommand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcCommand" Type="System.Data.Common.DbCommand" />
      </Parameters>
      <Docs>
        <param name="srcCommand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUpdateCommand">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia aktualizacji w bazie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetUpdateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetUpdateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpdateCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetUpdateCommand();" />
      <MemberSignature Language="F#" Value="override this.GetUpdateCommand : unit -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetUpdateCommand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia aktualizacji w bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt, który jest wymagane do przeprowadzenia aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand GetUpdateCommand (bool useColumnsForParameterNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand GetUpdateCommand(bool useColumnsForParameterNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpdateCommand (useColumnsForParameterNames As Boolean) As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ GetUpdateCommand(bool useColumnsForParameterNames);" />
      <MemberSignature Language="F#" Value="override this.GetUpdateCommand : bool -&gt; System.Data.SqlClient.SqlCommand" Usage="sqlCommandBuilder.GetUpdateCommand useColumnsForParameterNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="useColumnsForParameterNames" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="useColumnsForParameterNames">Jeśli <see langword="true" />, generowanie nazwy parametrów, jeśli to możliwe pasujące nazwy kolumny. Jeśli <see langword="false" />, generowanie @p1, @p2i tak dalej.</param>
        <summary>Pobiera automatycznie generowanych <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia aktualizacji w bazie danych.</summary>
        <returns>Automatycznie wygenerowany <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu wymagane do przeprowadzenia aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja może użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> celów metoda informacyjne lub dotyczące rozwiązywania problemów, ponieważ zwraca ono <xref:System.Data.SqlClient.SqlCommand> obiektu do wykonania.  
  
 Można również użyć <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> jako podstawa zmodyfikowane polecenia. Na przykład może wywołać <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> i zmodyfikuj <xref:System.Data.SqlClient.SqlCommand.CommandTimeout%2A> wartość, a następnie jawnie ustawione który na <xref:System.Data.SqlClient.SqlDataAdapter>.  
  
 Po instrukcji języka Transact-SQL najpierw jest generowany, aplikacja musi jawnie wywołać <xref:System.Data.Common.DbCommandBuilder.RefreshSchema%2A> zmiana instrukcji w dowolny sposób. W przeciwnym razie <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A> będą nadal używać informacji z poprzednich instrukcji, które mogą być nieprawidłowe. Instrukcji języka Transact-SQL najpierw są generowane, gdy aplikacja wywołuje albo <xref:System.Data.Common.DbDataAdapter.Update%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.GetUpdateCommand%2A>.  
  
 Domyślnie podczas generowania nazwy parametrów, jest użycie @p1, @p2, i tak dalej dla różnych parametrów. Przekazywanie `true` dla `useColumnsForParameterNames` parametr umożliwia wymuszenie <xref:System.Data.OleDb.OleDbCommandBuilder> wygenerować parametrów na podstawie nazwy kolumny. To się powiedzie, tylko wtedy, gdy są spełnione następujące warunki:  
  
-   <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNameMaxLength> Zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji została określona, a jego długość jest równa lub większa niż nazwa parametru wygenerowany.  
  
-   Nazwa parametru wygenerowanego spełnia kryteria określone w <xref:System.Data.Common.DbMetaDataColumnNames.ParameterNamePattern> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> kolekcji wyrażenia regularnego.  
  
-   A <xref:System.Data.Common.DbMetaDataColumnNames.ParameterMarkerFormat> zwrócony z **GetSchema** metody wywołania i znaleźć w <xref:System.Data.Common.DbMetaDataCollectionNames.DataSourceInformation> określono kolekcji.  
  
 Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand InitializeCommand (System.Data.Common.DbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand InitializeCommand(class System.Data.Common.DbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.InitializeCommand(System.Data.Common.DbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function InitializeCommand (command As DbCommand) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ InitializeCommand(System::Data::Common::DbCommand ^ command);" />
      <MemberSignature Language="F#" Value="override this.InitializeCommand : System.Data.Common.DbCommand -&gt; System.Data.Common.DbCommand" Usage="sqlCommandBuilder.InitializeCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.Common.DbCommand" />
      </Parameters>
      <Docs>
        <param name="command">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuoteIdentifier">
      <MemberSignature Language="C#" Value="public override string QuoteIdentifier (string unquotedIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string QuoteIdentifier(string unquotedIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.QuoteIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function QuoteIdentifier (unquotedIdentifier As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ QuoteIdentifier(System::String ^ unquotedIdentifier);" />
      <MemberSignature Language="F#" Value="override this.QuoteIdentifier : string -&gt; string" Usage="sqlCommandBuilder.QuoteIdentifier unquotedIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unquotedIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unquotedIdentifier">Oryginalny identyfikator bez cudzysłowów.</param>
        <summary>Podany identyfikator bez cudzysłowów w przypadku katalogu poprawne zwraca wartość prawidłowego formularza tego identyfikatora w cudzysłowach. W tym poprawnie anulowanie wszelkie cudzysłowy osadzony w identyfikatorze.</summary>
        <returns>Identyfikator wersja ujętego w cudzysłów. Osadzone cudzysłowy wewnątrz identyfikator poprawnie będą miały zmienione znaczenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuotePrefix">
      <MemberSignature Language="C#" Value="public override string QuotePrefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QuotePrefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property QuotePrefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ QuotePrefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QuotePrefix : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.QuotePrefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia początkową znaku lub znaków do użycia podczas określania obiektów bazy danych programu SQL Server, takich jak tabele lub kolumny, których nazwy zawierają znaki, takie jak spacje lub zastrzeżone tokenów.</summary>
        <value>Początkowy znak lub znaków do użycia. Wartość domyślna to ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Mimo że nie można zmienić <xref:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix%2A> właściwości po instrukcji insert, update lub delete wygenerowaniu polecenia, można zmienić ich ustawienia po wywołaniu `Update` metody element DataAdapter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można zmienić tej właściwości po INSERT, UPDATE, lub wygenerowaniu polecenia DELETE.</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteSuffix">
      <MemberSignature Language="C#" Value="public override string QuoteSuffix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QuoteSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property QuoteSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ QuoteSuffix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QuoteSuffix : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak końcowy lub znaków do użycia podczas określania obiektów bazy danych programu SQL Server, takich jak tabele lub kolumny, których nazwy zawierają znaki, takie jak spacje lub zastrzeżone tokenów.</summary>
        <value>Końcowy znak lub znaków do użycia. Wartość domyślna to ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Mimo że nie można zmienić <xref:System.Data.SqlClient.SqlCommandBuilder.QuotePrefix%2A> lub <xref:System.Data.SqlClient.SqlCommandBuilder.QuoteSuffix%2A> właściwości po instrukcji insert, update lub delete operacji został wygenerowany, można zmienić ich ustawienia po wywołaniu `Update` metody element DataAdapter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można zmienić tej właściwości, po wygenerowaniu insert, update lub polecenia delete.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaSeparator">
      <MemberSignature Language="C#" Value="public override string SchemaSeparator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SchemaSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SchemaSeparator As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SchemaSeparator { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSeparator : string with get, set" Usage="System.Data.SqlClient.SqlCommandBuilder.SchemaSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znak używany dla tego separatora między identyfikatora schematu i inne identyfikatory.</summary>
        <value>Znak, który ma być używany jako separator schematu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogólnie rzecz biorąc serwerów baz danych wskazuje schematu dla identyfikatora oddzielając nazwy schematu z identyfikatora niektórych znakiem. Na przykład program SQL Server używa okres, tworzenie pełne identyfikatory jak Person.CustomerName, gdzie nazwa schematu jest "Osoba" i "CustomerName" jest identyfikatorem. Ustawienie tej właściwości umożliwia deweloperom zmienić to zachowanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRowUpdatingHandler">
      <MemberSignature Language="C#" Value="protected override void SetRowUpdatingHandler (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetRowUpdatingHandler(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.SetRowUpdatingHandler(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetRowUpdatingHandler (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetRowUpdatingHandler(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="override this.SetRowUpdatingHandler : System.Data.Common.DbDataAdapter -&gt; unit" Usage="sqlCommandBuilder.SetRowUpdatingHandler adapter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnquoteIdentifier">
      <MemberSignature Language="C#" Value="public override string UnquoteIdentifier (string quotedIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string UnquoteIdentifier(string quotedIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlCommandBuilder.UnquoteIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function UnquoteIdentifier (quotedIdentifier As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ UnquoteIdentifier(System::String ^ quotedIdentifier);" />
      <MemberSignature Language="F#" Value="override this.UnquoteIdentifier : string -&gt; string" Usage="sqlCommandBuilder.UnquoteIdentifier quotedIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="quotedIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="quotedIdentifier">Identyfikator, który będzie miał jego osadzone cudzysłowy usunięte.</param>
        <summary>Podany identyfikatora ujętego w cudzysłów zwraca w postaci bez cudzysłowu poprawny identyfikator. W tym poprawnie unescaping wszelkie cudzysłowy osadzony w identyfikatorze.</summary>
        <returns>Identyfikator bez cudzysłowów cudzysłowem osadzonym odpowiednio niecytowana.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="SqlConnection" FullName="System.Data.SqlClient.SqlConnection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13a8805b62cac7e4548ac44737cd6c5c1dc3578c" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452440" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlConnection : System.Data.Common.DbConnection, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlConnection extends System.Data.Common.DbConnection implements class System.Data.IDbConnection, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlClient.SqlConnection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlConnection&#xA;Inherits DbConnection&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlConnection sealed : System::Data::Common::DbConnection, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.SqlClient</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbConnection</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("InfoMessage")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje połączenie z bazą danych programu SQL Server. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.SqlClient.SqlConnection> obiekt reprezentuje unikatowy sesji ze źródłem danych programu SQL Server. W systemie klienta i serwera bazy danych jest odpowiednikiem połączenie sieciowe z serwerem. <xref:System.Data.SqlClient.SqlConnection> jest używany razem z <xref:System.Data.SqlClient.SqlDataAdapter> i <xref:System.Data.SqlClient.SqlCommand> w celu zwiększenia wydajności podczas nawiązywania połączenia z bazą danych programu Microsoft SQL Server. Dla wszystkich innych produktów programu SQL Server i innych źródeł danych OLE DB, obsługiwane, należy użyć <xref:System.Data.OleDb.OleDbConnection>.  
  
 Podczas tworzenia wystąpienia <xref:System.Data.SqlClient.SqlConnection>, wszystkie właściwości są ustawione na wartości początkowe. Aby uzyskać listę tych wartości, zobacz <xref:System.Data.SqlClient.SqlConnection> konstruktora.  
  
 Zobacz <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> listę słów kluczowych w parametrach połączenia.  
  
 Jeśli <xref:System.Data.SqlClient.SqlConnection> umieszczane poza zakres, nie będzie można go zamknąć. W związku z tym należy jawnie zamknąć połączenie przez wywołanie metody `Close` lub `Dispose`. `Close` i `Dispose` działają tak samo. Jeśli pula połączeń wartość `Pooling` ustawiono `true` lub `yes`, połączenie znajdujące się poniżej jest przywracane do puli połączeń. Z drugiej strony Jeśli `Pooling` ustawiono `false` lub `no`, połączenie z serwerem podstawowe faktycznie jest zamknięty.  
  
> [!NOTE]
>  Zdarzenia logowania i wylogowywania nie będą zgłaszane na serwerze gdy połączenie jest pobranych z lub zwrócony do puli połączeń, ponieważ połączenie nie jest w rzeczywistości zamknięte zwracanie do puli połączeń. Aby uzyskać więcej informacji, zobacz [programu SQL Server połączenia buforowanie (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
 Aby upewnić się, że połączenia są zawsze zamknięte, Otwórz połączenie wewnątrz `using` zablokować, jak pokazano w następującego fragmentu kodu. Daje to gwarancję, że połączenie jest zamknięte automatycznie, gdy kod jest kończona bloku.  
  
```vb  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    ' Do work here; connection closed on following line.  
End Using  
  
```  
  
```csharp  
using (SqlConnection connection = new SqlConnection(connectionString))  
    {  
        connection.Open();  
        // Do work here; connection closed on following line.  
    }  
```  
  
> [!NOTE]
>  Aby wdrożyć aplikacje wysokiej wydajności, należy użyć puli połączeń. Korzystając z dostawcy danych programu .NET Framework dla programu SQL Server, nie trzeba włączyć puli połączeń, ponieważ dostawca zarządza to automatycznie, mimo że niektóre ustawienia można zmodyfikować. Aby uzyskać więcej informacji, zobacz [programu SQL Server połączenia buforowanie (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
 Jeśli <xref:System.Data.SqlClient.SqlException> jest generowany przez wykonanie metody <xref:System.Data.SqlClient.SqlCommand>, <xref:System.Data.SqlClient.SqlConnection> pozostaje otwarty, gdy poziom ważności jest 19 lub mniej. Jeśli poziom ważności jest 20 lub większą, serwer zwykle zamyka <xref:System.Data.SqlClient.SqlConnection>. Jednak użytkownik może ponownie otworzyć połączenie i kontynuować.  
  
 Aplikacja, która tworzy wystąpienie <xref:System.Data.SqlClient.SqlConnection> obiektu może wymagać wszystkich bezpośrednich i pośrednich wywołującym ma wystarczających uprawnień do kodu, ustawiając żądania kontroli zabezpieczeń deklaratywne lub konieczne. <xref:System.Data.SqlClient.SqlConnection> sprawia, że żądania kontroli zabezpieczeń przy użyciu <xref:System.Data.SqlClient.SqlClientPermission> obiektu. Użytkownicy można sprawdzić, czy ich kod jest wystarczające uprawnienia za pomocą <xref:System.Data.SqlClient.SqlClientPermissionAttribute> obiektu. Użytkownicy i Administratorzy mogą również używać [Caspol.exe (narzędzie zasad zabezpieczenia dostępu kodu)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md) Aby zmodyfikować zasady zabezpieczeń na poziomie komputera, użytkownika i enterprise. Aby uzyskać więcej informacji, zobacz [zabezpieczeń](http://msdn.microsoft.com/library/9a9621d7-8883-4a4f-a874-65e8e09e20a6). Na przykład pokazuje sposób użycia żądania kontroli zabezpieczeń, zobacz [zabezpieczenia dostępu kodu i ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 Aby uzyskać więcej informacji na temat obsługi komunikaty ostrzegawcze i informacyjne z serwera, zobacz [zdarzeń połączenia](~/docs/framework/data/adonet/connection-events.md). Błędy aparatu programu SQL Server i komunikaty o błędach są udokumentowane w dokumentacji SQL Server — książki Online.  
  
> [!CAUTION]
>  Zamiast pamięci współużytkowanej, możesz wymusić TCP. Możesz to zrobić, prefiksu tcp: Nazwa serwera w połączeniu ciąg lub użyć localhost.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlCommand> i <xref:System.Data.SqlClient.SqlConnection>. <xref:System.Data.SqlClient.SqlConnection> Jest otwarte, a następnie ustaw jako <xref:System.Data.SqlClient.SqlCommand.Connection%2A> dla <xref:System.Data.SqlClient.SqlCommand>. Przykład wywołuje <xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A>. Aby to osiągnąć, <xref:System.Data.SqlClient.SqlCommand.ExecuteNonQuery%2A> jest przekazywany z parametrów połączenia i ciągu zapytania, który jest [!INCLUDE[tsql](~/includes/tsql-md.md)] instrukcji INSERT. Połączenie jest zamykane automatycznie, gdy kod jest kończona przy użyciu bloku.  
  
 [!code-csharp[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlCommand.ExecuteNonQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlCommand.ExecuteNonQuery Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlConnection" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlConnection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nowe wystąpienie klasy <xref:System.Data.SqlClient.SqlConnection> utworzeniu odczytu/zapisu właściwości są ustawione na następujące wartości początkowej, o ile nie są specjalnie ustawiane przy użyciu ich skojarzone słów kluczowych w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwości.  
  
|Właściwości|Wartość początkowa|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|Pusty ciąg ("")|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|Pusty ciąg ("")|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|Pusty ciąg ("")|  
  
 Wartości tych właściwości można zmienić tylko za pomocą <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwości. <xref:System.Data.SqlClient.SqlConnectionStringBuilder> Klasa udostępnia funkcje tworzenia i zarządzania nimi zawartość parametry połączenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy i otwiera <xref:System.Data.SqlClient.SqlConnection>.  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Połączenie używane do bazy danych programu SQL Server.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlConnection" /> klasy, gdy ciąg, który zawiera ciąg połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nowe wystąpienie klasy <xref:System.Data.SqlClient.SqlConnection> utworzeniu odczytu/zapisu właściwości są ustawione na następujące wartości początkowej, o ile nie są specjalnie ustawiane przy użyciu ich skojarzone słów kluczowych w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwości.  
  
|Właściwości|Wartość początkowa|  
|----------------|-------------------|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>|`connectionString`|  
|<xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A>|15|  
|<xref:System.Data.SqlClient.SqlConnection.Database%2A>|Pusty ciąg ("")|  
|<xref:System.Data.SqlClient.SqlConnection.DataSource%2A>|Pusty ciąg ("")|  
  
 Wartości tych właściwości można zmienić tylko za pomocą <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwości. <xref:System.Data.SqlClient.SqlConnection> Klasa udostępnia funkcje tworzenia i zarządzania nimi zawartość parametry połączenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy i otwiera <xref:System.Data.SqlClient.SqlConnection>.  
  
 [!code-csharp[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.SqlConnection1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.SqlConnection1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential credential) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;xamarinandroid-7.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, credential As SqlCredential)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public SqlConnection (string connectionString, System.Data.SqlClient.SqlCredential cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString, class System.Data.SqlClient.SqlCredential cred) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String, cred As SqlCredential)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlConnection(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ cred);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" Index="0" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="cred" Type="System.Data.SqlClient.SqlCredential" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="connectionString">Ciąg połączenia, który nie używa żadnego z następujących słów kluczowych ciąg połączenia: <see langword="Integrated Security = true" />, <see langword="UserId" />, lub <see langword="Password" />; lub które nie używają <see langword="ContextConnection = true" />.</param>
        <param name="credential">To be added.</param>
        <param name="cred">To be added.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlClient.SqlConnection" /> klasy podany ciąg połączenia, które nie są używane <see langword="Integrated Security = true" /> i <see cref="T:System.Data.SqlClient.SqlCredential" /> obiekt, który zawiera identyfikator użytkownika i hasło.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessToken">
      <MemberSignature Language="C#" Value="public string AccessToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessToken" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.AccessToken" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessToken As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessToken { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia token dostępu dla połączenia.</summary>
        <value>Token dostępu dla połączenia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDbTransaction">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbTransaction BeginDbTransaction (System.Data.IsolationLevel isolationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbTransaction BeginDbTransaction(valuetype System.Data.IsolationLevel isolationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginDbTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbTransaction ^ BeginDbTransaction(System::Data::IsolationLevel isolationLevel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isolationLevel" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="isolationLevel">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTransaction">
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia transakcji bazy danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction () As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia transakcji bazy danych.</summary>
        <returns>Obiekt reprezentujący nowej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie mapuje do wdrożenia programu SQL Server BEGIN TRANSACTION.  
  
 Należy jawnie przekazać ani wycofać, przy użyciu transakcji <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> lub <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody. Aby poprawnie wykonuje dostawcy danych programu .NET Framework dla modelu zarządzania transakcji programu SQL Server, należy unikać innych modeli zarządzania transakcji, takie jak programu SQL Server.  
  
> [!NOTE]
>  Jeśli nie określisz poziom izolacji, używany jest domyślny poziom izolacji. Określa poziom izolacji z <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> metody, użyj przeciążenia, które przyjmuje `iso` parametr (<xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>). Poziom izolacji dla transakcji będzie się powtarzać, po zakończeniu transakcji i do momentu połączenia jest zamknięty lub usunięty. Ustawienie poziomu izolacji **migawki** w bazie danych, których nie włączono poziom izolacji migawki nie zgłasza wyjątek. Transakcja zostanie zakończony, przy użyciu poziomu izolacji domyślne.  
  
> [!CAUTION]
>  Jeśli transakcja nie została uruchomiona i poziom 16 lub wyższej błąd występuje na serwerze, transakcja zostanie nie wycofana do <xref:System.Data.SqlClient.SqlDataReader.Read%2A> wywołania metody. Żaden wyjątek jest zgłaszany **ExecuteReader**.  
  
> [!CAUTION]
>  Gdy kwerenda zwraca dużą ilość danych i wywołania `BeginTransaction`, <xref:System.Data.SqlClient.SqlException> jest generowany, gdy program SQL Server nie zezwala na równoległych transakcji przy użyciu MARS. Aby uniknąć tego problemu, zawsze skojarzyć transakcji z polecenia i/lub połączenie przed żadnych czytników są otwarte.  
  
 Aby uzyskać więcej informacji o transakcji programu SQL Server zobacz "Jawnych transakcji" i "kodowania wydajne" w dokumentacji SQL Server — książki Online.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i <xref:System.Data.SqlClient.SqlTransaction>. Ponadto przedstawiono sposób użycia <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, i <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Równoległych transakcji nie są dozwolone w przypadku korzystania z wielu aktywnych zestawów wyników (MARS).</exception>
        <exception cref="T:System.InvalidOperationException">Transakcje równoległe są nieobsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
      </Parameters>
      <Docs>
        <param name="iso">Poziom izolacji transakcji powinien uruchamiania.</param>
        <summary>Rozpoczyna się poziom izolacji określony od transakcji bazy danych.</summary>
        <returns>Obiekt reprezentujący nowej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie mapuje do wdrożenia programu SQL Server BEGIN TRANSACTION.  
  
 Należy jawnie przekazać ani wycofać, przy użyciu transakcji <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> lub <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody. Aby poprawnie wykonuje dostawcy danych programu .NET Framework dla modelu zarządzania transakcji programu SQL Server, należy unikać innych modeli zarządzania transakcji, takie jak programu SQL Server.  
  
> [!NOTE]
>  Po zatwierdzeniu lub wycofana transakcji poziom izolacji transakcji utrzymuje się przez wszystkie kolejne polecenia, które są w trybie autozatwierdzania (Domyślnie program SQL Server). To może spowodować nieoczekiwane wyniki, takie jak poziom izolacji REPEATABLE READ utrwalanie i blokowania innych użytkowników poza wierszem. Aby zresetować poziom izolacji domyślne (READ COMMITTED), należy wykonać [!INCLUDE[tsql](~/includes/tsql-md.md)] USTAWIĆ transakcji izolacji poziom READ COMMITTED instrukcji lub wywołanie <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType> a następnie natychmiast przez <xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>. Aby uzyskać więcej informacji na poziomie izolacji programu SQL Server zobacz "Izolacji poziomy w aparat bazy danych" w dokumentacji SQL Server — książki Online.  
  
 Aby uzyskać więcej informacji o transakcji programu SQL Server zobacz "Jawnych transakcji" i "kodowania wydajne" w dokumentacji SQL Server — książki Online.  
  
> [!CAUTION]
>  Gdy kwerenda zwraca dużą ilość danych i wywołania `BeginTransaction`, <xref:System.Data.SqlClient.SqlException> jest generowany, gdy program SQL Server nie zezwala na równoległych transakcji przy użyciu MARS. Aby uniknąć tego problemu, zawsze skojarzyć transakcji z polecenia i/lub połączenie przed żadnych czytników są otwarte.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i <xref:System.Data.SqlClient.SqlTransaction>. Ponadto przedstawiono sposób użycia <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, i <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Równoległych transakcji nie są dozwolone w przypadku korzystania z wielu aktywnych zestawów wyników (MARS).</exception>
        <exception cref="T:System.InvalidOperationException">Transakcje równoległe są nieobsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::String ^ transactionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="transactionName">Nazwa transakcji.</param>
        <summary>Uruchomienie transakcji bazy danych o nazwie określonej transakcji.</summary>
        <returns>Obiekt reprezentujący nowej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie mapuje do wdrożenia programu SQL Server BEGIN TRANSACTION.  
  
 Długość `transactionName` parametru nie może przekraczać 32 znaków; w przeciwnym razie zwracany wyjątek.  
  
 Wartość w `transactionName` parametr może zostać użyty w wywołaniach nowsze <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> i w `savePoint` parametr <xref:System.Data.SqlClient.SqlTransaction.Save%2A> metody.  
  
 Należy jawnie przekazać ani wycofać, przy użyciu transakcji <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> lub <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody. Aby upewnić się, że [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] dostawcy danych dla modelu zarządzania transakcji programu SQL Server wykonuje się poprawnie, należy unikać innych modeli zarządzania transakcji, takiej jak programu SQL Server.  
  
 Aby uzyskać więcej informacji o transakcji programu SQL Server zobacz "Jawnych transakcji" i "kodowania wydajne" w dokumentacji SQL Server — książki Online.  
  
> [!CAUTION]
>  Gdy kwerenda zwraca dużą ilość danych i wywołania `BeginTransaction`, <xref:System.Data.SqlClient.SqlException> jest generowany, gdy program SQL Server nie zezwala na równoległych transakcji przy użyciu MARS. Aby uniknąć tego problemu, zawsze skojarzyć transakcji z polecenia i/lub połączenie przed żadnych czytników są otwarte.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i <xref:System.Data.SqlClient.SqlTransaction>. Ponadto przedstawiono sposób użycia <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, i <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Równoległych transakcji nie są dozwolone w przypadku korzystania z wielu aktywnych zestawów wyników (MARS).</exception>
        <exception cref="T:System.InvalidOperationException">Transakcje równoległe są nieobsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginTransaction">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlTransaction BeginTransaction (System.Data.IsolationLevel iso, string transactionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlTransaction BeginTransaction(valuetype System.Data.IsolationLevel iso, string transactionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.BeginTransaction(System.Data.IsolationLevel,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTransaction (iso As IsolationLevel, transactionName As String) As SqlTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlTransaction ^ BeginTransaction(System::Data::IsolationLevel iso, System::String ^ transactionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlTransaction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iso" Type="System.Data.IsolationLevel" />
        <Parameter Name="transactionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="iso">Poziom izolacji transakcji powinien uruchamiania.</param>
        <param name="transactionName">Nazwa transakcji.</param>
        <summary>Rozpoczyna się od nazwy transakcji i poziom izolacji określony transakcji bazy danych.</summary>
        <returns>Obiekt reprezentujący nowej transakcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie mapuje do wdrożenia programu SQL Server BEGIN TRANSACTION.  
  
 Wartość w `transactionName` parametr może zostać użyty w wywołaniach nowsze <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> i w `savePoint` parametr <xref:System.Data.SqlClient.SqlTransaction.Save%2A> metody.  
  
 Należy jawnie przekazać ani wycofać, przy użyciu transakcji <xref:System.Data.SqlClient.SqlTransaction.Commit%2A> lub <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody. Aby poprawnie wykonuje model zarządzania transakcji programu SQL Server, należy unikać innych modeli zarządzania transakcji, takie jak programu SQL Server.  
  
> [!NOTE]
>  Po zatwierdzeniu lub wycofana transakcji poziom izolacji transakcji utrzymuje się przez wszystkie kolejne polecenia, które są w trybie autozatwierdzania (Domyślnie program SQL Server). To może spowodować nieoczekiwane wyniki, takie jak poziom izolacji REPEATABLE READ utrwalanie i blokowania innych użytkowników poza wierszem. Aby zresetować poziom izolacji domyślne (READ COMMITTED), należy wykonać [!INCLUDE[tsql](~/includes/tsql-md.md)] USTAWIĆ transakcji izolacji poziom READ COMMITTED instrukcji lub wywołanie <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A?displayProperty=nameWithType> a następnie natychmiast przez <xref:System.Data.SqlClient.SqlTransaction.Commit%2A?displayProperty=nameWithType>. Aby uzyskać więcej informacji na poziomie izolacji programu SQL Server zobacz "Izolacji poziomy w aparat bazy danych" w dokumentacji SQL Server — książki Online.  
  
 Aby uzyskać więcej informacji o transakcji programu SQL Server zobacz "Jawnych transakcji" i "kodowania wydajne" w dokumentacji SQL Server — książki Online.  
  
> [!CAUTION]
>  Gdy kwerenda zwraca dużą ilość danych i wywołania `BeginTransaction`, <xref:System.Data.SqlClient.SqlException> jest generowany, gdy program SQL Server nie zezwala na równoległych transakcji przy użyciu MARS. Aby uniknąć tego problemu, zawsze skojarzyć transakcji z polecenia i/lub połączenie przed żadnych czytników są otwarte.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i <xref:System.Data.SqlClient.SqlTransaction>. Ponadto przedstawiono sposób użycia <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>, <xref:System.Data.SqlClient.SqlTransaction.Commit%2A>, i <xref:System.Data.SqlClient.SqlTransaction.Rollback%2A> metody.  
  
 [!code-csharp[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.BeginTransaction3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.BeginTransaction3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Równoległych transakcji nie są dozwolone w przypadku korzystania z wielu aktywnych zestawów wyników (MARS).</exception>
        <exception cref="T:System.InvalidOperationException">Transakcje równoległe są nieobsługiwane.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangeDatabase">
      <MemberSignature Language="C#" Value="public override void ChangeDatabase (string database);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ChangeDatabase(string database) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangeDatabase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ChangeDatabase (database As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ChangeDatabase(System::String ^ database);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.ChangeDatabase(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="database" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="database">Nazwa bazy danych do użycia zamiast bieżącej bazy danych.</param>
        <summary>Zmiany bieżącej bazy danych dla otwartego <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość podana w `database` parametr musi być prawidłową nazwę bazy danych. `database` Parametr nie może zawierać wartości null, ciągiem pustym lub ciągiem o tylko pustych znaków.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i wyświetla niektóre jego właściwości tylko do odczytu.  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa bazy danych jest nieprawidłowa.</exception>
        <exception cref="T:System.InvalidOperationException">Połączenie nie jest otwarty.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Nie można zmienić bazy danych.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChangePassword">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia hasło programu SQL Server.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, string newPassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, string newPassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, newPassword As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::String ^ newPassword);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="newPassword" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, który zawiera wystarczających informacji do łączenia się z serwerem, który ma. Parametry połączenia muszą zawierać nazwę użytkownika i bieżącego hasła.</param>
        <param name="newPassword">Aby ustawić nowe hasło. Hasło musi spełniać wszystkie zasady zabezpieczeń haseł na serwerze, w tym minimalnej długości i wymagania dotyczące określonych znaków i tak dalej.</param>
        <summary>Zmiany w ciągu połączenia w celu dostarczony nowe hasło oznaczone hasło programu SQL Server dla użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli używasz programu SQL Server w systemie Windows Server, deweloperzy mogą wykorzystać funkcje umożliwiające aplikacji klienckiej podawaj jednocześnie bieżącą, jak i nowe hasło w celu zmiany istniejącego hasła. Aplikacje można wdrożyć funkcje, takie jak monitowania użytkownika o nowe hasło podczas początkowego logowania, jeśli stare hasło wygasło i można wykonać tej operacji bez interwencji administratora.  
  
 <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A> Metoda zmienia hasło programu SQL Server dla użytkownika wskazanego w podane `connectionString` parametru na wartość podana w `newPassword` parametru. Jeśli parametry połączenia zawiera opcję Zintegrowane zabezpieczenia (oznacza to, "Integrated Security = True" lub jego odpowiednik), jest zgłaszany wyjątek.  
  
 Aby określić, że hasło wygasło, wywoływania <xref:System.Data.SqlClient.SqlConnection.Open%2A> metoda zgłasza <xref:System.Data.SqlClient.SqlException>. Aby wskazać, że musi zresetować hasło, które są zawarte w parametrach połączenia, <xref:System.Data.SqlClient.SqlException.Number%2A> właściwość wyjątek zawiera wartość stanu 18487 lub 18488. Pierwsza wartość (18487) wskazuje, że hasło wygasło i drugą (18488) wskazuje, że można zresetować hasła przed zalogowaniem się.  
  
 Otwiera połączenie z serwerem, żądań zmiany hasła i zamyka połączenie zaraz po zakończeniu tej metody. To połączenie nie jest pobierana z ani zwrócony do puli połączeń programu SQL Server.  
  
   
  
## Examples  
 Poniżej przedstawiono prosty przykład zmiany hasła:  
  
```  
class Program {  
   static void Main(string[] args) {  
      System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password");  
   }  
}  
  
```  
  
```  
Module Module1  
    Sub Main()  
System.Data.SqlClient.SqlConnection.ChangePassword(  
        "Data Source=a_server;Initial Catalog=a_database;UID=user;PWD=old_password",   
       "new_password")  
    End Sub  
End Module  
  
```  
  
 Następującej aplikacji konsoli Pokazuje zagadnień związanych z zmiana hasła użytkownika, ponieważ bieżące hasło wygasło.  
  
 [!code-csharp[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/CS/source.cs#1)]
 [!code-vb[DataWorks SqlConnection.ChangePassword#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlConnection.ChangePassword/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametry połączenia zawiera opcję Użyj zintegrowanych zabezpieczeń.  Lub <paramref name="newPassword" /> więcej niż 128 znaków.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="connectionString" /> lub <paramref name="newPassword" /> parametr ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangePassword">
      <MemberSignature Language="C#" Value="public static void ChangePassword (string connectionString, System.Data.SqlClient.SqlCredential credential, System.Security.SecureString newSecurePassword);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangePassword(string connectionString, class System.Data.SqlClient.SqlCredential credential, class System.Security.SecureString newSecurePassword) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.Data.SqlClient.SqlCredential,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangePassword (connectionString As String, credential As SqlCredential, newSecurePassword As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangePassword(System::String ^ connectionString, System::Data::SqlClient::SqlCredential ^ credential, System::Security::SecureString ^ newSecurePassword);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="credential" Type="System.Data.SqlClient.SqlCredential" />
        <Parameter Name="newSecurePassword" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="connectionString">Parametry połączenia, który zawiera wystarczających informacji do nawiązania połączenia z serwerem. Parametry połączenia nie należy używać następujące słowa kluczowe parametrów połączenia: <see langword="Integrated Security = true" />, <see langword="UserId" />, lub <see langword="Password" />; lub <see langword="ContextConnection = true" />.</param>
        <param name="credential">A <see cref="T:System.Data.SqlClient.SqlCredential" /> obiektu.</param>
        <param name="newSecurePassword">Nowe hasło. <c>newSecurePassword</c> musi być tylko do odczytu. Hasło musi spełniać wszystkie zasady zabezpieczeń haseł na serwerze (na przykład minimalnej długości i wymagania dotyczące określonych znaków).</param>
        <summary>Zmienia hasło programu SQL Server, użytkownik wskazanych w <see cref="T:System.Data.SqlClient.SqlCredential" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">1.  Parametry połączenia zawierają dowolną kombinację <see langword="UserId" />, <see langword="Password" />, lub <see langword="Integrated Security=true" />.  2.  Parametry połączenia zawierają <see langword="Context Connection=true" />.  3.  <paramref name="newSecurePassword" /> jest większe niż 128 znaków.  4.  <paramref name="newSecurePassword" /> to nie tylko do odczytu.  5.  <paramref name="newSecurePassword" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentNullException">Jeden z parametrów (<paramref name="connectionString" />, <paramref name="credential" />, lub <paramref name="newSecurePassword" />) ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearAllPools">
      <MemberSignature Language="C#" Value="public static void ClearAllPools ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllPools() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearAllPools" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllPools ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllPools();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opróżnia puli połączeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> Resetuje lub opróżnia puli połączeń. W przypadku połączeń używana w momencie wywołania są odpowiednio oznaczone, a zostaną odrzucone (a nie zostały zwrócone do puli) po <xref:System.Data.SqlClient.SqlConnection.Close%2A> nazywa się na nich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearPool">
      <MemberSignature Language="C#" Value="public static void ClearPool (System.Data.SqlClient.SqlConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearPool(class System.Data.SqlClient.SqlConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ClearPool(System.Data.SqlClient.SqlConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearPool (connection As SqlConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearPool(System::Data::SqlClient::SqlConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.SqlClient.SqlConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.SqlClient.SqlConnection" /> Do wyczyszczenia z puli.</param>
        <summary>Opróżnia puli połączeń skojarzone z określonego połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A> Czyści puli połączeń, z którym skojarzony jest `connection`. Jeśli dodatkowe połączenia skojarzony z `connection` jest używana w momencie wywołania, są odpowiednio oznaczone, a zostaną odrzucone (a nie zostały zwrócone do puli), gdy <xref:System.Data.SqlClient.SqlConnection.Close%2A> jest wywoływana na nich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientConnectionId">
      <MemberSignature Language="C#" Value="public Guid ClientConnectionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ClientConnectionId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ClientConnectionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientConnectionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ClientConnectionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikator połączenia ostatniej próby połączenia, niezależnie od tego, czy próba powodzeniem lub niepowodzeniem.</summary>
        <value>Próba połączenia identyfikator ostatniego połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ClientConnectionId%2A> działa niezależnie od tego, która wersja serwera możesz nawiązać połączenie, ale dzienniki zdarzeń rozszerzonych i wpis na błędy bufor pierścień połączenia nie będą obecne w [!INCLUDE[sskatmai_r2](~/includes/sskatmai-r2-md.md)] i starszych wersji.  
  
 Identyfikator połączenia można znaleźć w dzienniku zdarzeń rozszerzonych, jeśli został błędu na serwerze, jeśli włączono zdarzeń rozszerzonych rejestrowanie identyfikator połączenia. Możesz również znaleźć Identyfikatora połączenia w buforze pierścień połączenia ([rozwiązywania problemów z łącznością programu SQL Server 2008 buforem pierścienia łączności](http://go.microsoft.com/fwlink/?LinkId=207752)) dla niektórych błędów dotyczących połączeń. Jeśli identyfikator połączenia, który nie jest w buforze pierścień połączenia, można założyć błędu sieci.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie z bazą danych. Jest to preferowana metoda zamknięcia wszystkie otwarte połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.Close%2A> Metody wycofuje wszystkie transakcje oczekujące. Następnie go zwalnia połączenia z puli połączeń lub zamyka połączenie, jeśli buforowanie połączeń jest wyłączone.  
  
> [!NOTE]
>  Transakcje uruchomione przy użyciu oczekujące [!INCLUDE[tsql](~/includes/tsql-md.md)] lub <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> są automatycznie wycofana przy połączenia jest resetowany, jeśli buforowanie połączeń jest włączone. Jeśli buforowanie połączeń jest wyłączona, transakcja zostanie wycofana po `SqlConnection.Close` jest wywoływana. Transakcje uruchomione za pomocą <xref:System.Transactions> są kontrolowane przez `System.Transactions` infrastruktury i do których nie dotyczy `SqlConnection.Close`.  
  
 Aplikacja może wywołać <xref:System.Data.SqlClient.SqlConnection.Close%2A> więcej niż jeden raz. Wyjątek nie zostanie wygenerowany.  
  
 Jeśli <xref:System.Data.SqlClient.SqlConnection> umieszczane poza zakres, nie będzie można go zamknąć. W związku z tym należy jawnie zamknąć połączenie przez wywołanie metody `Close` lub `Dispose`. `Close` i `Dispose` działają tak samo. Jeśli pula połączeń wartość `Pooling` ustawiono `true` lub `yes`, połączenie znajdujące się poniżej jest przywracane do puli połączeń. Z drugiej strony Jeśli `Pooling` ustawiono `false` lub `no`, połączenie z serwerem znajdujące się poniżej zostało zamknięte.  
  
> [!NOTE]
>  Zdarzenia logowania i wylogowywania nie będą zgłaszane na serwerze gdy połączenie jest pobranych z lub zwrócony do puli połączeń, ponieważ połączenie nie jest w rzeczywistości zamknięte zwracanie do puli połączeń. Aby uzyskać więcej informacji, zobacz [programu SQL Server połączenia buforowanie (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
> [!CAUTION]
>  Nie wywołuj `Close` lub `Dispose` na połączenie, DataReader lub innego obiektu zarządzanego w `Finalize` metody klasy. W finalizator należy tylko Zwolnij niezarządzane zasoby, które bezpośrednio należą do klasy. Jeśli klasa nie ma żadnych niezarządzanych zasobów, nie dołączaj `Finalize` metody w definicji klasy. Aby uzyskać więcej informacji, zobacz [wyrzucanie elementów bezużytecznych](~/docs/standard/garbage-collection/index.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection>, zostanie on otwarty, wyświetla niektóre jego właściwości. Połączenie jest automatycznie zamknięte po zakończeniu `using` bloku.  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.SqlClient.SqlException">Błąd połączenia na poziomie, który wystąpił podczas otwierania połączenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionKeyCacheTtl">
      <MemberSignature Language="C#" Value="public static TimeSpan ColumnEncryptionKeyCacheTtl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionKeyCacheTtl" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionKeyCacheTtl As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan ColumnEncryptionKeyCacheTtl { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia time-to-live szyfrowania kolumny klucza wpisów w buforze klucza szyfrowania kolumny [zawsze Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine) funkcji. Wartość domyślna to 2 godziny. wartość 0 oznacza nie buforowania na wszystkich.</summary>
        <value>Przedział czasu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionQueryMetadataCacheEnabled">
      <MemberSignature Language="C#" Value="public static bool ColumnEncryptionQueryMetadataCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionQueryMetadataCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ColumnEncryptionQueryMetadataCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ColumnEncryptionQueryMetadataCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest włączone buforowanie metadanych zapytań (true) czy nie (false) w zapytaniach parametrycznych uruchamiania [zawsze Encrypted](/sql/relational-databases/security/encryption/always-encrypted-database-engine) włączone bazy danych. Wartość domyślna to true.</summary>
        <value>Zwraca wartość PRAWDA, jeśli jest włączone buforowanie metadanych zapytań; w przeciwnym razie wartość false. wartość true, jest ustawieniem domyślnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W zapytaniach parametrycznych SqlClient sprawia, że obie strony do programu SQL Server dla parametru metadanych, aby zobaczyć, których parametr należy szyfrować i w jaki sposób (które kluczy i algorytmów powinny być używane). Jeśli aplikacja wymaga tego samego zapytania wiele razy, dodatkowe obie strony jest kierowane do serwera poszczególnych czas, który powoduje spadek wydajności aplikacji.  
  
 Z **ColumnEncryptionQueryMetadataCacheEnabled** ustawioną wartość PRAWDA, jeśli to samo zapytanie jest wywołana wiele razy, komunikacja dwukierunkowa na serwerze zostaną wprowadzone tylko raz. Pamięć podręczna zawiera niemożliwą do skonfigurowania parametr rozmiar maksymalny, który ma ustawioną wartość kwerendy 2000.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnEncryptionTrustedMasterKeyPaths">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.IList&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.IList`1&lt;string&gt;&gt; ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ColumnEncryptionTrustedMasterKeyPaths" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ColumnEncryptionTrustedMasterKeyPaths As IDictionary(Of String, IList(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ ColumnEncryptionTrustedMasterKeyPaths { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::IList&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.IList&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Umożliwia ustalenie listy Zaufane ścieżki klucza dla serwera bazy danych. Jeśli podczas przetwarzania zapytania aplikacji sterownika odbiera ścieżki klucza, który nie znajduje się na liście, zapytanie nie powiedzie się. Ta właściwość zapewnia dodatkową ochronę przed takimi atakami, obejmujących serwer SQL złamany zapewniający fałszywych klucza ścieżki, które mogą prowadzić do wyciek poświadczeń magazynu kluczy.</summary>
        <value>Lista ścieżek zaufany klucz główny szyfrowania kolumny.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectionString">
      <MemberSignature Language="C#" Value="public override string ConnectionString { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionString" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionString { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlConnectionStringEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg używany do otwierania bazy danych programu SQL Server.</summary>
        <value>Parametry połączenia, Nazwa źródłowej bazy danych i inne parametry wymagane do ustanowienia połączenia początkowego. Wartością domyślną jest ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> Jest podobny do ciągu połączenia OLE DB, ale nie są identyczne. W odróżnieniu od OLE DB i ADO, ciąg połączenia, który jest zwracany jest taka sama jak ustawiono użytkownika <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>, minus informacji o zabezpieczeniach, jeśli ustawiono wartość Persist Security Info `false` (ustawienie domyślne). .NET Framework Data Provider for SQL Server nie trwałe i zwrócić hasła w parametrach połączenia, chyba że ustawioną Persist Security Info `true`.  
  
 Można użyć <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwość, aby połączyć się z bazą danych. Poniższy przykład przedstawia typowe parametry.  
  
```  
"Persist Security Info=False;Integrated Security=true;Initial Catalog=Northwind;server=(local)"  
```  
  
 Użyj nowych <xref:System.Data.SqlClient.SqlConnectionStringBuilder> utworzyć prawidłowe połączenie ciągów w czasie wykonywania. Aby uzyskać więcej informacji, zobacz [Konstruktorzy ciągów połączenia](~/docs/framework/data/adonet/connection-string-builders.md).  
  
 <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> Właściwość można ustawić tylko wtedy, gdy połączenie jest zamknięte. Wiele wartości parametrów połączeń ma odpowiednie właściwości tylko do odczytu. Po ciągu połączenia jest ustawiona, te właściwości zostaną zaktualizowane, z wyjątkiem przypadków, gdy zostanie wykryty błąd. W takim przypadku żadnej właściwości zostały zaktualizowane. <xref:System.Data.SqlClient.SqlConnection> właściwości zwraca tylko te ustawienia, które są zawarte w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.  
  
 Aby połączyć się z komputerem lokalnym, określ "(local)" dla serwera. Jeśli nie określono nazwy serwera, połączenie nastąpi próba domyślnego wystąpienia na komputerze lokalnym.  
  
 Resetowanie <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> zamkniętego połączenia resetuje wszystkie wartości parametrów połączeń (i powiązanych właściwości) zawiera hasło. Na przykład jeśli ustawisz ciąg połączenia, który zawiera "bazy danych = AdventureWorks", a następnie zresetować parametry połączenia do "źródła danych = MójSerwer; Integrated Security = true", <xref:System.Data.SqlClient.SqlConnection.Database%2A> właściwość nie jest ustawiona na "AdventureWorks".  
  
 Natychmiast po ustawiany jest przeanalizować parametrów połączenia. W przypadku znalezienia błędów w składni podczas analizowania, wyjątek czasu wykonywania, takie jak <xref:System.ArgumentException>, zostanie wygenerowany. Inne błędy, znajduje się tylko w przypadku próby otwarcia połączenia.  
  
 Podstawowe formaty parametry połączenia zawiera serię par — słowo kluczowe i wartości, oddziel je średnikami. Znak równości (=) łączy każde słowo kluczowe i jego wartość. Aby uwzględnić wartości, które zawiera średnik, znak pojedynczego cudzysłowu ani znaków podwójnego cudzysłowu, wartość musi być ujęta w znaki podwójnego cudzysłowu. Jeśli wartość zawiera średnik i znaku podwójnego cudzysłowu, wartość mogą być ujęte w apostrofy. Znak pojedynczego cudzysłowu jest również przydatne, jeśli wartość rozpoczyna się od znaku podwójnego cudzysłowu. Z drugiej strony podwójny cudzysłów służy Jeśli wartość rozpoczyna się od pojedynczego cudzysłowu. Jeśli wartość zawiera znak pojedynczego cudzysłowu jak podwójnego cudzysłowu, znak cudzysłowu, ujmij wartość musi być podwójny za każdym razem, gdy ma miejsce w wartości.  
  
 Aby spacji ani na końcu w wartości ciągu, wartość musi być ujęta w znaki apostrofu lub podwójny cudzysłów. Spacji wiodących lub końcowych wokół liczba całkowita, wartość logiczna lub wartości wyliczenia są ignorowane, nawet jeśli ujęty w cudzysłów. Jednak spacje wewnątrz — słowo kluczowe literału ciągu lub wartość są zachowywane. Pojedynczy lub podwójny cudzysłów może być używana w ciągu połączenia bez użycia ogranicznik (na przykład źródło danych = my'Server lub źródło danych = my "Server), chyba że znak cudzysłowu jest pierwszy i ostatni znak w wartości.  
  
 Słowa kluczowe nie jest uwzględniana wielkość liter.  
  
 W poniższej tabeli wymieniono prawidłowe nazwy dla wartości słów kluczowych w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.  
  
  Poniższa lista zawiera prawidłowe nazwy do buforowania wartości w ramach połączeń <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>. Aby uzyskać więcej informacji, zobacz [programu SQL Server połączenia buforowanie (ADO.NET)](~/docs/framework/data/adonet/sql-server-connection-pooling.md).  
  
-   Okres istnienia połączenia (lub limit czasu równoważenia obciążenia)  
  
-   Enlist  
  
-   Rozmiar maksymalny buforu  
  
-   Minimalny rozmiar puli  
  
-   Buforowanie  
  
 Ustawiając — słowo kluczowe lub wartości, które wymagają wartość logiczną buforowania połączeń, można użyć "tak" zamiast "true" i "no" zamiast "false". Liczby całkowite są reprezentowane jako ciągi.  
  
> [!NOTE]
>  .NET Framework Data Provider for SQL Server używa własnego protokołu do komunikowania się z programem SQL Server. W związku z tym nie obsługuje korzystanie z nazwą źródła danych (DSN) ODBC podczas nawiązywania połączenia z programem SQL Server, ponieważ nie powoduje dodania warstwy ODBC.  
  
> [!NOTE]
>  Universal data link (UDL) plików nie są obsługiwane dla dostawcy danych programu .NET Framework dla programu SQL Server.  
  
> [!CAUTION]
>  W tej wersji aplikacji należy zachować ostrożność podczas konstruowania parametry połączenia oparte na dane wejściowe użytkownika (na przykład podczas pobierania informacji o ID i hasło użytkownika z okno dialogowe i dołączenie go w parametrach połączenia). Aplikacji należy upewnić się, użytkownik nie można osadzić dodatkowych ciąg parametrów połączenia w tych wartości (na przykład wprowadzania hasła jako "validpassword; baza danych = somedb" w celu dołączenia do innej bazy danych). Aby utworzyć parametry połączenia oparte na danych wejściowych użytkownika, należy użyć nowego <xref:System.Data.SqlClient.SqlConnectionStringBuilder>, która weryfikuje ciąg połączenia i pomoże wyeliminować ten problem. Zobacz [Konstruktorzy ciągów połączenia](~/docs/framework/data/adonet/connection-string-builders.md) Aby uzyskać więcej informacji.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i ustawia <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> właściwości przed otwarciem połączenia.  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podano nieprawidłowe połączenie argument ciągu lub nie został podany argument ciągu połączenia wymagane.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionTimeout">
      <MemberSignature Language="C#" Value="public override int ConnectionTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ConnectionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ConnectionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ConnectionTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ConnectionTimeout { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.ConnectionTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas oczekiwania podczas próby nawiązania połączenia przed zakończeniem próby i wygenerowaniem błędu.</summary>
        <value>Czas (w sekundach) oczekiwania na połączenie, aby otworzyć. Wartość domyślna to 15 sekund.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy określić ilość czasu oczekiwania połączenia limitu czasu przy użyciu `Connect Timeout` lub `Connection Timeout` słów kluczowych w parametrach połączenia. Wartość 0 oznacza brak limitu i należy unikać w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> ponieważ próby nawiązania połączenia przez nieokreślony czas oczekiwania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i ustawia `Connection Timeout` 30 sekund w parametrach połączenia. Kod otwiera połączenie i wyświetla <xref:System.Data.SqlClient.SqlConnection.ConnectionTimeout%2A> właściwości w oknie konsoli.  
  
 [!code-csharp[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.ConnectionTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.ConnectionTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCommand">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCommand CreateCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.SqlClient.SqlCommand CreateCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCommand () As SqlCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::SqlClient::SqlCommand ^ CreateCommand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca <see cref="T:System.Data.SqlClient.SqlCommand" /> obiekt skojarzony z <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <returns>A <see cref="T:System.Data.SqlClient.SqlCommand" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[SqlConnection_CreateCommand#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/sqlconnection_createcommand/cs/source.cs#1)]
 [!code-vb[SqlConnection_CreateCommand#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/sqlconnection_createcommand/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDbCommand">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbCommand CreateDbCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbCommand CreateDbCommand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.CreateDbCommand" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDbCommand () As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbCommand ^ CreateDbCommand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credential">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credential" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credential" />
      <MemberSignature Language="VB.NET" Value="Public Property Credential As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credential { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.SqlClient.SqlCredential" /> obiekt dla tego połączenia.</summary>
        <value>
          <see cref="T:System.Data.SqlClient.SqlCredential" /> Obiekt dla tego połączenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Persist Security Info = true` jest wymagane do pobrania wartości <xref:System.Data.SqlClient.SqlCredential> obiekt z <xref:System.Data.SqlClient.SqlConnection.Credential%2A>.  
  
 Wartość domyślna <xref:System.Data.SqlClient.SqlConnection.Credential%2A> ma wartość null.  
  
 <xref:System.InvalidOperationException> Zostanie zgłoszony wyjątek:  
  
-   Jeśli <xref:System.Data.SqlClient.SqlConnection.Credential%2A> jest ustawiony dla otwartego połączenia.  
  
-   Jeśli <xref:System.Data.SqlClient.SqlConnection.Credential%2A> jest ustawiana podczas `Context Connection=true`.  
  
-   Jeśli <xref:System.Data.SqlClient.SqlConnection.Credential%2A> jest ustawiana podczas `Integrated Security = true`.  
  
-   Jeśli <xref:System.Data.SqlClient.SqlConnection.Credential%2A> jest ustawiona, gdy używa ciągu połączenia `Password`.  
  
-   Jeśli <xref:System.Data.SqlClient.SqlConnection.Credential%2A> jest ustawiona, gdy używa ciągu połączenia `UserID`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Data.SqlClient.SqlCredential Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.SqlClient.SqlCredential Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As SqlCredential" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SqlClient::SqlCredential ^ Credentials { System::Data::SqlClient::SqlCredential ^ get(); void set(System::Data::SqlClient::SqlCredential ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Database">
      <MemberSignature Language="C#" Value="public override string Database { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Database" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.Database" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Database As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Database { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.Database</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę bieżącej bazy danych lub baza danych ma być używany po otwarciu połączenia.</summary>
        <value>Nazwa bieżącej bazy danych lub nazwa bazy danych do użycia po otwarciu połączenia. Wartością domyślną jest ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection.Database%2A> Właściwość aktualizacje dynamiczne. W przypadku zmiany w bieżącej bazie danych przy użyciu [!INCLUDE[tsql](~/includes/tsql-md.md)] instrukcji lub <xref:System.Data.SqlClient.SqlConnection.ChangeDatabase%2A> , wysyłany jest komunikat informacyjny i właściwość jest aktualizowane automatycznie.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i wyświetla niektóre jego właściwości tylko do odczytu.  
  
 [!code-csharp[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Database Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Database Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public override string DataSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DataSource As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DataSource { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę wystąpienia programu SQL Server, którym chcesz się połączyć.</summary>
        <value>Nazwa wystąpienia programu SQL Server, którym chcesz się połączyć. Wartością domyślną jest ciąg pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Data.SqlClient.SqlConnection.DataSource%2A> Zwraca `null` Jeśli parametrów połączenia dla <xref:System.Data.SqlClient.SqlConnection> jest "połączenia kontekstu = true".  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i wyświetla niektóre jego właściwości tylko do odczytu.  
  
 [!code-csharp[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.DataSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.DataSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DbProviderFactory">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbProviderFactory DbProviderFactory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbProviderFactory DbProviderFactory" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.DbProviderFactory" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DbProviderFactory As DbProviderFactory" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbProviderFactory ^ DbProviderFactory { System::Data::Common::DbProviderFactory ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbProviderFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistDistributedTransaction">
      <MemberSignature Language="C#" Value="public void EnlistDistributedTransaction (System.EnterpriseServices.ITransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnlistDistributedTransaction(class System.EnterpriseServices.ITransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistDistributedTransaction(System.EnterpriseServices.ITransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnlistDistributedTransaction (transaction As ITransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnlistDistributedTransaction(System::EnterpriseServices::ITransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.EnterpriseServices.ITransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Odwołanie do istniejącej <see cref="T:System.EnterpriseServices.ITransaction" /> w którym można zarejestrować.</param>
        <summary>Rejestruje w określonym transakcji jako transakcji rozproszonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A> metody można zarejestrować transakcji rozproszonej. Ponieważ współdziała on połączenie w <xref:System.Transactions.Transaction> wystąpienia, **EnlistTransaction** korzysta z funkcji dostępnych w <xref:System.Transactions> transakcji, dzięki czemu preferowane rozproszonychprzestrzeninazwdozarządzania** EnlistDistributedTransaction** w tym celu. Aby uzyskać więcej informacji, zobacz [transakcji rozproszonych](~/docs/framework/data/adonet/distributed-transactions.md).  
  
 Możesz zarejestrować się w istniejących przy użyciu transakcji rozproszonej **EnlistDistributedTransaction** metody po wyłączeniu automatycznej rejestracji. Rejestrowanie w istniejącej transakcji rozproszonej upewnia się, że, jeśli transakcja jest zatwierdzona lub wycofana, zmiany dokonane przez kod w źródle danych są również zatwierdzenia lub wycofania.  
  
 `EnlistDistributedTransaction` Zwraca wyjątek, jeśli <xref:System.Data.SqlClient.SqlConnection> został już uruchomiony przy użyciu transakcji <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>. Jednak jeśli transakcja jest transakcji lokalnej rozpoczęty o godzinie źródło danych (na przykład, wykonując jawnie za pomocą instrukcji BEGIN TRANSACTION <xref:System.Data.SqlClient.SqlCommand> obiektu), **EnlistDistributedTransaction** nastąpi powrót do wcześniejszej transakcji lokalnej i powoduje zarejestrowanie w istniejącej transakcji rozproszonej, zgodnie z żądaniem. Nie otrzymasz powiadomienie lokalnego transakcja została wycofana, czy odpowiedzialny za zarządzanie wszystkich transakcji lokalnej nie uruchomiono przy użyciu <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnlistTransaction">
      <MemberSignature Language="C#" Value="public override void EnlistTransaction (System.Transactions.Transaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EnlistTransaction(class System.Transactions.Transaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.EnlistTransaction(System.Transactions.Transaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EnlistTransaction(System::Transactions::Transaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Transactions.Transaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Odwołanie do istniejącej <see cref="T:System.Transactions.Transaction" /> w którym można zarejestrować.</param>
        <summary>Rejestruje w określonym transakcji jako transakcji rozproszonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Data.SqlClient.SqlConnection.EnlistTransaction%2A> metody można zarejestrować transakcji rozproszonej. Ponieważ współdziała on połączenie w <xref:System.Transactions.Transaction> wystąpienia, **EnlistTransaction** korzysta z funkcji dostępnych w <xref:System.Transactions> transakcji, dzięki czemu preferowane rozproszonychprzestrzeninazwdozarządzania** EnlistDistributedTransaction**, który korzysta z **System.EnterpriseServices.ITransaction** obiektu. Ma również semantyki nieco inne: po połączenie jawnie jest zarejestrowana w transakcji, nie może być unenlisted lub zarejestrowany w innej transakcji, dopóki nie zakończy Pierwsza transakcja. Aby uzyskać więcej informacji na temat transakcji rozproszonych, zobacz [transakcje rozproszone](~/docs/framework/data/adonet/distributed-transactions.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FireInfoMessageEventOnUserErrors">
      <MemberSignature Language="C#" Value="public bool FireInfoMessageEventOnUserErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property FireInfoMessageEventOnUserErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FireInfoMessageEventOnUserErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> właściwości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" /> właściwość została ustawiona; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A> do `true`, błędów, które wcześniej były traktowane jako wyjątki są teraz obsługiwane jako <xref:System.Data.SqlClient.SqlConnection.InfoMessage> zdarzenia. Wszystkie zdarzenia wyzwalać natychmiast i będą obsługiwane przez program obsługi zdarzeń. Jeśli jest <xref:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors%2A> ustawiono `false`, następnie <xref:System.Data.SqlClient.SqlConnection.InfoMessage> na końcu procedury obsługi zdarzeń.  
  
> [!NOTE]
>  Błąd poziomu ważności 17 lub nowszym, który powoduje, że serwer zatrzymania przetwarzania polecenia musi być obsługiwana jako wyjątek. W takim przypadku jest zwracany wyjątek, niezależnie od sposobu obsługi błędu w <xref:System.Data.SqlClient.SqlConnection.InfoMessage> zdarzeń.  
  
 Aby uzyskać więcej informacji dotyczących pracy ze zdarzeniami, zobacz [zdarzeń połączenia](~/docs/framework/data/adonet/connection-events.md). Aby uzyskać więcej informacji o błędach wygenerowanych przez aparat programu SQL Server zobacz dokumentację SQL Server — książki Online.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca informacje o schemacie dla źródła danych to <see cref="T:System.Data.SqlClient.SqlConnection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Próba pobrania informacji o schemacie dla więcej niż jednej procedury składowanej numerów wersji schematu dla najnowszego jest zwracany wyłącznie. Aby uzyskać więcej informacji na procedury składowane w określonej wersji Zobacz SQL Server — książki Online.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca informacje o schemacie dla źródła danych to <see cref="T:System.Data.SqlClient.SqlConnection" />. Aby uzyskać więcej informacji na temat schematu, zobacz [kolekcje schematów serwera SQL] (http://msdn.microsoft.com/library/ms254969.aspx).</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zawierający informacje o schemacie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="collectionName">Określa nazwę schematu do zwrócenia.</param>
        <summary>Zwraca informacje o schemacie dla źródła danych to <see cref="T:System.Data.SqlClient.SqlConnection" /> przy użyciu określonego ciągu dla nazwy schematu.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zawierający informacje o schemacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje o schemacie bazy danych, tabel lub kolumn może być konieczne. Ten przykład:  
  
-   Używa GetSchema w celu uzyskania informacji o schemacie.  
  
-   Użyj schematu ograniczenia, aby uzyskać informacje podane.  
  
-   Pobiera informacje o schemacie bazy danych, tabele i kolumny.  
  
 Przed uruchomieniem próbki, należy utworzyć przykładowej bazy danych, użycie następujących [!INCLUDE[tsql](~/includes/tsql-md.md)]:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 [Jak pobrać informacji schematu z bazy danych](https://code.msdn.microsoft.com/How-to-Get-Schema-b66d62e2) ma C# i Visual Basic wersje tego przykładu kodu w projektach Visual Studio.  
  
```  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
      using (SqlConnection conn = new SqlConnection("Data Source=(local);Initial Catalog=MySchool;Integrated Security=True;Asynchronous Processing=true;")) {  
         conn.Open();  
  
         // Get the Meta Data for Supported Schema Collections  
         DataTable metaDataTable = conn.GetSchema("MetaDataCollections");  
  
         Console.WriteLine("Meta Data for Supported Schema Collections:");  
         ShowDataTable(metaDataTable, 25);  
         Console.WriteLine();  
  
         // Get the schema information of Databases in your instance  
         DataTable databasesSchemaTable = conn.GetSchema("Databases");  
  
         Console.WriteLine("Schema Information of Databases:");  
         ShowDataTable(databasesSchemaTable, 25);  
         Console.WriteLine();  
  
         // First, get schema information of all the tables in current database;  
         DataTable allTablesSchemaTable = conn.GetSchema("Tables");  
  
         Console.WriteLine("Schema Information of All Tables:");  
         ShowDataTable(allTablesSchemaTable, 20);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Table Type to get   
         // the specified table(s).  
         // You can use four restrictions for Table, so you should create a 4 members array.  
         String[] tableRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Table Type.   
         // Now we specify the Table Name of the table what we want to get schema information.  
         tableRestrictions[2] = "Course";  
  
         DataTable courseTableSchemaTable = conn.GetSchema("Tables", tableRestrictions);  
  
         Console.WriteLine("Schema Information of Course Tables:");  
         ShowDataTable(courseTableSchemaTable, 20);  
         Console.WriteLine();  
  
         // First, get schema information of all the columns in current database.  
         DataTable allColumnsSchemaTable = conn.GetSchema("Columns");  
  
         Console.WriteLine("Schema Information of All Columns:");  
         ShowColumns(allColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Column Name to get the specified column(s).  
         // You can use four restrictions for Column, so you should create a 4 members array.  
         String[] columnRestrictions = new String[4];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         columnRestrictions[2] = "Course";  
         columnRestrictions[3] = "DepartmentID";  
  
         DataTable departmentIDSchemaTable = conn.GetSchema("Columns", columnRestrictions);  
  
         Console.WriteLine("Schema Information of DepartmentID Column in Course Table:");  
         ShowColumns(departmentIDSchemaTable);  
         Console.WriteLine();  
  
         // First, get schema information of all the IndexColumns in current database  
         DataTable allIndexColumnsSchemaTable = conn.GetSchema("IndexColumns");  
  
         Console.WriteLine("Schema Information of All IndexColumns:");  
         ShowIndexColumns(allIndexColumnsSchemaTable);  
         Console.WriteLine();  
  
         // You can specify the Catalog, Schema, Table Name, Constraint Name, Column Name to   
         // get the specified column(s).  
         // You can use five restrictions for Column, so you should create a 5 members array.  
         String[] indexColumnsRestrictions = new String[5];  
  
         // For the array, 0-member represents Catalog; 1-member represents Schema;   
         // 2-member represents Table Name; 3-member represents Constraint Name;4-member represents Column Name.   
         // Now we specify the Table_Name and Column_Name of the columns what we want to get schema information.  
         indexColumnsRestrictions[2] = "Course";  
         indexColumnsRestrictions[4] = "CourseID";  
  
         DataTable courseIdIndexSchemaTable = conn.GetSchema("IndexColumns", indexColumnsRestrictions);  
  
         Console.WriteLine("Index Schema Information of CourseID Column in Course Table:");  
         ShowIndexColumns(courseIdIndexSchemaTable);  
         Console.WriteLine();  
      }  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   private static void ShowDataTable(DataTable table, Int32 length) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-" + length + "}", col.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         foreach (DataColumn col in table.Columns) {  
            if (col.DataType.Equals(typeof(DateTime)))  
               Console.Write("{0,-" + length + ":d}", row[col]);  
            else if (col.DataType.Equals(typeof(Decimal)))  
               Console.Write("{0,-" + length + ":C}", row[col]);  
            else  
               Console.Write("{0,-" + length + "}", row[col]);  
         }  
         Console.WriteLine();  
      }  
   }  
  
   private static void ShowDataTable(DataTable table) {  
      ShowDataTable(table, 14);  
   }  
  
   private static void ShowColumns(DataTable columnsTable) {  
      var selectedRows = from info in columnsTable.AsEnumerable()  
                         select new {  
                            TableCatalog = info["TABLE_CATALOG"],  
                            TableSchema = info["TABLE_SCHEMA"],  
                            TableName = info["TABLE_NAME"],  
                            ColumnName = info["COLUMN_NAME"],  
                            DataType = info["DATA_TYPE"]  
                         };  
  
      Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "TableCatalog", "TABLE_SCHEMA",  
          "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", row.TableCatalog,  
             row.TableSchema, row.TableName, row.ColumnName, row.DataType);  
      }  
   }  
  
   private static void ShowIndexColumns(DataTable indexColumnsTable) {  
      var selectedRows = from info in indexColumnsTable.AsEnumerable()  
                         select new {  
                            TableSchema = info["table_schema"],  
                            TableName = info["table_name"],  
                            ColumnName = info["column_name"],  
                            ConstraintSchema = info["constraint_schema"],  
                            ConstraintName = info["constraint_name"],  
                            KeyType = info["KeyType"]  
                         };  
  
      Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", "table_schema", "table_name", "column_name", "constraint_schema", "constraint_name", "KeyType");  
      foreach (var row in selectedRows) {  
         Console.WriteLine("{0,-14}{1,-11}{2,-14}{3,-18}{4,-16}{5,-8}", row.TableSchema,  
             row.TableName, row.ColumnName, row.ConstraintSchema, row.ConstraintName, row.KeyType);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> jest określony jako wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchema (string collectionName, string[] restrictionValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchema(string collectionName, string[] restrictionValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.GetSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchema (collectionName As String, restrictionValues As String()) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchema(System::String ^ collectionName, cli::array &lt;System::String ^&gt; ^ restrictionValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collectionName" Type="System.String" />
        <Parameter Name="restrictionValues" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="collectionName">Określa nazwę schematu do zwrócenia.</param>
        <param name="restrictionValues">Zestaw wartości ograniczeń dla żądanego schematu.</param>
        <summary>Zwraca informacje o schemacie dla źródła danych to <see cref="T:System.Data.SqlClient.SqlConnection" /> przy użyciu określonego ciągu dla nazwy schematu i tablicy określony ciąg wartości ograniczeń.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> zawierający informacje o schemacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `restrictionValues` Można podać parametru *n* głębokość wartości, które są określone przez kolekcji ograniczeń dla określonej kolekcji. Aby ustawić wartości dla danego ograniczeń i nie ustawić wartości właściwości inne ograniczenia, należy ustawić poprzednich ograniczeń `null` , a następnie przekaż odpowiednią wartość w ograniczenia, które chcesz określić wartość.  
  
 Na przykład jest kolekcją "Tabele". Kolekcja "Tabele" ma trzy ograniczenia — bazy danych, właściciela, nazwy tabeli--i chcesz odzyskać tylko w tabelach, które są skojarzone z właścicielem "Carl", musisz przekazać w następujących wartości: null, "Carl". Jeśli wartość ograniczenia nie jest przekazany, wartości domyślne są używane dla tego ograniczenia. To tego samego mapowania jako przekazywanie `null`, który jest inny niż przekazywanie w ciągu pustego wartość parametru. W takim przypadku ciąg pusty ("") jest traktowany jako wartość parametru określony.  
  
 Potrzeby demonstrowania przykładowy kod <xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>, zobacz <xref:System.Data.SqlClient.SqlConnection.GetSchema%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="collectionName" /> jest określony jako wartość null.</exception>
        <altmember cref="M:System.Data.SqlClient.SqlConnection.GetSchema" />
      </Docs>
    </Member>
    <Member MemberName="InfoMessage">
      <MemberSignature Language="C#" Value="public event System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.SqlClient.SqlInfoMessageEventHandler InfoMessage" />
      <MemberSignature Language="DocId" Value="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InfoMessage As SqlInfoMessageEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::SqlClient::SqlInfoMessageEventHandler ^ InfoMessage;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SqlClient.SqlInfoMessageEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy program SQL Server zwraca komunikat ostrzeżenia lub informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klienci, w których chcesz przetworzyć ostrzeżenia i komunikaty informacyjne wysyłane przez serwer powinien utworzyć <xref:System.Data.SqlClient.SqlInfoMessageEventHandler> delegata do nasłuchiwania do tego zdarzenia.  
  
 <xref:System.Data.SqlClient.SqlConnection.InfoMessage> Zdarzenie wystąpi, gdy wiadomość z o wadze 10 lub mniej jest zwracany przez program SQL Server. Komunikaty o wadze od 11 do 20 Zgłoś błąd i komunikaty o ważności za pośrednictwem 20 przyczyny połączenia, aby zamknąć. Aby uzyskać więcej informacji dotyczących poziomów błędów programu SQL Server zobacz "Bazy danych aparatu błąd wag" w podręcznikach Online programu SQL Server.  
  
 Aby uzyskać więcej informacji i przykład zobacz [zdarzeń połączenia](~/docs/framework/data/adonet/connection-events.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public override void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.Open" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Open();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDbConnection.Open</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera połączenie z bazą danych przy użyciu ustawień właściwości określone przez <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlClient.SqlConnection> Rysuje otwartego połączenia z puli połączeń, jeśli jest dostępny. W przeciwnym razie nawiązaniem nowego połączenia z wystąpieniem programu SQL Server.  
  
> [!NOTE]
>  Jeśli <xref:System.Data.SqlClient.SqlConnection> umieszczane poza zakres, nie jest zamknięty. W związku z tym należy jawnie zamknąć połączenie przez wywołanie metody <xref:System.Data.SqlClient.SqlConnection.Close%2A>.  
  
> [!NOTE]
>  Jeśli określisz numeru portu innego niż 1433, gdy użytkownik próbuje połączyć się z wystąpieniem programu SQL Server i za pomocą protokołu innego niż TCP/IP, <xref:System.Data.SqlClient.SqlConnection.Open%2A> metoda kończy się niepowodzeniem. Aby określić numer portu innego niż 1433, obejmują "serwer = machinename, numer portu" w ciągu połączenia, a protokół TCP/IP używany.  
  
> [!NOTE]
>  .NET Framework Data Provider for SQL Server wymaga uprawnień zabezpieczeń "Umożliwia wywołania zestawy niezarządzanych" włączone (<xref:System.Security.Permissions.SecurityPermission> z <xref:System.Security.Permissions.SecurityPermissionFlag> ustawioną `UnmanagedCode`) można otworzyć <xref:System.Data.SqlClient.SqlConnection> z włączonym debugowaniem SQL.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection>go otwiera i wyświetla niektóre jego właściwości. Połączenie jest automatycznie zamknięte po zakończeniu `using` bloku.  
  
 [!code-csharp[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.Open Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.Open Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można otworzyć połączenia bez określania źródła danych lub serwera.  lub połączenie jest już otwarte.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Wystąpił błąd na poziomie połączenia podczas otwierania połączenia. Jeśli <see cref="P:System.Data.SqlClient.SqlException.Number" /> właściwość zawiera wartość 18487 lub 18488, oznacza to, że określone hasło wygasło lub musi zostać zresetowany. Zobacz <see cref="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" /> metody, aby uzyskać więcej informacji.  <see langword="&lt;system.data.localdb&gt;" /> Znacznika w pliku app.config ma nieprawidłową lub nieznaną elementów.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Istnieją dwa wpisy o takiej samej nazwie w <see langword="&lt;localdbinstances&gt;" /> sekcji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task OpenAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task OpenAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ OpenAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Instrukcja anulowania.</param>
        <summary>Wersja asynchroniczna elementu <see cref="M:System.Data.SqlClient.SqlConnection.Open" />, która otwiera połączenie z bazą danych przy użyciu ustawień właściwości określone przez <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />. Token anulowania może służyć do żądania porzucony operację zanim upłynie limit czasu połączenia.  Wyjątki będą przekazywane za pośrednictwem zwrócone zadania. Jeśli upłynie limit czasu połączenia bez uzyskania połączenia, zwrócone zadania zostanie oznaczony jako błąd z powodu wyjątku. Implementacja zwraca klasę Task, bez blokowania wątek wywołujący dla puli i niebuforowanych połączeń.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>, <xref:System.Data.SqlClient.SqlConnection.State%2A> musi zwracać <xref:System.Data.ConnectionState.Connecting> do zwróconego <xref:System.Threading.Tasks.Task> zostało zakończone. Następnie, jeśli połączenie zakończyło się pomyślnie, <xref:System.Data.SqlClient.SqlConnection.State%2A> musi zwracać <xref:System.Data.ConnectionState.Open>. Jeśli połączenie nie powiedzie się, <xref:System.Data.SqlClient.SqlConnection.State%2A> musi zwracać <xref:System.Data.ConnectionState.Closed>.  
  
 Wywołanie <xref:System.Data.SqlClient.SqlConnection.Close%2A> podejmie próbę anulowania lub zamknąć odpowiadającego <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A> wywołania.  
  
 Aby uzyskać więcej informacji na temat programowania asynchronicznego w programie .NET Framework Data Provider for SQL Server, zobacz [programowania asynchronicznego](~/docs/framework/data/adonet/asynchronous-programming.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywoływanie <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" /> więcej niż raz dla tego samego wystąpienia przed ukończeniem zadania.  
  
 <see langword="Context Connection=true" /> określono w parametrach połączenia.  Połączenie nie jest dostępna z puli połączeń przed upływem limitu czasu połączenia.</exception>
        <exception cref="T:System.Data.SqlClient.SqlException">Błędu zwrócony przez program SQL Server, który wystąpił podczas otwierania połączenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="PacketSize">
      <MemberSignature Language="C#" Value="public int PacketSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PacketSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.PacketSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PacketSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PacketSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar (w bajtach) pakietów sieciowych używanych do komunikowania się z wystąpieniem programu SQL Server.</summary>
        <value>Rozmiar (w bajtach) pakietów sieciowych. Wartość domyślna to 8000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja wykonuje operacje kopiowania masowego, lub wysyła lub odbiera duże ilości danych tekstowych lub graficznych, rozmiar pakietu jest większy niż domyślny może zwiększyć wydajność, ponieważ powoduje ona mniejszą liczbę sieci operacje odczytu i zapisu. Jeśli aplikacja wysyła i odbiera małe ilości danych, możesz ustawić rozmiar pakietu do 512 bajtów (przy użyciu wartości rozmiaru pakietu w <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>), która jest wystarczające dla większości operacji transferu danych. W przypadku większości aplikacji najlepiej jest domyślny rozmiar pakietu.  
  
 <xref:System.Data.SqlClient.SqlConnection.PacketSize%2A> może być wartością z zakresu bajtów 512 do 32767. Wyjątek jest generowany, jeśli wartość jest poza tym zakresem.  
  
 Ustawienie wartości domyślnej na liczbę większą niż 8000 spowoduje, że pakiety do użycia programu przydzielania wielostronicowe w wystąpieniu programu SQL Server zamiast bardziej efektywnego przydzielania SinglePage, zmniejszenie ogólnej skalowalności programu SQL Server. Aby uzyskać więcej informacji o używaniu pamięć programu SQL Server, zobacz [Memory Architecture](http://go.microsoft.com/fwlink/?LinkId=143705) w dokumentacji SQL Server — książki Online.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection>, włączając ustawienie `Packet Size` do 512 w parametrach połączenia. Wyświetla <xref:System.Data.SqlClient.SqlConnection.PacketSize%2A> i <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> właściwości w oknie konsoli.  
  
 [!code-csharp[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.PacketSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.PacketSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterColumnEncryptionKeyStoreProviders">
      <MemberSignature Language="C#" Value="public static void RegisterColumnEncryptionKeyStoreProviders (System.Collections.Generic.IDictionary&lt;string,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterColumnEncryptionKeyStoreProviders(class System.Collections.Generic.IDictionary`2&lt;string, class System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt; customProviders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RegisterColumnEncryptionKeyStoreProviders(System.Collections.Generic.IDictionary{System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterColumnEncryptionKeyStoreProviders (customProviders As IDictionary(Of String, SqlColumnEncryptionKeyStoreProvider))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterColumnEncryptionKeyStoreProviders(System::Collections::Generic::IDictionary&lt;System::String ^, System::Data::SqlClient::SqlColumnEncryptionKeyStoreProvider ^&gt; ^ customProviders);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customProviders" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider&gt;" />
      </Parameters>
      <Docs>
        <param name="customProviders">Dostawcy niestandardowi</param>
        <summary>Rejestruje dostawców magazynu kluczy szyfrowania kolumn.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetStatistics">
      <MemberSignature Language="C#" Value="public void ResetStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.ResetStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetStatistics ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetStatistics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Jeśli włączono zbierania statystyk, wszystkie wartości są resetowane do zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd nie jest generowany, jeśli zbierania statystyk nie jest włączona, ta metoda jest wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetrieveStatistics">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary RetrieveStatistics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IDictionary RetrieveStatistics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.RetrieveStatistics" />
      <MemberSignature Language="VB.NET" Value="Public Function RetrieveStatistics () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IDictionary ^ RetrieveStatistics();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję pary wartości nazwy statystyk w punkcie w czasie, gdy zostanie wywołana metoda.</summary>
        <returns>Zwraca odwołanie typu <see cref="T:System.Collections.IDictionary" /> z <see cref="T:System.Collections.DictionaryEntry" /> elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta metoda jest wywoływana, wartości pobierane, są lokalizacje w bieżącym punkcie w czasie. Jeśli będziesz kontynuować, przy użyciu połączenia, wartości są niepoprawne. Musisz ponownie wykonaj metodę, aby uzyskać najbardziej aktualne wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerVersion">
      <MemberSignature Language="C#" Value="public override string ServerVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServerVersion" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.ServerVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ServerVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ServerVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który zawiera wersja wystąpienia programu SQL Server, z którym klient jest połączony.</summary>
        <value>Wersja wystąpienia programu SQL Server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wersja jest w formie *##. ##. ###*, gdzie pierwsze dwie cyfry są wersji głównej obok dwie cyfry są wersja pomocnicza i wersji są cztery ostatnie cyfry. Ten ciąg ma postać *major.minor.build*, gdzie jest to główna i pomocnicza są dokładnie dwie cyfry i kompilacja jest dokładnie cztery cyfry.  
  
 <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> została wywołana w czasie zwrócony zadanie nie zostało ukończone i połączenie nie zostało ono otwarte po wywołaniu <xref:System.Data.SqlClient.SqlConnection.OpenAsync%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i wyświetla <xref:System.Data.SqlClient.SqlConnection.ServerVersion%2A> właściwości.  
  
 [!code-csharp[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/CS/source.cs#1)]
 [!code-vb[Classic WebData ISqlConnection.ServerVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData ISqlConnection.ServerVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Połączenie jest zamknięte.  
  
 <see cref="P:System.Data.SqlClient.SqlConnection.ServerVersion" /> została wywołana w czasie zwrócony zadanie nie zostało ukończone i połączenie nie zostało ono otwarte po wywołaniu <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public override System.Data.ConnectionState State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.ConnectionState State" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.State" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property State As ConnectionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::ConnectionState State { System::Data::ConnectionState get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbConnection.State</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConnectionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje stan <see cref="T:System.Data.SqlClient.SqlConnection" /> podczas ostatniej operacji sieciowej wykonywane w ramach połączenia.</summary>
        <value>
          <see cref="T:System.Data.ConnectionState" /> Wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca <xref:System.Data.ConnectionState> Wyliczenie wskazujące stan <xref:System.Data.SqlClient.SqlConnection>. Zamknąć i otworzyć ponownie połączenia zostanie odświeżony wartość <xref:System.Data.SqlClient.SqlConnection.State%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StatisticsEnabled">
      <MemberSignature Language="C#" Value="public bool StatisticsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StatisticsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.StatisticsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property StatisticsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StatisticsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jeśli wartość <see langword="true" />, statystyk umożliwia zbieranie dla bieżącego połączenia.</summary>
        <value>Zwraca <see langword="true" /> Jeśli zbierania statystyk jest włączone; w przeciwnym razie <see langword="false" />. <see langword="false" /> jest ustawieniem domyślnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Włączenie zbierania statystyk ma pomocniczej, ale zauważalnego wpływu na wydajność i w związku z tym powinna być włączona tylko wtedy, gdy jest to wymagane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlClient.SqlConnection.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy obiekt, który jest kopią bieżącego wystąpienia.</summary>
        <returns>Nowy obiekt będący kopią tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.SqlClient.SqlConnection> wystąpienia jest rzutowane na <xref:System.ICloneable> interfejsu.  
  
 Ten element członkowski jest obsługiwana tylko przez program .NET Compact Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkstationId">
      <MemberSignature Language="C#" Value="public string WorkstationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkstationId" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlClient.SqlConnection.WorkstationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkstationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkstationId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.SqlClient</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg, który identyfikuje klienta bazy danych.</summary>
        <value>Ciąg, który identyfikuje klienta bazy danych. Jeśli nie zostanie określony, nazwa komputera klienckiego. Jeśli nie określono wartość jest ciągiem pustym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg zawiera zwykle nazwę sieciową klienta. <xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A> Właściwość odpowiada `Workstation ID` właściwość parametrów połączenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.SqlClient.SqlConnection> i wyświetla <xref:System.Data.SqlClient.SqlConnection.WorkstationId%2A> właściwości.  
  
 [!code-csharp[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlConnection.WorkstationId Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlConnection.WorkstationId Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
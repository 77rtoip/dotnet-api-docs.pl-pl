<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81d50a3ca76157834fc7eb0634ae1d13af8fe855" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36444394" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia identyfikatora systemowego typu XAML dla elementów członkowskich typu XAML. Identyfikator jest używany przez czytelników XAML i zapisywania XAML podczas przetwarzania elementu członkowskiego węzłów (gdy czytnik XAML jest ustawiony na <see cref="F:System.Xaml.XamlNodeType.StartMember" />), a także na ogólne logiki system typu XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> Służy do zwracania informacji dotyczących składnika XAML trzy metody: standardowy wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) odbicia; technika odbicia tylko odwołanie do wywoływania wewnętrznych interfejsów API tego bit użycie zoptymalizowanych flagi; lub wywołanie wirtualnej zastąpień o `Lookup*` interfejsu API, który jest obsługiwane przez możliwości <xref:System.Xaml.XamlMember> podklasy. Dla większości korzysta z interfejsów API architektury .NET Framework XAML usług i <xref:System.Xaml.XamlMember> interfejsu API, użyj domyślny kontekst schematu XAML. Domyślny kontekst schematu XAML dla programu .NET Framework XAML Services używa kopii systemu typu CLR. Dzięki temu czytników XAML i zapisywania XAML do pracy z dowolnego typu lub elementu członkowskiego, który jest zdefiniowany w lub w inny sposób dostępne do, środowiska CLR i jego technik odbicia.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Interfejsy API wyszukiwania * i XamlMember klas pochodnych  
 <xref:System.Xaml.XamlMember> definiuje kilka wirtualnych elementów członkowskich, które klasy pochodne mogą zastąpić. Członkowie mają nazwy, zawsze rozpoczynających się od ciągu `Lookup`. W pozostałej części interfejsu API nazwę odwołania następnie właściwość, która wpływa na metodę wirtualną. Na przykład <xref:System.Xaml.XamlMember> klasy pochodne mogą zastąpić <xref:System.Xaml.XamlMember.LookupTargetType%2A> wpływ jakie zdefiniowane base właściwość <xref:System.Xaml.XamlMember.TargetType%2A> zwraca w klasie pochodnej. Istnieje przewidywania wartości zwracane dla takich właściwości w <xref:System.Xaml.XamlMember> lub istniejących klas pochodnych przeczytaj dokumentację, aby uzyskać odpowiednie `Lookup*` metody.  
  
 Celem `Lookup*` metod jest zapewnienie technika rozszerzenia systemu typu XAML, która będzie zawierała <xref:System.Xaml.XamlMember> klasy podstawowej. Przez pochodny <xref:System.Xaml.XamlMember> i zastępowanie `Lookup` wirtualne elementy członkowskie, można zdefiniować pojęcie elementu członkowskiego XAML dla schematu XAML w systemie typów języka XAML nie będąc związanym z charakterystykę bazowego typu systemu lub technologii. Można również użyć podany kontekst schematu XAML w ramach tego programu i nadal zwracania wyników, który ma.  
  
 Na przykład należy wziąć pod uwagę <xref:System.Xaml.XamlMember> właściwości <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Ta właściwość informuje wywołań tej operacji, takich jak przy użyciu <xref:System.Xaml.XamlWriter> dla serializacji można zapisać wartości dla tego elementu członkowskiego na obiekcie docelowym. W implementacji domyślnej określenie, czy element członkowski jest zapisywalny jest nawiązywane za pomocą techniki odbicia przed zapasowy CLR <xref:System.Type> i jej elementów członkowskich ( <xref:System.Reflection.MemberInfo>). W związku z tym domyślnie system typów języka XAML zależy od system typów CLR. Jednak usunąć tę zależność potrzeby system typu XAML raportu z <xref:System.Xaml.XamlMember.IsWritePublic%2A> przez zastąpienie interfejsu API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. W ramach zastąpienia, można użyć innych oznaczeń, takich jak metadanych, które dotyczą technologii, z tabeli odnośników głównego jest zoptymalizowana pod kątem stałym słownictwa XAML lub różne inne strategie, określając, czy element członkowski XAML jest zapisywalny w sieci Słownik XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Konstruowanie XamlMember bez kontekst schematu XAML  
 Większość konstruktorów <xref:System.Xaml.XamlMember> wymagają <xref:System.Xaml.XamlSchemaContext> jako część ich inicjowania. <xref:System.Xaml.XamlSchemaContext> Jest także niezbędne dla wielu wewnętrzny <xref:System.Xaml.XamlSchemaContext> operacji, takich jak uzyskanie informacji, które są przekazywane z zapasowego typu. Podczas pracy z <xref:System.Xaml.XamlMember> interfejsu API, zwykle masz <xref:System.Xaml.XamlSchemaContext> nie jest dostępna z otaczającego konstrukcja takich jak <xref:System.Xaml.XamlWriter>. W takim przypadku można przekazać <xref:System.Xaml.XamlSchemaContext> odwoływać się do wszystkich XAML typu wywołań systemowych wymagających kontekst schematu XAML.  
  
 Jeden konstruktor określonych, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, nie wymaga <xref:System.Xaml.XamlSchemaContext>. Jednak <xref:System.Xaml.XamlMember> który jest tworzony z <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, taki element członkowski nie może zostać zapisany do obiektu wykresu. Przy użyciu implementacji usługi .NET Framework XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> , który ma wartość `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> chyba, że wdrożenie może obsłużyć wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład jeden lub więcej z następujących czynności może mieć wartość true implementacji:  
  
-   Kontekst schematu XAML jest dostępny w później.  
  
-   Możesz użyć wzorzec wywołujący element członkowski.  
  
-   Świadomie przesłonić <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowych zapisywania XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System typów CLR <see cref="T:System.Reflection.EventInfo" /> reprezentujący element członkowski zdarzeń.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.EventInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje zdarzenie (właściwość punktu połączenia programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System typów CLR <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący elementu właściwości.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.PropertyInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje właściwość (a w szczególności nie jest połączenie programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System typów CLR <see cref="T:System.Reflection.EventInfo" /> reprezentujący element członkowski zdarzeń.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która obsługuje w czasie wykonywania odbicia wywołuje przed <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.EventInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />, takie jak <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje zdarzenia (lub punktu połączenia właściwością programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System typów CLR <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący elementu właściwości.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Wywołuje implementację, która obsługuje wywołania środowiska wykonawczego przed <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu odbicia <see cref="T:System.Reflection.PropertyInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />, takie jak <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor należy używać tylko wtedy, gdy element członkowski reprezentuje właściwości i jeśli nie jest połączenie programu obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu możliwej zdarzenia.</param>
        <param name="adder">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> obsługi <see langword="Add" /> metody dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący zdarzenie możliwe do dołączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje elementu członkowskiego zdarzenia możliwe do dołączenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa ciągu elementu członkowskiego.</param>
        <param name="declaringType">
          <see cref="T:System.Xaml.XamlType" /> Informacje dotyczące typu deklarującego.</param>
        <param name="isAttachable">
          <see langword="true" /> Aby wskazać, że element członkowski jest możliwy do dołączenia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy za pomocą nazwy ciągu i typ deklarujący <see cref="T:System.Xaml.XamlType" /> informacji. A <see cref="T:System.Xaml.XamlMember" /> który jest tworzony z tym podpis ma zasadnicze ograniczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> który jest tworzony z <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, taki element członkowski nie może zostać zapisany do obiektu wykresu. Przy użyciu implementacji usług .NET Framework XAML <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> z <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` chyba, że wdrożenie może obsłużyć wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład jeden lub więcej z następujących czynności może mieć wartość true implementacji:  
  
-   Kontekst schematu XAML jest dostępny w później.  
  
-   Możesz użyć wzorzec wywołujący element członkowski.  
  
-   Świadomie przesłonić <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowych zapisywania XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> lub <paramref name="declaringType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu właściwości z możliwością dołączenia.</param>
        <param name="getter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="get" /> akcesor dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="setter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="set" /> akcesor dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący dołączalna właściwość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje dołączalna właściwość, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu możliwej zdarzenia.</param>
        <param name="adder">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> obsługi <see langword="Add" /> metody dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Wywołuje implementację, która obsługuje wywołania środowiska wykonawczego przed <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący możliwej zdarzenia, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje elementu członkowskiego zdarzenia możliwe do dołączenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu właściwości z możliwością dołączenia.</param>
        <param name="getter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="get" /> akcesor dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="setter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="set" /> akcesor dołączalny element członkowski na tworzenie kopii implementacji.</param>
        <param name="schemaContext">
          <see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się element członkowski.</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Wywołuje implementację, która obsługuje wywołania środowiska wykonawczego przed <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący dołączalna właściwość, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje dołączalna właściwość elementu członkowskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> dla typu, który deklaruje element członkowski, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> Dla typu, który deklaruje element członkowski, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zwykle ustawiana tylko podczas inicjowania i zazwyczaj nie jest `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> informacje mogą być przekazywane w przez konstruktorów dla inicjowania. Przez wywołanie bezpośrednio konstruktory podstawowe inicjowania dla <xref:System.Xaml.XamlMember> klas pochodnych można pominąć niektóre testy wartość wprowadzonych w klasie podstawowej. Inicjowanie pochodnej można zmienić informacje dotyczące relacji zgłoszone członka typu elementu członkowskiego XAML, tak, aby go już wyrównane w oczekiwany sposób informacje o systemie typu jego podstawowej deklaracji CLR. Wszelkie kontroli krytyczny dla zabezpieczeń deklarowanie informacji o typie w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektów zadeklarowany jako obiekt, który służy do ładowanie odłożone języka XAML.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenie ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.DeferringLoader%2A> wywołuje <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> lub określonego zastąpienia tej metody. Dzieje się to w przypadkach, w którym logiki początkowego odbicia wewnętrznych nie już ustawiona informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę <see cref="T:System.Xaml.XamlMember" /> obiektów. Raport tych elementów członkowskich, do których istnieją relacje zależności dla kolejność inicjowania względem to <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.DependsOn%2A> wywołuje <xref:System.Xaml.XamlMember.LookupDependsOn%2A> lub określonego zastąpienia tej metody. Dzieje się to w przypadkach, w którym logiki początkowego odbicia wewnętrznych nie już ustawiona informacje.  
  
 `DependsOn` Można zastosować wzorca do przypadków modelu obiektów, które celowo są sprzeczne z ogólną zasadą XAML. Ogólną zasadą XAML jest, że elementy członkowskie typu, które nie są przekazywane jako tekst inicjowania (lub metody fabryki w XAML 2009) musi mieć możliwość można przypisać w dowolnej kolejności. Stosując `DependsOn` wzorca do elementu członkowskiego, można nakazać autorów XAML zawsze przetworzyć przywoływany element członkowski przed tego elementu członkowskiego. Można zastosować tego wzorca w sytuacjach, gdy wartość bieżącego elementu członkowskiego wymaga kontekstu lub inne informacje, które są dostępne tylko po ustawieniu innego członka.  
  
 `DependsOn` Wzorzec powinny być stosowane rozważnie i zarezerwowane dla scenariuszy właściwości tam, gdzie służy architektury cel. Dużej liczby zależności mieć możliwość spowolnić jej przetwarzanie XAML. Ponadto można uzyskać zależności cykliczne jest, w takim przypadku zachowanie przetwarzania XAML jest niezdefiniowany.  
  
 Przykład `DependsOn` z WPF scenariusze niektórych właściwości na <xref:System.Windows.Controls.ControlTemplate> i <xref:System.Windows.DataTemplate>na <xref:System.Windows.Trigger>i na <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący obiekt jest taki sam <paramref name="obj" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt tego samego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący obiekt jest taki sam <paramref name="other" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Liczba całkowita wartość skrótu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę przestrzeni nazw XAML, gdzie może istnieć tego elementu członkowskiego XAML.</summary>
        <returns>Lista identyfikatorów przestrzeni nazw XAML jako ciągi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> wywołać wyniku <xref:System.Xaml.XamlMember.DeclaringType%2A> skojarzonego z tym <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> implementację, która jest skojarzona z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która jest skojarzona z tym <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Wzorzec jest zaawansowane techniki rozszerzenia system typu XAML. `Invoker` Wzorzec umożliwia wstrzyknąć zachowanie mapowania typu innego schematu, używając nadal definicji system typu XAML z usługami .NET Framework XAML.  
  
 Jeśli <xref:System.Xaml.XamlMember.LookupInvoker%2A> zastąpienia zwraca `null`, lub Jeśli domyślna implementacja zwraca `null` ponieważ brakuje w nim <xref:System.Xaml.XamlMember.UnderlyingMember%2A> tego <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlMember.Invoker%2A> zwraca właściwość <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> jest ustawieniem domyślnym. Jest tak w przypadku większości operacji korzystające z usług .NET Framework XAML i domyślny kontekst schematu XAML i gdzie zastąpienia nie określonych `Invoker` wzorce są przekazywane do tworzenia obiektów systemowych typu XAML.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.Invoker%2A> wywołuje <xref:System.Xaml.XamlMember.LookupInvoker%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> został zgłoszony jako właściwością otoczenia.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> jest zgłoszone jako właściwość otoczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsAmbient%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> lub określonego zastąpienia tej metody. Dzieje się to w implementacjach gdzie logiki początkowego odbicia wewnętrznych nie już ustawiona informacje.  
  
 Sprawdzanie właściwości otaczających jest zwykle są częścią logika przetwarzania XAML, aby upewnić się, że wartości, które opierają się na użycie otoczenia kwalifikację typu obiektów i może działać prawidłowo. Interfejsy API usług .NET Framework XAML i domyślny kontekst schematu XAML wypełnia tej wartości w oparciu o przypisanie z <xref:System.Windows.Markup.AmbientAttribute>. Domyślna implementacja <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> wykorzystuje istniejące tego <xref:System.Windows.Markup.AmbientAttribute> technika który zwraca `true` Jeśli <xref:System.Windows.Markup.AmbientAttribute> istnieje w deklaracji elementu członkowskiego.  
  
 <xref:System.Windows.Markup.AmbientAttribute> znajduje się na elementach członkowskich kilka typów WPF, która obejmuje <xref:System.Windows.Application>, <xref:System.Windows.Setter>, i <xref:System.Windows.Style>. Również znajduje się na <xref:System.Windows.ResourceDictionary> typu, który connotes, że każdy członek używającą <xref:System.Windows.ResourceDictionary> zgodnie z jego typ należy traktować jako otoczenia nawet wtedy, gdy element członkowski nie jest specjalnie przypisane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest dołączalny element członkowski.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> jest dołączalny element członkowski; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAttachable%2A> Wartość została zainicjowana w oparciu Konstruktor, który został użyty do utworzenia <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest dyrektywą XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> jest XAML dyrektywy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsDirective%2A> Wartość została zainicjowana w oparciu Konstruktor, który został użyty do utworzenia <xref:System.Xaml.XamlMember>. Podstawowym <xref:System.Xaml.XamlMember> inicjowania konstruktorów, aby <xref:System.Xaml.XamlMember.IsDirective%2A> jest `false`. Jednak <xref:System.Xaml.XamlDirective> klasy ( <xref:System.Xaml.XamlMember> klasy) inicjuje, aby <xref:System.Xaml.XamlMember.IsDirective%2A> jest `true`.  
  
 Jeśli chcesz zgłosić <xref:System.Xaml.XamlMember.IsDirective%2A> jako `true` wywołań niestandardowej klasy schematu XAML dla członków XAML, upewnij się, pochodzi z <xref:System.Xaml.XamlDirective> ponieważ jest to jedyny sposób włączania tego zachowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje elementu członkowskiego zdarzenia.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsEvent%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsEvent%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest inicjowany z prawidłowym <see langword="xamlName" /> ciąg jako jego <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> jest inicjowany z prawidłowym <see langword="xamlName" /> , ciąg; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsReadOnly%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski o można wywołać publicznej <see langword="get" /> metody dostępu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje można wywołać publicznej <see langword="get" /> akcesor; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> Wartość sprawdza, czy <xref:System.Xaml.XamlMember.DeclaringType%2A> jest publiczny. Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepubliczne, `get` metody dostępu nie można wywołać w sposób praktyczne i <xref:System.Xaml.XamlMember.IsReadPublic%2A> zwraca `false`.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsReadPublic%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> lub określonego zastąpienia tej metody.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metody jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie ma możliwość Zmień (złośliwy lub w inny sposób) informacje zgłoszone dostępu elementu członkowskiego XAML tak, aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu dostępu do informacji o swojej podstawowej deklaracji CLR. Dla dowolnego krytyczny dla zabezpieczeń kontroli poziomy dostępu w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski nie jest rozpoznawana przez bazowego systemu, który jest używany do rozpoznawania typu i element członkowski.</summary>
        <value>
          <see langword="true" /> Jeśli element członkowski nie jest rozwiązywana; <see langword="false" /> Jeśli element członkowski jest rozpoznawana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> który jest tworzony z <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlMember> z `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> nie można zapisać do obiektu wykresu. W domyślnej implementacji w .NET Framework XAML usług API <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> , który ma wartość `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> chyba, że wdrożenie może obsłużyć wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsUnknown%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje tylko do zapisu elementu członkowskiego.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje tylko do zapisu elementu członkowskiego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsWriteOnly%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma można wywołać publicznej <see langword="set" /> metody dostępu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje można wywołać publicznej <see langword="set" /> akcesor; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> Uwzględnia wartość czy <xref:System.Xaml.XamlMember.DeclaringType%2A> jest publiczny jako część określenie. Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepubliczne, `set` metody dostępu nie można wywołać w sposób praktyczne i <xref:System.Xaml.XamlMember.IsWritePublic%2A> zwraca `false`.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsWritePublic%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> lub określonego zastąpienia tej metody.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metody jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie ma możliwość Zmień (złośliwy lub w inny sposób) informacje zgłoszone dostępu elementu członkowskiego XAML tak, aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu dostępu do informacji o swojej podstawowej deklaracji CLR. Dla dowolnego krytyczny dla zabezpieczeń kontroli poziomy dostępu w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej zwraca <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementacji.</summary>
        <returns>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przesłonić tę metodę, aby zapewnić wewnętrzny odbicia z alternatywny sposób uzyskiwania wartości atrybutów CLR. W przypadku braku przesłonięcie wewnętrznego reflektora używa typowe logiki odbicia CLR, takie jak wywołania <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Domyślna implementacja zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektów zadeklarowany jako obiekt, który służy do ładowanie odłożone języka XAML.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mający <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenie ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.DeferringLoader%2A> właściwości. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.DeferringLoader%2A> aby zwrócić wartość, która różni się od wartości, który został włączony przez domyślny odbicia wewnętrznych, i również udostępniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Domyślna implementacja zwraca obiekt albo odczytując <xref:System.Windows.Markup.XamlDeferLoadAttribute> lub przy użyciu <xref:System.Xaml.XamlDeferringLoader> z typ deklarujący. Jeśli żaden obiekt jest dostępny, ta metoda może zwracać `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę <see cref="T:System.Xaml.XamlMember" /> obiektów. Elementy na liście raportu elementów członkowskich, do których istnieją relacje zależności dla kolejność inicjowania względem to <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.DependsOn%2A> właściwości. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.DependsOn%2A> aby zwrócić wartość, która różni się od wartości, który został włączony przez domyślny odbicia wewnętrznych, i również udostępniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Implementacje składników zapisywania i odczytywania WPF XAML atrybutu to miejsce w przypadku <xref:System.Windows.Markup.DependsOnAttribute>. Domyślna implementacja używa tego istniejących <xref:System.Windows.Markup.DependsOnAttribute> technik.  
  
 Przesłonić tę metodę, jeśli nie używasz <xref:System.Windows.Markup.DependsOnAttribute> dla tego celu i mają zamiar zastąpić technika tego wskazująca kolejność przetwarzania właściwości z własnych techniki. Jeśli nie zamierzasz obsługuje kolejność przetwarzania właściwości, można użyć w implementacji domyślnej, ponieważ go nie zwróciło żadnych wyników, który jest odpowiedni.  
  
 Lista jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> skojarzonego z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Informacje na temat tego <see cref="T:System.Xaml.XamlMember" />; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wywołania <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Domyślna implementacja nie wymaga, aby <xref:System.Xaml.XamlMember> można skonstruować za pomocą jednego z konstruktorów, które przekazują początkowej <xref:System.Xaml.Schema.XamlMemberInvoker>. Jednak <xref:System.Xaml.XamlMember.UnderlyingMember%2A> wartości musi istnieć dla <xref:System.Xaml.XamlMember>; w przeciwnym razie wartość domyślna implementacja zwraca `null`.  
  
 Ta metoda musi również pochodzić od <xref:System.Xaml.Schema.XamlMemberInvoker> i zamierzony zwracany typ klasy pochodnej. Jeśli `null`, <xref:System.Xaml.XamlMember.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> dotyczące obiektów wywołujących.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> został zgłoszony jako właściwością otoczenia.</summary>
        <returns>
          <see langword="true" /> Aby zgłosić to <see cref="T:System.Xaml.XamlMember" /> jako właściwość otoczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wewnętrzny wywołania, które Sprawdź, czy informacje o właściwościach otaczającego XAML. Właściwość otoczenia zachowanie jest uwzględnione w publicznych działanie interfejsu API czytników XAML i zapisywania XAML. Wywołania wewnętrznego, które odwołują się <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> są zwykle część logiki przetwarzania XAML, aby upewnić się, że wartości, które opierają się na użycie otoczenia kwalifikację typu obiektów i może działać prawidłowo. Domyślna implementacja usługi XAML .NET Framework używa przypisywanie uzyskać te informacje z odbicia przez tworzenie kopii typów CLR. W szczególności sprawdza Domyślna implementacja <xref:System.Windows.Markup.AmbientAttribute> i zwraca `true` dla <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Jeśli <xref:System.Windows.Markup.AmbientAttribute> istnieje w definicji elementu członkowskiego.  
  
 Przesłonić tę metodę, jeśli nie używasz <xref:System.Windows.Markup.AmbientAttribute> dla tego celu i zamierzasz zamienić technika tego wskazująca właściwości otaczających XAML z własnych techniki.  
  
 Przykład interfejsy API z WPF, która atrybutem <xref:System.Windows.Markup.AmbientAttribute> są <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> i <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie.</summary>
        <returns>
          <see langword="true" /> w raporcie tego <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja domyślnych operacji sprawdzania czy <xref:System.Xaml.XamlMember.UnderlyingMember%2A> jest typu <xref:System.Reflection.EventInfo>, a jeśli tak jest, zwraca `true`.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsEvent%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępnych metadanych, który może zostać zinterpretowany ustalenie XAML typu oświadczenia systemu na poszczególnych przypadków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość przeznaczone tylko do odczytu.</summary>
        <returns>
          <see langword="true" /> Aby zgłosić to <see cref="T:System.Xaml.XamlMember" /> jako zamierzone właściwość tylko do odczytu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` Jeśli <xref:System.Xaml.XamlMember.UnderlyingMember%2A> istnieje, ale publiczny `set` akcesor nie istnieje dla niego, zgodnie z ustaleniami odbicia wewnętrznych.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępnych metadanych, który może zostać zinterpretowany ustalenie XAML typu oświadczenia systemu na poszczególnych przypadków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość, która ma publiczny <see langword="get" /> metody dostępu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość, która ma publiczny <see langword="get" /> akcesor; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki na podstawie odbicia wewnętrznych lub Negacja <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, w tej kolejności przetwarzania.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Zwraca czy ten element członkowski jest publiczny; Zwraca `true` dla publicznego elementu członkowskiego na nonpublic, typem deklarującym. Użyj <xref:System.Xaml.XamlMember.IsReadPublic%2A> zamiast tego, jeśli chcesz również wziąć pod uwagę widoczność typ deklarujący.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metody jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie ma możliwość Zmień (złośliwy lub w inny sposób) informacje zgłoszone dostępu elementu członkowskiego XAML tak, aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu dostępu do informacji o swojej podstawowej deklaracji CLR. Dla dowolnego krytyczny dla zabezpieczeń kontroli poziomy dostępu w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który nie jest rozpoznawana przez bazowego systemu, który jest używany do rozpoznawania typu i element członkowski.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje nie można rozpoznać elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsUnknown%2A>. Domyślna implementacja zwraca wyniki, które są oparte na obu odbicia wewnętrznych lub Sprawdzanie, czy dla `null` wartość <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, w tej kolejności przetwarzania.  
  
 Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publicznego <see langword="set" /> , ale nie publiczny akcesor <see langword="get" /> metody dostępu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje tylko do zapisu elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` Jeśli <xref:System.Xaml.XamlMember.UnderlyingMember%2A> istnieje mający publiczny `set` metody dostępu i nonpublic `get` dostępu, zgodnie z ustaleniami odbicia wewnętrznych.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publicznego <see langword="set" /> metody dostępu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlMember" /> reprezentuje zapisu elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki na podstawie odbicia wewnętrznych lub Negacja <xref:System.Xaml.XamlMember.IsReadOnly%2A>, w tej kolejności przetwarzania.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metody jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie ma możliwość Zmień (złośliwy lub w inny sposób) informacje zgłoszone dostępu elementu członkowskiego XAML tak, aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu dostępu do informacji o swojej podstawowej deklaracji CLR. Dla dowolnego krytyczny dla zabezpieczeń kontroli poziomy dostępu w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znaki nawias otwierający i zamykający dla rozszerzenia znacznika.</summary>
        <returns>Kolekcja zawierająca znaki nawias otwierający i zamykający.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> typu gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</summary>
        <returns>Typ gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja rozróżnia możliwej i niedołączalnego elementów członkowskich. Dla członków niedołączalnego <xref:System.Xaml.XamlMember.LookupTargetType%2A> zawsze zwraca <xref:System.Xaml.XamlMember.DeclaringType%2A>. Dla członków dołączalny <xref:System.Xaml.XamlMember.LookupTargetType%2A> zwraca wynik, w oparciu o sprawdzenie <xref:System.Xaml.XamlMember.UnderlyingMember%2A> typ parametru metody dostępu i interpretuje, że typ oparty na kontekst schematu XAML.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.TargetType%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> typu, który jest używany przez element członkowski.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> Typu, który jest używany przez element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.Type%2A>. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.Type%2A> aby zwrócić wartość, która różni się od wartości, który został włączony przez domyślny odbicia wewnętrznych, i również udostępniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Domyślna implementacja używa różne ścieżki i pojęciach znaczenie dla zwróconego <xref:System.Xaml.XamlType> opartego na czy to <xref:System.Xaml.XamlMember> reprezentuje właściwości, metody lub zdarzenia.  
  
-   Dla właściwości, zwracana <xref:System.Xaml.XamlType> jest typ, który ustawia właściwość jest zwracana przez właściwość.  
  
-   Zdarzenia, zwracana <xref:System.Xaml.XamlType> jest typem obsługi zdarzeń wymagane (delegata w implementacji środowiska CLR).  
  
-   W przypadku metody <xref:System.Xaml.XamlType> jest typ zwracany.  
  
 W każdym przypadku kontekst schematu XAML jest używany do oceny typu XAML z podstawowego typu systemu.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.Type%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca implementacji konwertera typu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wystąpienia z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenia; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następującą logiką i kolejność przetwarzania:  
  
-   Jeśli istnieje przypisywanie na poziomie elementu członkowskiego (<xref:System.ComponentModel.TypeConverterAttribute>), informacje o atrybutach służy do wywołania <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> przed kontekst schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, jest zwracany konwertera typów, który jest skojarzony z typem.  
  
-   Jeśli element członkowski jest zdarzenie, zwracany jest specyficzne dla zdarzenia typu konwertera.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.TypeConverter%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="get" /> dostępu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> Skojarzonych z nim <see langword="get" /> akcesor; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> właściwość jako <xref:System.Reflection.PropertyInfo> i zwraca wartość <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (z parametrem ustawioną `true`), która oznacza, że zwrócony metoda może być niepubliczne. To zachowanie może spowodować `null` określonych przypadkach. w tym przypadkach, gdy istnieje nie skojarzone metody dostępu lub element członkowski nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> właściwość skojarzony <xref:System.Xaml.Schema.XamlMemberInvoker>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych. Upewnij się, że wdrożenie <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie zwracają wyniki skorelowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca system typów CLR <see cref="T:System.Reflection.MemberInfo" /> skojarzonego z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>System typów CLR <see cref="T:System.Reflection.MemberInfo" /> obiekt, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca informacje elementu członkowskiego podstawowej, opartej na konstrukcji. Jeśli <xref:System.Reflection.MemberInfo> obiekt jest tworzony za pomocą podpisu, który nie ma wystarczającej ilości informacji do ustawienia podstawowego elementu członkowskiego, ta metoda zwraca `null`.  
  
 Jeśli element członkowski podstawowej została ustawiona podczas konstruowania, należy nie należy wywołać tę metodę.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych. Upewnij się, że wdrożenie <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie zwracają wyniki skorelowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="set" /> dostępu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> Skojarzonych z nim <see langword="set" /> akcesor; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> jako <xref:System.Reflection.PropertyInfo> i zwraca wartość <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (z parametrem ustawioną `true`), która oznacza, że zwrócony metoda może być niepubliczne. Może to spowodować `null` dla niektórych przypadkach, także w przypadkach, gdy jest nie takiego dostępu, lub element członkowski nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> na skojarzone <xref:System.Xaml.Schema.XamlMemberInvoker>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych. Upewnij się, że wdrożenie <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie zwracają wyniki skorelowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca implementację serializator wartość, która jest skojarzona z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wystąpienia z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następującą logiką i kolejność przetwarzania:  
  
-   Jeśli istnieje przypisywanie na poziomie elementu członkowskiego (<xref:System.Windows.Markup.ValueSerializerAttribute>), informacje o atrybutach służy do wywołania <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> przed kontekst schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, jest zwracany konwerter wartości, który jest skojarzony z typem.  
  
-   Jeśli poprzednie warunki nie są stosowane, `null` jest zwracany.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników uniform dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli znajduje się specjalistyczny dostępne, aby określić to na poszczególnych przypadków metadanych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiuje znaki nawias otwierający i zamykający dla rozszerzenia znacznika.</summary>
        <value>Kolekcja zawierająca znaki nawias otwierający i zamykający.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="xamlName" /> Nazwa ciągu, który deklaruje to <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>
          <see langword="xamlName" /> Nazwa ciągu, który deklaruje to <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zawsze ustawiana podczas konstruowania. Konstruktory, które są implementowane przez <xref:System.Xaml.XamlMember> zwykle Zgłoś wyjątek, jeśli nie określono nazwy początkowej; w związku z tym nie będzie tę właściwość, aby być `null` lub ciąg pusty, jeśli używasz usług domyślne .NET Framework XAML implementacje.  
  
 [Xamlname — gramatyka](~/docs/framework/xaml-services/xamlname-grammar.md) i reguły nazewnictwa dla typu CLR i elementów członkowskich nie są dokładnie intersect. Istnieje możliwość deklaruje nazwę elementu członkowskiego, który jest dozwolony w obszarze CLR, ale nie jest prawidłowy w obszarze nazw XAML. Jeśli to możliwe należy unikać tej sytuacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlMember" /> obiekty mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="xamlMember1" /> jest taka sama jak wartość <paramref name="xamlMember2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlMember" /> obiekty mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="xamlMember1" /> różni się od wartości <paramref name="xamlMember2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera jedna przestrzeń nazw XAML identyfikator URI, który identyfikuje głównej przestrzeni nazw XAML dla tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Identyfikator dla głównej przestrzeni nazw XAML dla tego <see cref="T:System.Xaml.XamlMember" />, jako łańcuch znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Właściwość udostępnia taką samą wartość jak wywołanie <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> , a następnie uzyskiwanie pierwszy ciąg wartości na liście zwracanych. Preferowanym przestrzeni nazw XAML powinien być używany podczas zapisywania elementu członkowskiego z powrotem tekst lub inne oświadczenia, które zachowują informacje o przestrzeni nazw XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wartość, która wskazuje, jak powinna ona przetwarzać element członkowski wizualnego projektanta.</summary>
        <value>Wartość <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wyliczenia. Wartość domyślna to <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> typu gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</summary>
        <value>Typ gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona wartość różni się możliwe do dołączenia i niedołączalnego elementów członkowskich. Dla członków niedołączalnego <xref:System.Xaml.XamlMember.TargetType%2A> zwraca <xref:System.Xaml.XamlMember.DeclaringType%2A>. Dla członków możliwej <xref:System.Xaml.XamlMember.LookupTargetType%2A> zwraca wyniku, który jest oparty na tę logikę:  
  
-   Jeśli odbicia nie można rozpoznać zapasowy (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), ta metoda zwraca wewnętrzny stała, który reprezentuje typ obiektu ogólnego.  
  
-   Jeśli poprzednich warunków nie ma zastosowania, <xref:System.Xaml.XamlMember.LookupTargetType%2A> jest wywoływana. Domyślna implementacja zwraca <xref:System.Xaml.XamlType> opartego na sprawdzenie metod, które implementują `get` i `set` metody dostępu. Klasy mogą zastąpić <xref:System.Xaml.XamlMember.LookupTargetType%2A> do użycia inaczej, takie jak metadanych innych formularzy, które może raportować typy elementów docelowych dla możliwe do dołączenia elementy członkowskie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Reprezentacja ciągu tego <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> typu, który jest używany przez element członkowski.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> Typu, który jest używany przez element członkowski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.Type%2A> wywołuje <xref:System.Xaml.XamlMember.LookupType%2A> lub określonego zastąpienia tej metody. Dzieje się tak, gdy logiki początkowego odbicia wewnętrznych już nie ustawiono informacji.  
  
 Zachowanie domyślne (nie <xref:System.Xaml.XamlMember.LookupType%2A> zastąpienia), zwracana <xref:System.Xaml.XamlType> może mieć inną funkcję koncepcyjnego. Stosuje który znaczenia zależy od tego, czy to <xref:System.Xaml.XamlMember> reprezentuje właściwości, metody lub zdarzenia, jak przedstawiono na poniższej liście:  
  
-   Dla właściwości, zwracana <xref:System.Xaml.XamlType> jest typ, który ustawia właściwość jest zwracana przez właściwość.  
  
-   Zdarzenia, zwracana <xref:System.Xaml.XamlType> jest typem obsługi zdarzeń wymagane (delegata w implementacji środowiska CLR).  
  
-   W przypadku metody <xref:System.Xaml.XamlType> jest typ zwrotny tej metody, które mogą być `null`.  
  
 W każdym przypadku kontekst schematu XAML jest używany do oceny typu XAML z zapasowego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który może służyć do tworzenia konwersji typu XAML zadeklarowany obiektów.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wartości, z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.TypeConverter%2A> wywołuje <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> lub określonego zastąpienia tej metody. Dzieje się tak, gdy logiki początkowego odbicia wewnętrznych już nie ustawiono informacji.  
  
 Implementacje, które zwracają właściwości inną niż null wartość <xref:System.Xaml.XamlMember.TypeConverter%2A> niekoniecznie działającego <xref:System.ComponentModel.TypeConverter>. Poniżej przedstawiono listę możliwych wartości zwracane inną niż null dla <xref:System.Xaml.XamlMember.TypeConverter%2A> i reprezentują te wartości:  
  
-   Wartość zwracana raporty konwerter typu, który ma atrybut specjalnie do tego elementu członkowskiego lub ogólnie na typ docelowy konwertera. To zachowanie jest zazwyczaj jakie większość systemów typu XAML i procesorów XAML, poszukaj w celu utworzenia wystąpienia typu konwertera i wywołanie jego metody.  
  
-   Wartość zwracana raporty konwertera wartości wbudowanych. Istnieje konwerterów dla pewnych operacji wewnętrznych, wykonywanych przez moduł zapisujący XAML. W szczególności konwerterów wartości wbudowanych konwertowanie wartości ciągu nieprzetworzonego atrybutu podstawowych poziom języka XAML. Dla implementacji usług .NET Framework XAML te konwersje typu wbudowanego często przesyła konwertera typów, który jest zdefiniowany w zestawie systemu. Na przykład konwersji dla <xref:System.Int32> wartość zawiera wbudowane przekazywane konwersji i w związku z tym <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> wartości odwołania <xref:System.ComponentModel.Int32Converter>.  
  
-   Wartość zwracana raporty szczególnych przypadkach modelu nieograniczonego obiektów; oznacza to <xref:System.Xaml.XamlMember> ma <xref:System.Xaml.XamlMember.Type%2A> wartość <xref:System.Object>. W takim przypadku <xref:System.Xaml.Schema.XamlValueConverter%601> zgłasza, że <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> jest {`Object}`. Jednak <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> jest `null` , ponieważ nie rzeczywisty typ wystąpienia jest ani do wykonania konwersji. Zamiast tego zachowania modelu obiektu nie można określić do czasu wykonywania, gdy środowisko uruchomieniowe określonych technologii określa obsługi jego wykres obiektu.  
  
 Jeśli dostęp do działającego <xref:System.ComponentModel.TypeConverter> z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, można wywołać metody konwersji. Jednak wiele metod konwersji zależne od kontekstu usługi. Jeśli nie ma tego samego kontekstu usługi dostępne, że konwerter typów oczekuje dla swojej roli typowe zapisywania obiektów dla wykresów obiektów, metod konwertera można zgłaszają wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera system typów CLR <see cref="T:System.Reflection.MemberInfo" /> dostępnej dla elementu członkowskiego, który jest tworzony przez <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" />, lub <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>System typów CLR <see cref="T:System.Reflection.MemberInfo" /> informacji jako rzutowanie z parametrami konstruktora początkowej. A <see cref="T:System.Xaml.XamlMember" /> który jest tworzony z <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> zwraca podpis <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.UnderlyingMember%2A> wywołuje <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> lub określonego zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który jest używany do serializacji wartości XAML zadeklarowany obiektów.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.ValueSerializer%2A> wywołuje <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> lub określonego zastąpienia tej metody. Dzieje się tak, gdy logiki początkowego odbicia wewnętrznych już nie ustawiono informacji.  
  
 Nie wszystkie przypadki, które zwracają właściwości inną niż null wartość <xref:System.Xaml.XamlMember.ValueSerializer%2A> są zawsze działa <xref:System.Windows.Markup.ValueSerializer>. Zobacz <xref:System.Xaml.XamlMember.TypeConverter%2A>; te same kwestie <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
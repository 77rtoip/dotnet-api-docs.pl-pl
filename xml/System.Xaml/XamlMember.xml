<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5bf358cf5bbfc2549fa0d48319a913cdf514495" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51938072" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera identyfikator systemie typu XAML dla składowych typu XAML. Identyfikator jest używany przez XAML czytników i składników zapisywania XAML podczas przetwarzania elementu członkowskiego węzłów (gdy czytnik XAML jest umieszczony na <see cref="F:System.Xaml.XamlNodeType.StartMember" />) a także ogólne logiki systemie typu XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> można użyć trzech metod do zwracania informacji na temat członka XAML: standardowy wspólnego języka środowiska uruchomieniowego (języka wspólnego CLR) odbicia; technika odbicia tylko odwołanie do wywoływania wewnętrznego flagi tego bitu zoptymalizowane pod kątem użycia interfejsów API; lub wywołanie wirtualnej przesłonięć o `Lookup*` interfejsu API, który jest dostarczany przez możliwości <xref:System.Xaml.XamlMember> podklasach. Dla większości zastosowań interfejsów API programu .NET Framework XAML usług i <xref:System.Xaml.XamlMember> interfejsu API, użyj domyślny kontekst schematu XAML. Domyślny kontekst schematu XAML dla programu .NET Framework XAML Services używa kopii systemu typu CLR. Umożliwia to XAML czytniki i moduły zapisujące XAML, do pracy z dowolnego typu lub elementu członkowskiego, który jest zdefiniowany w lub w inny sposób dostępne, CLR i jego technik odbicia.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Interfejsy API wyszukiwania * i XamlMember klasy pochodne  
 <xref:System.Xaml.XamlMember> definiuje kilka wirtualnych elementów członkowskich, które klasy pochodne mogą zastąpić. Te elementy członkowskie mają nazwy, które zawsze rozpoczyna się od ciągu `Lookup`. W pozostałej części interfejsie API Nazwa odwołania następnie właściwość, która ma wpływ na metodę wirtualną. Na przykład <xref:System.Xaml.XamlMember> klasy pochodne mogą zastąpić <xref:System.Xaml.XamlMember.LookupTargetType%2A> do wywierania wpływu na jakie zdefiniowane podstawowa właściwość <xref:System.Xaml.XamlMember.TargetType%2A> zwraca w klasie pochodnej. Możesz przewidzieć wartości zwracane dla tych właściwości w <xref:System.Xaml.XamlMember> lub istniejące klasy pochodne, zapoznając się z dokumentacją odpowiedniego `Lookup*` metody.  
  
 Celem `Lookup*` metody ma na celu dostarczenie technika rozszerzenia systemu typu XAML, która zawiera <xref:System.Xaml.XamlMember> klasy bazowej. Przez pochodząca od <xref:System.Xaml.XamlMember> i zastępowanie `Lookup` wirtualnych elementów członkowskich, można zdefiniować koncepcję elementu XAML dla schematu XAML w systemie typu XAML nie są powiązane szczegółowe informacje na temat zapasowego typu systemu lub technologii. Można również użyć podanej kontekst schematu XAML zgodnie z tym systemem i nadal zwracają wyniki, które chcesz.  
  
 Na przykład należy wziąć pod uwagę <xref:System.Xaml.XamlMember> właściwość <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Ta właściwość informuje wywołań tej operacji, takich jak przy użyciu <xref:System.Xaml.XamlWriter> dla serializacji można napisać wartość dla tego elementu członkowskiego w obiekcie docelowym. W implementacji domyślnej, czy element członkowski jest zapisywalny orzeczenia przy użyciu technik odbicie wobec zapasowego typu CLR <xref:System.Type> i jej elementów członkowskich ( <xref:System.Reflection.MemberInfo>). W związku z tym domyślnie systemie typu XAML jest zależna od systemu typu CLR. Jednak możesz usunąć tę zależność dla systemie typu XAML raportowania z <xref:System.Xaml.XamlMember.IsWritePublic%2A> przez zastąpienie interfejsu API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. W ramach przesłonięcia, można użyć innych oznaczeń, takich jak metadane, które są specyficzne dla technologii, tabeli odnośników master, która jest zoptymalizowana pod kątem stały słownictwa XAML lub różnych innych strategii określania, czy członek XAML jest zapisywalny w sieci Słownictwa XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Konstruowanie XamlMember bez kontekst schematu XAML  
 Większość konstruktory <xref:System.Xaml.XamlMember> wymagają <xref:System.Xaml.XamlSchemaContext> jako część ich inicjowania. <xref:System.Xaml.XamlSchemaContext> Jest również wiele wewnętrznych <xref:System.Xaml.XamlSchemaContext> operacji, takich jak uzyskanie informacji, które są przekazywane z zapasowego typu. Podczas pracy z <xref:System.Xaml.XamlMember> interfejsu API, zwykle ma <xref:System.Xaml.XamlSchemaContext> dostępnej z otaczającego konstrukcji takich jak <xref:System.Xaml.XamlWriter>. W takim przypadku można przekazać <xref:System.Xaml.XamlSchemaContext> odwoływać się za pośrednictwem wszystkich XAML typ wywołań systemowych, które wymagają kontekst schematu XAML.  
  
 Jednego określonego konstruktora, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, nie wymaga <xref:System.Xaml.XamlSchemaContext>. Jednak <xref:System.Xaml.XamlMember> który jest konstruowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, nie można zapisać elementu członkowskiego do wykresu obiektu. Przy użyciu implementacji usług .NET Framework XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> wartością `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> chyba, że Twoja implementacja może obsługiwać wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład co najmniej jeden z następujących czynności mogą być spełnione implementacji:  
  
-   Kontekst schematu XAML jest dostępna w dalszej części.  
  
-   Korzystania z wzorca wywoływania elementu członkowskiego.  
  
-   Zastąp celowo <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowy Edytor XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System typów CLR <see cref="T:System.Reflection.EventInfo" /> reprezentujący element członkowski zdarzenia.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.EventInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje zdarzenie (właściwość punktu połączenia programu obsługi zdarzeń), należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System typów CLR <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący elementu właściwości.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.PropertyInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje właściwość (w szczególności jest połączenie programu obsługi zdarzeń), należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System typów CLR <see cref="T:System.Reflection.EventInfo" /> reprezentujący element członkowski zdarzenia.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która obsługuje w czasie wykonywania odbicia wywołuje względem <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> przy użyciu systemu typów CLR <see cref="T:System.Reflection.EventInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje zdarzenie (lub właściwości punktu połączenia programu obsługi zdarzeń), należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System typów CLR <see cref="T:System.Reflection.PropertyInfo" /> reprezentujący elementu właściwości.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która obsługuje wywołania w czasie wykonywania wywołań względem <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu odbicia <see cref="T:System.Reflection.PropertyInfo" /> i <see cref="T:System.Xaml.XamlSchemaContext" />, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko wtedy, gdy element członkowski reprezentuje właściwość, a jeśli nie jest połączenie programu obsługi zdarzeń, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu, który można dołączyć zdarzenia.</param>
        <param name="adder">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> obsługi <see langword="Add" /> metody, które można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący zdarzenie można dołączyć.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje element członkowski zdarzenia można dołączyć, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa ciągu elementu członkowskiego.</param>
        <param name="declaringType"><see cref="T:System.Xaml.XamlType" /> Informacje dotyczące typu deklarującego.</param>
        <param name="isAttachable"><see langword="true" /> Aby wskazać, że element członkowski można dołączyć; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy za pomocą nazwy ciągu i deklarowanie <see cref="T:System.Xaml.XamlType" /> informacji. A <see cref="T:System.Xaml.XamlMember" /> , jest tworzony w tym podpis ma znaczące ograniczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> który jest konstruowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, nie można zapisać elementu członkowskiego do wykresu obiektu. Przy użyciu implementacji .NET Framework XAML Services <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> z <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` chyba, że Twoja implementacja może obsługiwać wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład co najmniej jeden z następujących czynności mogą być spełnione implementacji:  
  
-   Kontekst schematu XAML jest dostępna w dalszej części.  
  
-   Korzystania z wzorca wywoływania elementu członkowskiego.  
  
-   Zastąp celowo <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowy Edytor XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> lub <paramref name="declaringType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu, który można dołączyć właściwości.</param>
        <param name="getter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="get" /> dostępu można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="setter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="set" /> dostępu można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentująca właściwości z możliwością dołączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje właściwości z możliwością dołączenia, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu, który można dołączyć zdarzenia.</param>
        <param name="adder">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> obsługi <see langword="Add" /> metody, które można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która obsługuje wywołania w czasie wykonywania wywołań względem <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentujący zdarzenie można dołączyć tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje element członkowski zdarzenia można dołączyć, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu, który można dołączyć właściwości.</param>
        <param name="getter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="get" /> dostępu można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="setter">System typów CLR <see cref="T:System.Reflection.MethodInfo" /> dla <see langword="set" /> dostępu można dołączyć elementu członkowskiego przez tworzenie kopii implementacji.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekstu, które kwalifikują się elementu członkowskiego.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Implementację, która obsługuje wywołania w czasie wykonywania wywołań względem <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy dla <see cref="T:System.Xaml.XamlMember" /> reprezentująca właściwości z możliwością dołączenia, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element członkowski reprezentuje element członkowski można dołączyć właściwości, należy użyć tego konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> dla typu, który deklaruje element członkowski, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Dla typu, który deklaruje element członkowski, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zwykle ustawiana tylko podczas inicjowania i nie jest zazwyczaj `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> informacje mogą być przekazywane w przez konstruktory inicjowania. Za pośrednictwem wywołania bezpośrednio do konstruktorów, inicjowanie <xref:System.Xaml.XamlMember> klasach pochodnych można pominąć niektóre testy wartości, które zostały wprowadzone w klasie bazowej. Inicjowanie pochodnej można zmienić informacje dotyczące relacji zgłoszonych składowej typu elementu członkowskiego XAML, tak, aby go już wyrównane w oczekiwany sposób informacje o systemie typu w swojej podstawowej deklaracji CLR. Dla kontroli zabezpieczenia krytyczny deklarowania informacji o typie należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiekt, który jest używany dla odroczone ładowanie XAML zadeklarowana obiektów.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenia na ogólnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.DeferringLoader%2A> wywołuje <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> lub określone zastąpienia tej metody. Dzieje się to w przypadkach, w którym logiki początkowej odbicia wewnętrznego nie już ustawił informacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę <see cref="T:System.Xaml.XamlMember" /> obiektów. Raport tych członków, jeśli istnieją relacje zależności dla kolejności inicjowania względem tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.DependsOn%2A> wywołuje <xref:System.Xaml.XamlMember.LookupDependsOn%2A> lub określone zastąpienia tej metody. Dzieje się to w przypadkach, w którym logiki początkowej odbicia wewnętrznego nie już ustawił informacje.  
  
 `DependsOn` Wzorca mogą być stosowane do przypadków modelu obiektów, których umyślnie sprzeczne z ogólną zasadą XAML. Ogólną zasadą XAML jest, że elementy członkowskie typu, które nie są przekazywane jako tekst inicjowania (lub za pomocą metody fabryki w XAML 2009) musi być mogły mieć przypisanej w dowolnej kolejności. Stosując `DependsOn` wzorca do elementu członkowskiego, możesz wydać polecenie autorzy XAML aby zawsze przetwarzać przywoływanego elementu członkowskiego przed tego elementu członkowskiego. Można zastosować tego wzorca w sytuacjach, w którym wartość elementu bieżącej wymaga kontekstu lub inne informacje, które są dostępne tylko po ustawieniu elementu członkowskiego.  
  
 `DependsOn` Wzorzec powinny być stosowane rozsądnie i zarezerwowane dla scenariuszy właściwość tam, gdzie służy architektury przeznaczenia. Duża liczba zależności mogą potencjalnie spowolnienia przetwarzania XAML. Ponadto istnieje możliwość do tworzenia zależności cyklicznych, w którym to przypadku XAML przetwarzania zachowanie jest niezdefiniowane.  
  
 Przykład `DependsOn` scenariusze z WPF obejmują niektóre właściwości na <xref:System.Windows.Controls.ControlTemplate> i <xref:System.Windows.DataTemplate>na <xref:System.Windows.Trigger>, a następnie na <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt.</summary>
        <returns><see langword="true" /> Jeśli bieżący obiekt jest równy <paramref name="obj" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt tego samego typu.</summary>
        <returns><see langword="true" /> Jeśli bieżący obiekt jest równy <paramref name="other" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Liczba całkowita wartość skrótu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę przestrzeni nazw XAML, w którym ten element członkowski XAML może istnieć.</summary>
        <returns>Lista identyfikatorów przestrzeń nazw XAML jako ciągi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> wynik z połączenia <xref:System.Xaml.XamlMember.DeclaringType%2A> skojarzony z tym <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> wdrożenia, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Wdrożenia, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Wzorzec jest zaawansowanej techniki rozszerzenia systemie typu XAML. `Invoker` Wzorzec zapewnia sposób wstrzyknąć zachowanie mapowania typu innego schematu, używając przy tym nadal definicji systemie typu XAML z usług programu .NET Framework XAML.  
  
 Jeśli <xref:System.Xaml.XamlMember.LookupInvoker%2A> zastąpienia zwraca `null`, lub Jeśli domyślna implementacja zwraca `null` ponieważ brakuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> tego <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlMember.Invoker%2A> właściwość zwraca <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> jest ustawieniem domyślnym. Jest tak w przypadku większości operacji, które korzystają z usług programu .NET Framework XAML i domyślny kontekst schematu XAML i gdzie zastąpienia nie określonych `Invoker` wzorce są przekazywane do tworzenia jednostek systemie typu XAML.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.Invoker%2A> wywołuje <xref:System.Xaml.XamlMember.LookupInvoker%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> zgłaszane właściwości otoczenia.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> jest zgłaszane jako zmieniono właściwość; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsAmbient%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> lub określone zastąpienia tej metody. Dzieje się to w implementacji, gdzie logiki początkowej odbicia wewnętrznego nie już ustawił informacje.  
  
 Sprawdzanie właściwości otoczenia jest są zazwyczaj część logiki przetwarzania XAML, aby upewnić się, że obiektów i wartości, które opierają się na użycie otoczenia kwalifikację typu może działać prawidłowo. Interfejsy API programu .NET Framework XAML Services i domyślny kontekst schematu XAML wypełnienie tej wartości, w oparciu o uznanie autorstwa z <xref:System.Windows.Markup.AmbientAttribute>. Domyślna implementacja klasy <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> wykorzystuje istniejące to <xref:System.Windows.Markup.AmbientAttribute> technika i zwróci ono `true` Jeśli <xref:System.Windows.Markup.AmbientAttribute> istnieje w deklaracji elementu członkowskiego.  
  
 <xref:System.Windows.Markup.AmbientAttribute> znajduje się na elementach członkowskich kilka typów WPF, która obejmuje <xref:System.Windows.Application>, <xref:System.Windows.Setter>, i <xref:System.Windows.Style>. Również znajduje się na <xref:System.Windows.ResourceDictionary> typ, który connotes, że każdy członek korzystającą <xref:System.Windows.ResourceDictionary> zgodnie z jego typ należy rozważyć otoczenia nawet wtedy, gdy element członkowski nie jest specjalnie przypisane.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest elementem członkowskim można dołączyć.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> jest elementem członkowskim można dołączyć; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAttachable%2A> Wartość jest inicjowany, oparte na Konstruktor, który został użyty do utworzenia <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest dyrektywa XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> jest XAML dyrektywę; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsDirective%2A> Wartość jest inicjowany, oparte na Konstruktor, który został użyty do utworzenia <xref:System.Xaml.XamlMember>. Podstawa <xref:System.Xaml.XamlMember> konstruktory inicjują tak, aby <xref:System.Xaml.XamlMember.IsDirective%2A> jest `false`. Jednak <xref:System.Xaml.XamlDirective> klasy ( <xref:System.Xaml.XamlMember> klasy pochodnej) inicjuje tak, aby <xref:System.Xaml.XamlMember.IsDirective%2A> jest `true`.  
  
 Jeśli chcesz zgłosić <xref:System.Xaml.XamlMember.IsDirective%2A> jako `true` wywołań niestandardowej klasy schematu XAML dla członków XAML, upewnij się, pochodzi z <xref:System.Xaml.XamlDirective> ponieważ jest jedynym sposobem, aby włączyć to zachowanie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski zdarzenia.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsEvent%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsEvent%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> jest inicjowana przy użyciu prawidłowego <see langword="xamlName" /> ciąg jako jego <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> jest inicjowana przy użyciu prawidłowego <see langword="xamlName" /> ciągu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje członkiem tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje członkiem tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsReadOnly%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje Członkowskie z publiczną wywoływalnej <see langword="get" /> metody dostępu.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje wywoływane publicznego <see langword="get" /> akcesor; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> Wartość sprawdza, czy <xref:System.Xaml.XamlMember.DeclaringType%2A> jest publiczny. Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepublicznych, `get` dostępu nie jest możliwy do wywołania w praktyczny sposób i <xref:System.Xaml.XamlMember.IsReadPublic%2A> zwraca `false`.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsReadPublic%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> lub określone zastąpienia tej metody.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metoda jest wirtualna i dlatego może zostać zastąpiona. Przesłonięcie ma możliwość zmiany (złośliwie i w inny sposób) informacje zgłoszone dostępu do elementu członkowskiego XAML, aby go już wyrównane w oczekiwany sposób system dostępu do informacji o typie jego podstawowej deklaracji CLR. Dla kontroli zabezpieczenia krytyczny poziomów dostępu należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski nie jest rozpoznawana przez system zapasowy, który jest używany do rozpoznawania typów i elementów członkowskich.</summary>
        <value><see langword="true" /> Jeśli element członkowski nie jest rozpoznawana; <see langword="false" /> , jeśli element jest rozpoznawana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> który jest konstruowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> zwraca podpis `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlMember> z `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> nie mogą być zapisywane do wykresu obiektu. W domyślnej implementacji w .NET Framework XAML usług interfejsów API <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy konstruować <xref:System.Xaml.XamlMember> wartością `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A> chyba, że Twoja implementacja może obsługiwać wyjątki od <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsUnknown%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje członkiem tylko do zapisu.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje tylko do zapisu elementu członkowskiego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.IsWriteOnly%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publiczny wywoływane <see langword="set" /> metody dostępu.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje wywoływane publicznego <see langword="set" /> akcesor; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> Uwzględnia wartość czy <xref:System.Xaml.XamlMember.DeclaringType%2A> jest publiczna w ramach określania. Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepublicznych, `set` dostępu nie jest możliwy do wywołania w praktyczny sposób i <xref:System.Xaml.XamlMember.IsWritePublic%2A> zwraca `false`.  
  
 Wywoływanie <xref:System.Xaml.XamlMember.IsWritePublic%2A> wywołuje <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> lub określone zastąpienia tej metody.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metoda jest wirtualna i dlatego może zostać zastąpiona. Przesłonięcie ma możliwość zmiany (złośliwie i w inny sposób) informacje zgłoszone dostępu do elementu członkowskiego XAML, aby go już wyrównane w oczekiwany sposób system dostępu do informacji o typie jego podstawowej deklaracji CLR. Dla kontroli zabezpieczenia krytyczny poziomów dostępu należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej zwraca <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementacji.</summary>
        <returns><see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępuje tę metodę zapewnienie wewnętrznego odbicia alternatywny sposób uzyskiwania wartości atrybutu CLR. W przypadku braku zastąpienia wewnętrzne odblaskowego używa typowe logiki odbicia CLR, takie jak wywołania <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Domyślna implementacja zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiekt, który jest używany dla odroczone ładowanie XAML zadeklarowana obiektów.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> zawierający <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenia na ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.DeferringLoader%2A> właściwości. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.DeferringLoader%2A> do zwracają wartość, która różni się od wartości, która została włączona przez odbicie wewnętrzny domyślny, i jeśli są jednocześnie zapewniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Domyślna implementacja zwraca obiekt, za odczytywanie <xref:System.Windows.Markup.XamlDeferLoadAttribute> lub za pomocą <xref:System.Xaml.XamlDeferringLoader> z typ deklarujący. Jeśli żaden obiekt jest dostępny, ta metoda może zwrócić `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę <see cref="T:System.Xaml.XamlMember" /> obiektów. Elementy na liście raportu członków, jeśli istnieją relacje zależności dla kolejności inicjowania względem tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.DependsOn%2A> właściwości. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.DependsOn%2A> do zwracają wartość, która różni się od wartości, która została włączona przez odbicie wewnętrzny domyślny, i jeśli są jednocześnie zapewniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Implementacje WPF XAML czytników i składników zapisywania atrybutu to miejsce w przypadku <xref:System.Windows.Markup.DependsOnAttribute>. Domyślna implementacja używa tego istniejącego <xref:System.Windows.Markup.DependsOnAttribute> techniki.  
  
 Przesłonić tę metodę, jeśli nie używasz <xref:System.Windows.Markup.DependsOnAttribute> dla tego zastosowania i zamierzasz zastąpienia tego technika wskazującą kolejność przetwarzania właściwości przy użyciu własnych techniki. Jeśli nie zamierzasz obsługiwać kolejność przetwarzania właściwości, można użyć domyślną implementację, ponieważ on nie zwróciło żadnych wyników, który jest odpowiedni.  
  
 Lista jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Informacje na temat tego <see cref="T:System.Xaml.XamlMember" />; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wywołania <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Domyślna implementacja nie wymaga <xref:System.Xaml.XamlMember> można skonstruować przy użyciu jednego z konstruktorów, zaliczonych początkową <xref:System.Xaml.Schema.XamlMemberInvoker>. Jednak <xref:System.Xaml.XamlMember.UnderlyingMember%2A> wartości, musi istnieć przez <xref:System.Xaml.XamlMember>; w przeciwnym razie zwraca wartość domyślną implementację `null`.  
  
 Należy przesłonić tę metodę w przypadku również dziedziczyć <xref:System.Xaml.Schema.XamlMemberInvoker> i zamierzony zwracany typ klasy pochodnej. Po powrocie `null`, <xref:System.Xaml.XamlMember.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> dotyczące obiektów wywołujących.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> zgłaszane właściwości otoczenia.</summary>
        <returns><see langword="true" /> Aby zgłosić to <see cref="T:System.Xaml.XamlMember" /> jako właściwość otoczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wewnętrzny wywołania, które Sprawdź, czy informacje o właściwości otoczenia XAML. Zachowanie właściwości otoczenia jest uwzględnione w publicznych zachowanie interfejsu API XAML czytników i składników zapisywania XAML. Wewnętrznego wywołań, które odwołują się <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> są zwykle część logiki przetwarzania XAML, aby upewnić się, że obiektów i wartości, które opierają się na użycie otoczenia kwalifikację typu może działać prawidłowo. Domyślna implementacja programu .NET Framework XAML Services używa przypisywanie uzyskać te informacje z odbicia przez tworzenie kopii typu CLR. W szczególności Domyślna implementacja sprawdza, czy <xref:System.Windows.Markup.AmbientAttribute> i zwraca `true` dla <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Jeśli <xref:System.Windows.Markup.AmbientAttribute> istnieje w definicji elementu członkowskiego.  
  
 Przesłonić tę metodę, jeśli nie używasz <xref:System.Windows.Markup.AmbientAttribute> dla tego zastosowania i zamierzasz zamienić tej techniki do wskazywania właściwości otoczenia XAML przy użyciu własnych techniki.  
  
 Przykład interfejsy API z WPF, która atrybutem <xref:System.Windows.Markup.AmbientAttribute> są <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> i <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> przedstawia zdarzenie.</summary>
        <returns><see langword="true" /> do raportu że <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne sprawdzanie, czy implementacja czy <xref:System.Xaml.XamlMember.UnderlyingMember%2A> typu <xref:System.Reflection.EventInfo>, a jeśli tak jest, zwraca `true`.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsEvent%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli masz specjalnych dostępnych metadanych, który może być interpretowany w celu określenia XAML typ oświadczenia systemu na poszczególnych przypadków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje zamierzony właściwość tylko do odczytu.</summary>
        <returns><see langword="true" /> Aby zgłosić to <see cref="T:System.Xaml.XamlMember" /> jako zamierzone właściwość tylko do odczytu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` Jeśli <xref:System.Xaml.XamlMember.UnderlyingMember%2A> istnieje, ale publiczny `set` akcesor nie istnieje, zgodnie z ustaleniami wewnętrznego odbicia.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, lub jeśli masz specjalnych dostępnych metadanych, który może być interpretowany w celu określenia XAML typ oświadczenia systemu na poszczególnych przypadków.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość, która ma publiczny <see langword="get" /> metody dostępu.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość, która ma publiczny <see langword="get" /> akcesor; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki oparte na wewnętrznych odbicia lub negację <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, przetwarzania w tej kolejności.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Zwraca czy ten element członkowski jest publiczny; Zwraca `true` publicznego elementu członkowskiego na nonpublic deklarowania typu. Użyj <xref:System.Xaml.XamlMember.IsReadPublic%2A> zamiast tego, jeśli chcesz również wziąć pod uwagę widoczność typ deklarujący.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metoda jest wirtualna i dlatego może zostać zastąpiona. Przesłonięcie ma możliwość zmiany (złośliwie i w inny sposób) informacje zgłoszone dostępu do elementu członkowskiego XAML, aby go już wyrównane w oczekiwany sposób system dostępu do informacji o typie jego podstawowej deklaracji CLR. Dla kontroli zabezpieczenia krytyczny poziomów dostępu należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który nie jest rozpoznawana przez system zapasowy, który jest używany do rozpoznawania typów i elementów członkowskich.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje nie można rozpoznać elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływane, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsUnknown%2A>. Domyślna implementacja zwraca wyniki, które są oparte na obu wewnętrznego odbicia lub Sprawdzanie, czy dla `null` wartość <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, przetwarzania w tej kolejności.  
  
 Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publiczną <see langword="set" /> , ale nie publiczny akcesor <see langword="get" /> metody dostępu.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje tylko do zapisu elementu członkowskiego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca `true` Jeśli <xref:System.Xaml.XamlMember.UnderlyingMember%2A> istnieje ma publiczną `set` metody dostępu i nonpublic `get` dostępu, zgodnie z ustaleniami wewnętrznego odbicia.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publiczną <see langword="set" /> metody dostępu.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlMember" /> reprezentuje składnik zapisu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki na podstawie odbicia wewnętrznego lub negację <xref:System.Xaml.XamlMember.IsReadOnly%2A>, przetwarzania w tej kolejności.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metoda jest wirtualna i dlatego może zostać zastąpiona. Przesłonięcie ma możliwość zmiany (złośliwie i w inny sposób) informacje zgłoszone dostępu do elementu członkowskiego XAML, aby go już wyrównane w oczekiwany sposób system dostępu do informacji o typie jego podstawowej deklaracji CLR. Dla kontroli zabezpieczenia krytyczny poziomów dostępu należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znaki nawias otwierający i zamykający rozszerzenia znaczników.</summary>
        <returns>Kolekcja zawierająca znaki nawias otwierający i zamykający.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> typu gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</summary>
        <returns>Typ gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja rozróżnia można dołączyć i nie można dołączyć elementy członkowskie. Nie można dołączyć członków <xref:System.Xaml.XamlMember.LookupTargetType%2A> zawsze zwraca <xref:System.Xaml.XamlMember.DeclaringType%2A>. W przypadku członków można dołączyć <xref:System.Xaml.XamlMember.LookupTargetType%2A> zwraca wynik, w oparciu o badanie <xref:System.Xaml.XamlMember.UnderlyingMember%2A> typ parametru metody dostępu i interpretuje, że typ oparty na kontekst schematu XAML.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.TargetType%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> typu, który jest używany przez element członkowski.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> Typu, który jest używany przez element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.Type%2A>. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlMember.Type%2A> do zwracają wartość, która różni się od wartości, która została włączona przez odbicie wewnętrzny domyślny, i jeśli są jednocześnie zapewniając niestandardowe <xref:System.Xaml.Schema.XamlMemberInvoker> informacji.  
  
 Domyślna implementacja używa inny kod ścieżki i pojęciach znaczenie dla zwracanego <xref:System.Xaml.XamlType> opartego na czy to <xref:System.Xaml.XamlMember> reprezentuje właściwości, metody lub zdarzenia.  
  
-   Właściwości zwracanego <xref:System.Xaml.XamlType> to typ, który ustawia właściwość, jest zwracany przez właściwość.  
  
-   Dla każdego zdarzenia zwróconego <xref:System.Xaml.XamlType> jest typ procedury obsługi zdarzeń wymagane (delegata w implementacji środowiska CLR).  
  
-   Dla metody <xref:System.Xaml.XamlType> jest typem zwracanym.  
  
 W każdym przypadku kontekst schematu XAML jest używane do oceny typ XAML z podstawowym typem systemu.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.Type%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ implementacji konwertera, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wystąpienia z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenia; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następujących logikę i kolejność przetwarzania:  
  
-   Jeśli przypisywanie istnieje na poziomie elementu członkowskiego (<xref:System.ComponentModel.TypeConverterAttribute>), informacje o atrybutach służy do wywołania <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> względem kontekst schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, zwracany jest konwertera typów, który jest skojarzony z typem.  
  
-   Jeśli element członkowski jest zdarzenie, zwracany jest konwertera typów specyficznych dla zdarzeń.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.TypeConverter%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="get" /> dostępu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> Skojarzonych z nim <see langword="get" /> akcesor; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> właściwość jako <xref:System.Reflection.PropertyInfo> i zwraca wartość <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (z parametrem ustawionym `true`), co oznacza, że zwracane metody można niepublicznych. To zachowanie może powodować `null` dla niektórych przypadków. w tym przypadkach, gdy istnieje nie skojarzone metody dostępu lub składowa nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> właściwość skojarzoną <xref:System.Xaml.Schema.XamlMemberInvoker>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek. Upewnij się zaimplementować <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie są skorelowane zwracają.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca system typów CLR <see cref="T:System.Reflection.MemberInfo" /> skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>System typów CLR <see cref="T:System.Reflection.MemberInfo" /> obiektu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca informacje elementu członkowskiego podstawowego zależy od konstrukcji. Jeśli <xref:System.Reflection.MemberInfo> obiekt jest konstruowany przy użyciu podpisu, który nie zawiera informacji wystarczających do bazowego elementu członkowskiego zestawu, Metoda ta zwraca `null`.  
  
 Jeśli podstawowy element członkowski został ustawiony podczas konstruowania, nie należy do wywołania tej metody.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek. Upewnij się zaimplementować <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie są skorelowane zwracają.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="set" /> dostępu, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> Skojarzonych z nim <see langword="set" /> akcesor; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> jako <xref:System.Reflection.PropertyInfo> i zwraca wartość <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (z parametrem ustawionym `true`), co oznacza, że zwracane metody można niepublicznych. Może to spowodować `null` w niektórych przypadkach, w tym w przypadkach, gdy nie ma żadnych takich akcesora lub składowa nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> na skojarzoną <xref:System.Xaml.Schema.XamlMemberInvoker>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek. Upewnij się zaimplementować <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, i <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> tak, aby wszystkie są skorelowane zwracają.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość implementację serializator, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wystąpienia z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następujących logikę i kolejność przetwarzania:  
  
-   Jeśli przypisywanie istnieje na poziomie elementu członkowskiego (<xref:System.Windows.Markup.ValueSerializerAttribute>), informacje o atrybutach służy do wywołania <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> względem kontekst schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, zwracany jest skojarzony z typem konwertera wartości.  
  
-   Jeśli poprzednie warunki nie są stosowane, `null` jest zwracana.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Przesłonić tę metodę, jeśli chcesz raportu dotyczącego wyników jednolitego dla całego <xref:System.Xaml.XamlMember> klasy, czy ma wyspecjalizowany metadanych można to ustalić na podstawie na przypadek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiuje nawiasy otwierający i zamykający rozszerzeniem znacznika.</summary>
        <value>Kolekcja zawierająca znaki nawias otwierający i zamykający.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see langword="xamlName" /> nazwy ciągu, która deklaruje to <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see langword="xamlName" /> Nazwy ciągu, która deklaruje to <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zawsze ustawiona podczas konstruowania. Konstruktory, które są implementowane przez <xref:System.Xaml.XamlMember> zazwyczaj throw wyjątku, jeśli nie określono nazwy początkowej; w związku z tym, nie powinna mieć tę właściwość, aby być `null` lub pusty ciąg, jeśli używane są domyślne .NET Framework XAML usługi implementacje.  
  
 [Xamlname — gramatyka](~/docs/framework/xaml-services/xamlname-grammar.md) i reguły nazewnictwa dla typu CLR i elementy członkowskie nie są dokładnie intersect. Jest możliwe zadeklarować nazwę elementu członkowskiego, które jest dozwolony w ramach środowiska CLR, ale nie jest prawidłowy w obszarze nazw XAML. Jeśli to możliwe należy unikać sytuacji.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlMember" /> obiekty mają taką samą wartość.</summary>
        <returns><see langword="true" /> Jeśli wartość <paramref name="xamlMember1" /> jest taka sama jak wartość <paramref name="xamlMember2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlMember" /> obiekty mają różne wartości.</summary>
        <returns><see langword="true" /> Jeśli wartość <paramref name="xamlMember1" /> różni się od wartości <paramref name="xamlMember2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera jednej przestrzeni nazw XAML identyfikator URI, który identyfikuje podstawowej przestrzeni nazw XAML dla tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Identyfikator dla podstawowej przestrzeni nazw XAML, w tym <see cref="T:System.Xaml.XamlMember" />, jako ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Właściwość udostępnia taką samą wartość jak wywołanie <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> a następnie konfigurowania pierwszego ciągu wartości z listy zwrócone. Podczas zapisywania elementu członkowskiego, z powrotem w tekst lub inne oświadczenia, które zachowują informacje o przestrzeni nazw XAML, należy używać preferowanych przestrzeń nazw XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wartość, która wskazuje, jak projektant wizualny powinien przetworzyć elementu członkowskiego.</summary>
        <value>Wartość <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wyliczenia. Wartość domyślna to <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> typu gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</summary>
        <value>Typ gdzie <see cref="T:System.Xaml.XamlMember" /> może istnieć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona wartość różni się dla członków można dołączyć i nie można dołączyć. Nie można dołączyć członków <xref:System.Xaml.XamlMember.TargetType%2A> zwraca <xref:System.Xaml.XamlMember.DeclaringType%2A>. W przypadku członków można dołączyć <xref:System.Xaml.XamlMember.LookupTargetType%2A> zwraca wynik, który jest oparty na tę logikę:  
  
-   Jeśli odbicia nie może rozpoznać zapasowy (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), ta metoda zwraca wartość stałą wewnętrzny, który reprezentuje typ ogólny obiekt.  
  
-   Jeśli poprzednich warunków nie ma zastosowania, <xref:System.Xaml.XamlMember.LookupTargetType%2A> jest wywoływana. Domyślna implementacja zwraca <xref:System.Xaml.XamlType> opartego na sprawdzenie metody, które implementują `get` i `set` metod dostępu. Klasy mogą zastąpić <xref:System.Xaml.XamlMember.LookupTargetType%2A> używać różne zachowanie, takie jak inne metadane, formularzy, który może zgłaszać typy elementów docelowych dla członków można dołączyć.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Reprezentacja ciągu tego <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> typu, który jest używany przez element członkowski.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Typu, który jest używany przez element członkowski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.Type%2A> wywołuje <xref:System.Xaml.XamlMember.LookupType%2A> lub określone zastąpienia tej metody. Dzieje się tak, gdy logiki początkowej odbicia wewnętrznego nie ustawił już informacje.  
  
 Zachowanie domyślne (nie <xref:System.Xaml.XamlMember.LookupType%2A> zastąpić), zwrócony <xref:System.Xaml.XamlType> mogą mieć różne znaczenie pojęć. Znaczenie, które mają zastosowanie zależy od tego, czy to <xref:System.Xaml.XamlMember> reprezentuje właściwości, metody lub zdarzenia, tak jak pokazano w poniższej listy:  
  
-   Właściwości zwracanego <xref:System.Xaml.XamlType> to typ, który ustawia właściwość, jest zwracany przez właściwość.  
  
-   Dla każdego zdarzenia zwróconego <xref:System.Xaml.XamlType> jest typ procedury obsługi zdarzeń wymagane (delegata w implementacji środowiska CLR).  
  
-   Dla metody <xref:System.Xaml.XamlType> jest typem zwracanym tej metody, która może być `null`.  
  
 W każdym przypadku kontekst schematu XAML jest używana do oceny typu XAML z zapasowego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który może służyć do tworzenia konwersji typu XAML zadeklarowana obiektów.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> wartości, przy użyciu <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenia na ogólnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.TypeConverter%2A> wywołuje <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> lub określone zastąpienia tej metody. Dzieje się tak, gdy logiki początkowej odbicia wewnętrznego nie ustawił już informacje.  
  
 Implementacje, które ma zwracać właściwość inną niż null wartość <xref:System.Xaml.XamlMember.TypeConverter%2A> niekoniecznie są działającego <xref:System.ComponentModel.TypeConverter>. Poniżej przedstawiono listę możliwych wartości zwracanych inną niż null dla <xref:System.Xaml.XamlMember.TypeConverter%2A> i reprezentują te wartości:  
  
-   Wartość zwracana raporty konwertera typów, która jest związana, specjalnie do tego elementu członkowskiego, lub bardziej ogólnie na typ docelowy konwertera. To zachowanie jest zazwyczaj jakie większość systemów typu XAML i procesorów XAML wyglądu w celu utworzenia wystąpienia konwertera typów i wywoływania jego metody.  
  
-   Wartość zwracana raporty konwertera wartości wbudowanej. Konwerterów istnieje dla pewnych operacji wewnętrznych, które są wykonywane przez Edytor XAML. W szczególności konwerterów wartości wbudowanych konwertowanie wartości ciągu raw atrybut prymitywów poziomu języka XAML. Do wykonania usług programu .NET Framework XAML takiej konwersji typu wbudowanego często przesyłać konwertera typów, która jest zdefiniowana w zestawie systemowym. Na przykład konwersja dla <xref:System.Int32> wartość ma wbudowane przekazywane konwersji i dlatego <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> wartość odwołania <xref:System.ComponentModel.Int32Converter>.  
  
-   Wartość zwracana raporty w specjalnym przypadku modelu nieograniczonego obiektu; oznacza to, że <xref:System.Xaml.XamlMember> ma <xref:System.Xaml.XamlMember.Type%2A> wartość <xref:System.Object>. W tym przypadku <xref:System.Xaml.Schema.XamlValueConverter%601> zgłasza, że <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> jest {`Object}`. Jednak <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> jest `null` ponieważ nie rzeczywisty typ lub wystąpienie jest dostępny, aby wykonać tę konwersję. Zamiast tego zachowania modelu obiektu nie można określić do czasu wykonywania, gdy środowisko uruchomieniowe określonych technologii określa obsługi jego wykresu obiektu.  
  
 Jeśli dostęp do działającego <xref:System.ComponentModel.TypeConverter> z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, można wywołać jego metody konwersji. Jednak wiele metod konwersji zależy od kontekstu usługi. Jeśli nie masz, tym samym kontekście usługa dostępna, że konwertera typów oczekuje, że jego typowe roli zapisywania obiektów dla wykresów obiektów, metody konwerter może zgłaszać wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ CLR systemu <see cref="T:System.Reflection.MemberInfo" /> dostępnej dla elementu członkowskiego, który jest konstruowany przy <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" />, lub <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>System typów CLR <see cref="T:System.Reflection.MemberInfo" /> informacji jako rzutowanie z parametry konstruktora początkowej. A <see cref="T:System.Xaml.XamlMember" /> który jest konstruowany <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> zwraca podpis <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.UnderlyingMember%2A> wywołuje <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> lub określone zastąpienia tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który jest używany do serializacji wartości XAML zadeklarowana obiektów.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenia na ogólnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Xaml.XamlMember.ValueSerializer%2A> wywołuje <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> lub określone zastąpienia tej metody. Dzieje się tak, gdy logiki początkowej odbicia wewnętrznego nie ustawił już informacje.  
  
 Nie wszystkie przypadki, które zwracają właściwości inną niż null wartość <xref:System.Xaml.XamlMember.ValueSerializer%2A> są zawsze działającego <xref:System.Windows.Markup.ValueSerializer>. Zobacz <xref:System.Xaml.XamlMember.TypeConverter%2A>; samo odnosi się do <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
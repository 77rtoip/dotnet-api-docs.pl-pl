<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a1a3c6f21332c02e5194428660fd5b7fbc4bdf3" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69427319" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia identyfikator systemu typu XAML dla elementów członkowskich typów XAML. Identyfikator jest używany przez czytniki XAML i autorów XAML podczas przetwarzania węzłów elementów członkowskich (gdy czytnik XAML jest umieszczony w elemencie <see cref="F:System.Xaml.XamlNodeType.StartMember" />), a także dla ogólnej logiki systemu typu XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember>można użyć trzech metodologii do zwrócenia informacji o elemencie członkowskim XAML: odbicie standardowego środowiska uruchomieniowego języka wspólnego (CLR); Technika odbicia tylko do odwołania wywołuje wewnętrzne interfejsy API, które używają zoptymalizowanych flag bitowych; lub wywoływanie wirtualnych zastąpień `Lookup*` interfejsu API, które są udostępniane <xref:System.Xaml.XamlMember> przez możliwe podklasy. W przypadku większości przypadków użycia .NET Framework interfejsów API usług XAML <xref:System.Xaml.XamlMember> i interfejsu API należy użyć domyślnego kontekstu schematu języka XAML. Domyślny kontekst schematu XAML dla usług .NET Framework XAML używa kopii zapasowej środowiska CLR dla systemu typu. Dzięki temu czytelnicy XAML i autorzy języka XAML mogą współdziałać z dowolnym typem lub członkiem, który jest zdefiniowany w lub w inny sposób dostępny dla środowiska CLR i jego odbicia.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Lookup * API i klasy pochodne XamlMember  
 <xref:System.Xaml.XamlMember>definiuje kilka wirtualnych elementów członkowskich, które klasy pochodne mogą przesłonić. Te składowe mają nazwy, które zawsze zaczynają `Lookup`się od ciągu. Pozostała część nazwy interfejsu API odwołuje się do właściwości, której dotyczy dana metoda wirtualna. Na przykład <xref:System.Xaml.XamlMember> Klasa pochodna może przesłonić <xref:System.Xaml.XamlMember.LookupTargetType%2A> , aby mieć wpływ na to, <xref:System.Xaml.XamlMember.TargetType%2A> co Właściwość zdefiniowana przez podstawę zwraca w klasie pochodnej. Można przewidzieć wartości zwracane dla takich właściwości w <xref:System.Xaml.XamlMember> lub istniejących klasach pochodnych, odczytując dokumentację dla odpowiednich `Lookup*` metod.  
  
 Celem `Lookup*` metod jest dostarczenie techniki rozszerzenia systemu typu XAML, która obejmuje <xref:System.Xaml.XamlMember> klasę bazową. Przez wyprowadzanie z <xref:System.Xaml.XamlMember> i `Lookup` zastępowanie wirtualnych elementów członkowskich można zdefiniować koncepcję elementu członkowskiego XAML dla schematu XAML w systemie typu XAML bez konieczności powiązania się z charakterystykami systemu lub technologii typu zapasowego. Możesz również użyć podanego kontekstu schematu XAML w tym schemacie i nadal zwracać wyniki.  
  
 Rozważmy na <xref:System.Xaml.XamlMember> przykład właściwość <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Ta właściwość informuje wywołujących, że operacje takie jak użycie funkcji <xref:System.Xaml.XamlWriter> for Serialization mogą napisać wartość dla tego elementu członkowskiego w obiekcie docelowym. W implementacji domyślnej, określenie, czy element członkowski jest zapisywalny, jest tworzony przy użyciu technik odbicia względem środowiska CLR <xref:System.Type> i jego członków <xref:System.Reflection.MemberInfo>(). W związku z tym Domyślnie system typu XAML zależy od systemu typów CLR. Można jednak usunąć tę zależność dla systemu typu XAML raportowanie <xref:System.Xaml.XamlMember.IsWritePublic%2A> przez zastąpienie interfejsu API. <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> W ramach przesłonięcia można użyć innych oznaczeń, takich jak metadane specyficzne dla danej technologii, główna tabela odnośników zoptymalizowana pod kątem ustalonego słownictwa XAML lub wiele innych strategii określania, czy element członkowski XAML jest zapisywalny w Słownictwo języka XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Konstruowanie XamlMember bez kontekstu schematu XAML  
 Większość konstruktorów <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlSchemaContext> wymaga jako część inicjalizacji. Jest również konieczne w przypadku wielu operacji <xref:System.Xaml.XamlSchemaContext> wewnętrznych, takich jak uzyskiwanie informacji przesyłanych dalej z typu zapasowego. <xref:System.Xaml.XamlSchemaContext> Gdy pracujesz z <xref:System.Xaml.XamlMember> interfejsem API, zazwyczaj masz, że <xref:System.Xaml.XamlSchemaContext> jest on dostępny z <xref:System.Xaml.XamlWriter>otaczającej konstrukcji, takiej jak. W takim przypadku można przekazać <xref:System.Xaml.XamlSchemaContext> odwołanie do wszystkich wywołań systemu typu XAML, które wymagają kontekstu schematu XAML.  
  
 Jeden określony Konstruktor <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>,, nie <xref:System.Xaml.XamlSchemaContext>wymaga. Jednak, <xref:System.Xaml.XamlMember> który jest zbudowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> z sygnaturą zwraca `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 W przypadku ścieżki ładowania, która <xref:System.Xaml.XamlObjectWriter>obejmuje, taki element członkowski nie może być zapisany w grafie obiektu. Korzystając z .NET Framework implementacji usług XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołanie <xref:System.Xaml.XamlObjectWriterException> zgłasza, kiedy są odpowiednie <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 <xref:System.Xaml.XamlMember> Nie należy tworzyć, która ma <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` wartość dla, chyba że implementacja może obsłużyć wyjątki z <xref:System.Xaml.XamlObjectWriter>lub inne sposoby dostosować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład co najmniej jedno z następujących elementów może być prawdziwe w implementacji:  
  
-   Kontekst schematu XAML jest dostępny w dalszej części.  
  
-   Używasz wzorca źródło elementu członkowskiego.  
  
-   Celowo przesłonięcie <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowym składniku zapisywania języka XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Zapoznanie się ze strukturami i koncepcjami strumienia węzłów XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlMember" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System <see cref="T:System.Reflection.EventInfo" /> typów CLR reprezentujący element członkowski zdarzenia.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu systemu <see cref="T:System.Reflection.EventInfo" /> typów CLR i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje zdarzenie (Właściwość punktu połączenia programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System <see cref="T:System.Reflection.PropertyInfo" /> typów CLR reprezentujący element członkowski właściwości.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu systemu <see cref="T:System.Reflection.PropertyInfo" /> typów CLR i <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje właściwość (a w związku z tym nie jest połączeniem programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">System <see cref="T:System.Reflection.EventInfo" /> typów CLR reprezentujący element członkowski zdarzenia.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <param name="invoker">Implementacja, która obsługuje wywołania odbicia w <see cref="T:System.Xaml.XamlMember" />czasie wykonywania względem. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu systemu <see cref="T:System.Reflection.EventInfo" /> typów CLR i <see cref="T:System.Xaml.XamlSchemaContext" />, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje zdarzenie (lub właściwość punktu połączenia programu obsługi zdarzeń).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">System <see cref="T:System.Reflection.PropertyInfo" /> typów CLR reprezentujący element członkowski właściwości.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <param name="invoker">Implementacja, która obsługuje wywołania wywołań w <see cref="T:System.Xaml.XamlMember" />czasie wykonywania względem. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu odbicia <see cref="T:System.Reflection.PropertyInfo" /> i a <see cref="T:System.Xaml.XamlSchemaContext" />, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego konstruktora należy używać tylko wtedy, gdy element członkowski reprezentuje właściwość i jeśli nie jest to połączenie programu obsługi zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu zdarzenia do dołączenia.</param>
        <param name="adder">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR dla metody obsługi <see langword="Add" /> do tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy <see cref="T:System.Xaml.XamlMember" /> dla, które reprezentuje zdarzenie możliwe do dołączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje element członkowski zdarzenia do dołączenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa ciągu elementu członkowskiego.</param>
        <param name="declaringType"><see cref="T:System.Xaml.XamlType" /> Informacje dla typu deklarującego.</param>
        <param name="isAttachable"><see langword="true" />, aby wskazać, że element członkowski jest możliwy do dołączenia; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy przy użyciu nazwy ciągu i deklarowania <see cref="T:System.Xaml.XamlType" /> informacji. Obiekt <see cref="T:System.Xaml.XamlMember" /> , który jest zbudowany z tą sygnaturą, ma znaczące ograniczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt <xref:System.Xaml.XamlMember> , który jest zbudowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> z sygnaturą `true` zwraca <xref:System.Xaml.XamlMember.IsUnknown%2A>dla.  
  
 W przypadku ścieżki ładowania, która <xref:System.Xaml.XamlObjectWriter>obejmuje, taki element członkowski nie może być zapisany w grafie obiektu. Korzystając z .NET Framework implementacji usług XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołanie <xref:System.Xaml.XamlObjectWriterException> zgłasza, kiedy są odpowiednie <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Nie należy tworzyć elementu <xref:System.Xaml.XamlMember> with <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` , chyba że implementacja może obsłużyć wyjątki <xref:System.Xaml.XamlObjectWriter>z lub inne sposoby dostosować <xref:System.Xaml.XamlObjectWriter> zachowanie. Na przykład co najmniej jedno z następujących elementów może być prawdziwe w implementacji:  
  
-   Kontekst schematu XAML jest dostępny w dalszej części.  
  
-   Używasz wzorca źródło elementu członkowskiego.  
  
-   Celowo przesłonięcie <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> w niestandardowym składniku zapisywania języka XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />lub <paramref name="declaringType" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu właściwości możliwej do dołączenia.</param>
        <param name="getter">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR <see langword="get" /> dla akcesora implementacji tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="setter">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR <see langword="set" /> dla akcesora implementacji tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy <see cref="T:System.Xaml.XamlMember" /> dla, które reprezentuje właściwość dołączalną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje właściwość dołączalną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nazwa ciągu zdarzenia do dołączenia.</param>
        <param name="adder">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR dla metody obsługi <see langword="Add" /> do tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <param name="invoker">Implementacja, która obsługuje wywołania wywołań w <see cref="T:System.Xaml.XamlMember" />czasie wykonywania względem. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy <see cref="T:System.Xaml.XamlMember" /> dla, które reprezentuje zdarzenie możliwe do dołączenia, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje element członkowski zdarzenia do dołączenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nazwa ciągu właściwości możliwej do dołączenia.</param>
        <param name="getter">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR <see langword="get" /> dla akcesora implementacji tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="setter">System <see cref="T:System.Reflection.MethodInfo" /> typów CLR <see langword="set" /> dla akcesora implementacji tworzenia kopii zapasowej dołączalnej składowej.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Kontekst, który jest kwalifikatorem elementu członkowskiego.</param>
        <param name="invoker">Implementacja, która obsługuje wywołania wywołań w <see cref="T:System.Xaml.XamlMember" />czasie wykonywania względem. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlMember" /> klasy <see cref="T:System.Xaml.XamlMember" /> dla, które reprezentuje właściwość dołączalną, w tym <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> informacje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora, jeśli element członkowski reprezentuje element członkowski właściwości możliwej do dołączenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dla typu, który deklaruje element członkowski, który jest skojarzony z <see cref="T:System.Xaml.XamlMember" />tym. <see cref="T:System.Xaml.XamlType" /></summary>
        <value>Dla typu, który deklaruje element członkowski, który jest skojarzony z <see cref="T:System.Xaml.XamlMember" />tym. <see cref="T:System.Xaml.XamlType" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zazwyczaj ustawiana podczas inicjowania i zazwyczaj nie `null`jest.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A>informacje mogą być przesyłane przez konstruktory do inicjalizacji. Wywoływanie bezpośrednio do konstruktorów podstawowych, Inicjalizacja <xref:System.Xaml.XamlMember> klas pochodnych może pominąć niektóre sprawdzenia wartości, które zostały wprowadzone w klasie bazowej. W związku z tym, Inicjalizacja pochodna może zmienić raportowane informacje o relacji elementu członkowskiego typu elementu członkowskiego języka XAML, aby nie były już wyrównane w oczekiwany sposób z informacjami o systemie typu jego źródłowej deklaracji środowiska CLR. W przypadku wszelkich testów krytycznych dla zabezpieczeń deklarujących informacje o typie należy zamiast tego użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Pobiera obiekt, który jest używany do odroczonego ładowania zadeklarowanych obiektów XAML.</summary>
        <value>With z <see cref="T:System.Xaml.XamlDeferringLoader" />ograniczeniemnaogólny. <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.DeferringLoader%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> Takie zachowanie występuje w przypadkach, gdy początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę <see cref="T:System.Xaml.XamlMember" /> obiektów. W tym raporcie znajdują się elementy członkowskie, w których istnieją <see cref="T:System.Xaml.XamlMember" />relacje zależności dla kolejności inicjalizacji.</summary>
        <value>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.DependsOn%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupDependsOn%2A> Takie zachowanie występuje w przypadkach, gdy początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 `DependsOn` Wzorzec może być stosowany do przypadków modelu obiektu, które w sposób celowy są sprzeczne z ogólną regułą języka XAML. Ogólna reguła XAML polega na tym, że elementy członkowskie typu, które nie są przekazane jako tekst inicjujący (lub przez metodę fabryki w języku XAML 2009), muszą być przypisane w dowolnej kolejności. Stosując `DependsOn` wzorzec do elementu członkowskiego, można nakazać autorom języka XAML zawsze przetwarzać element członkowski występujący w odwołaniu przed tym elementem członkowskim. Ten wzorzec można zastosować w sytuacjach, gdy wartość bieżącego elementu członkowskiego wymaga kontekstu lub innych informacji, które są dostępne tylko po ustawieniu innego elementu członkowskiego.  
  
 `DependsOn` Wzorzec powinien być stosowany w sposób odstrzeżony i zarezerwowany dla scenariuszy właściwości, gdzie służy do zastosowania architektury. Duża liczba zależności ma możliwość spowolnienia przetwarzania kodu XAML. Ponadto możliwe jest wygenerowanie zależności cyklicznych, w tym przypadku zachowanie przetwarzania XAML jest niezdefiniowane.  
  
 Przykładowe `DependsOn` scenariusze z platformy WPF obejmują pewne właściwości <xref:System.Windows.Controls.ControlTemplate> w <xref:System.Windows.DataTemplate>systemach i <xref:System.Windows.Trigger>, w i <xref:System.Windows.Setter>w.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy bieżący obiekt jest równy innemu obiektowi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest równy innemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli bieżący obiekt jest równy <paramref name="obj" /> parametrowi; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest równy innemu obiektowi tego samego typu.</summary>
        <returns><see langword="true" />Jeśli bieżący obiekt jest równy <paramref name="other" /> parametrowi; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego obiektu.</summary>
        <returns>Kod skrótu liczby całkowitej.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę przestrzeni nazw XAML, w których może istnieć ten element członkowski języka XAML.</summary>
        <returns>Lista identyfikatorów przestrzeni nazw XAML jako ciągi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> wynik wywołania <xref:System.Xaml.XamlMember.DeclaringType%2A> z, który jest skojarzony z tym <xref:System.Xaml.XamlMember>elementem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera implementację, która jest skojarzona <see cref="T:System.Xaml.XamlMember" />z tym. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></summary>
        <value>Implementacja, która jest skojarzona z <see cref="T:System.Xaml.XamlMember" />tym. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Wzorzec jest zaawansowaną techniką rozszerzenia systemu typu XAML. `Invoker` Wzorzec umożliwia wprowadzanie różnych zachowań mapowania typu schematu, przy jednoczesnym użyciu definicji systemu typu XAML z usług .NET Framework XAML.  
  
 <xref:System.Xaml.XamlMember> `null` `null` <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> <xref:System.Xaml.XamlMember.Invoker%2A> Jeśli przesłonięcie zwróci lub jeśli domyślna implementacja zwróci wartość, ponieważ brakuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> dla tego elementu, właściwość zwraca. <xref:System.Xaml.XamlMember.LookupInvoker%2A>  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>jest wartością domyślną. Dotyczy to większości operacji, które używają .NET Framework usług XAML i domyślnego kontekstu schematu języka XAML i gdzie nie są przenoszone żadne `Invoker` specyficzne wzorce przesłonięcia dla konstrukcji jednostek systemu typu XAML.  
  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.Invoker%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupInvoker%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest ona <see cref="T:System.Xaml.XamlMember" /> raportowana jako Właściwość otoczenia.</summary>
        <value><see langword="true" />Jeśli ta <see cref="T:System.Xaml.XamlMember" /> wartość jest raportowana jako Właściwość otoczenia; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsAmbient%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsAmbient%2A> To zachowanie występuje w implementacjach, w których początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 Sprawdzanie właściwości otoczenia jest zwykle częścią logiki przetwarzania XAML, aby upewnić się, że obiekty i wartości, które są zależne od użycia otoczenia dla kwalifikacji typów, mogą działać poprawnie. .NET Framework interfejsów API usług XAML i domyślny kontekst schematu XAML wypełniają tę wartość na podstawie przypisywania za <xref:System.Windows.Markup.AmbientAttribute>pomocą. Domyślna implementacja programu <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> używa tej istniejącej <xref:System.Windows.Markup.AmbientAttribute> techniki i zwraca `true` , jeśli <xref:System.Windows.Markup.AmbientAttribute> istnieje w deklaracji elementu członkowskiego.  
  
 <xref:System.Windows.Markup.AmbientAttribute>znajduje się w składowych kilku typów WPF, <xref:System.Windows.Application>takich jak, <xref:System.Windows.Setter>, i. <xref:System.Windows.Style> Znajduje się on również na <xref:System.Windows.ResourceDictionary> typie, który oznacza, że każdy element członkowski używany <xref:System.Windows.ResourceDictionary> jako jego typ powinien być uważany za otoczenie nawet wtedy, gdy element członkowski nie jest jawnie przypisany.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest to <see cref="T:System.Xaml.XamlMember" /> Dołączalna składowa.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Xaml.XamlMember" /> to element członkowski możliwej do dołączenia; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość jest inicjowana na podstawie konstruktora użytego do <xref:System.Xaml.XamlMember>skonstruowania. <xref:System.Xaml.XamlMember.IsAttachable%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest to <see cref="T:System.Xaml.XamlMember" /> dyrektywa języka XAML.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Xaml.XamlMember" /> to dyrektywa języka XAML; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość jest inicjowana na podstawie konstruktora użytego do <xref:System.Xaml.XamlMember>skonstruowania. <xref:System.Xaml.XamlMember.IsDirective%2A> Konstruktory <xref:System.Xaml.XamlMember> podstawowe inicjują w <xref:System.Xaml.XamlMember.IsDirective%2A> `false`ten sposób. Jednak Klasa (Klasa <xref:System.Xaml.XamlMember.IsDirective%2A> `true`pochodna) inicjuje się tak, że jest to. <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlDirective>  
  
 Jeśli chcesz raportować <xref:System.Xaml.XamlMember.IsDirective%2A> jako `true` metody wywoływania niestandardowej klasy schematu XAML dla elementów członkowskich XAML, upewnij się, że pochodzi od <xref:System.Xaml.XamlDirective> , ponieważ jest to jedyny sposób na włączenie tego zachowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski zdarzenia.</summary>
        <value><see langword="true" />Jeśli reprezentuje zdarzenie; w przeciwnym razie <see langword="false" />. <see cref="T:System.Xaml.XamlMember" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsEvent%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsEvent%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest ona <see cref="T:System.Xaml.XamlMember" /> zainicjowana z prawidłowym <see langword="xamlName" /> ciągiem <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Xaml.XamlMember" /> on zainicjowany z prawidłowym <see langword="xamlName" /> ciągiem; w przeciwnym <see langword="false" />razie.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli reprezentuje element członkowski tylko do odczytu; <see langword="false" />w przeciwnym razie. <see cref="T:System.Xaml.XamlMember" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsReadOnly%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsReadOnly%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski z wywoływanym publicznym <see langword="get" /> akcesorem.</summary>
        <value><see langword="true" />Jeśli ten <see cref="T:System.Xaml.XamlMember" /> element reprezentuje wywoływany <see langword="get" /> publiczny akcesor; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość sprawdza, <xref:System.Xaml.XamlMember.DeclaringType%2A> czy jest publiczna. <xref:System.Xaml.XamlMember.IsReadPublic%2A> Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepubliczny `get` , metoda dostępu nie jest wywoływana w praktyce i <xref:System.Xaml.XamlMember.IsReadPublic%2A> zwraca wartość `false`.  
  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsReadPublic%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metoda jest wirtualna i dlatego można ją zastąpić. Przesłonięcie ma możliwość zmiany (złośliwe lub inne) zgłoszonych informacji o dostępie do elementu członkowskiego języka XAML, tak aby nie był już wyrównany w oczekiwany sposób z informacjami o dostępie do systemu typu w jego źródłowej deklaracji środowiska CLR. W przypadku sprawdzania krytycznego pod względem zabezpieczeń poziomów dostępu należy zamiast tego użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element członkowski nie jest rozpoznawany przez system zapasowy używany do rozpoznawania typów i elementów członkowskich.</summary>
        <value><see langword="true" />Jeśli element członkowski nie jest rozpoznawany; <see langword="false" /> Jeśli element członkowski jest rozpoznawalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt <xref:System.Xaml.XamlMember> , który jest zbudowany <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> z sygnaturą `true` zwraca <xref:System.Xaml.XamlMember.IsUnknown%2A>dla.  
  
 W przypadku ścieżki ładowania, która <xref:System.Xaml.XamlObjectWriter>obejmuje, <xref:System.Xaml.XamlMember> element `true` with <xref:System.Xaml.XamlMember.IsUnknown%2A> dla nie może być zapisywana na Graf obiektu. W ramach domyślnych implementacji w .NET Framework interfejsów API usług XAML <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> wywołanie <xref:System.Xaml.XamlObjectWriterException> zgłasza, gdy odpowiednie <xref:System.Xaml.XamlMember> raporty `true` dla <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 <xref:System.Xaml.XamlMember> Nie należy tworzyć, która ma <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` wartość dla, chyba że implementacja może obsłużyć wyjątki z <xref:System.Xaml.XamlObjectWriter>lub inne sposoby dostosować <xref:System.Xaml.XamlObjectWriter> zachowanie.  
  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsUnknown%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsUnknown%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski tylko do zapisu.</summary>
        <value><see langword="true" />Jeśli reprezentuje element członkowski tylko do zapisu, <see langword="false" />w przeciwnym razie. <see cref="T:System.Xaml.XamlMember" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsWriteOnly%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma wywołaną metodę dostępu publicznego. <see langword="set" /></summary>
        <value><see langword="true" />Jeśli ten <see cref="T:System.Xaml.XamlMember" /> element reprezentuje wywoływany <see langword="set" /> publiczny akcesor; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość uważa, <xref:System.Xaml.XamlMember.DeclaringType%2A> czy jest publiczna w ramach wyznaczania. <xref:System.Xaml.XamlMember.IsWritePublic%2A> Jeśli <xref:System.Xaml.XamlMember.DeclaringType%2A> jest niepubliczny `set` , metoda dostępu nie jest wywoływana w praktyce i <xref:System.Xaml.XamlMember.IsWritePublic%2A> zwraca wartość `false`.  
  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.IsWritePublic%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metoda jest wirtualna i dlatego można ją zastąpić. Przesłonięcie ma możliwość zmiany (złośliwe lub inne) zgłoszonych informacji o dostępie do elementu członkowskiego języka XAML, tak aby nie był już wyrównany w oczekiwany sposób z informacjami o dostępie do systemu typu w jego źródłowej deklaracji środowiska CLR. W przypadku sprawdzania krytycznego pod względem zabezpieczeń poziomów dostępu należy zamiast tego użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej zwraca <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementację.</summary>
        <returns><see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementacja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp tę metodę, aby zapewnić wewnętrzne odbicie z alternatywnym sposobem uzyskania wartości atrybutów CLR. W przypadku braku przesłonięcia wewnętrzna reflektor używa typowej logiki odbicia CLR, takiej jak wywołania <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Domyślna implementacja zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Zwraca obiekt, który jest używany do odroczonego ładowania zadeklarowanych obiektów XAML.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> , który <see cref="T:System.Xaml.XamlDeferringLoader" /> ma ograniczenie dotyczące ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z <xref:System.Xaml.XamlMember.DeferringLoader%2A> właściwości. Zastąp tę metodę, jeśli <xref:System.Xaml.XamlMember.DeferringLoader%2A> chcesz zwrócić wartość, która różni się od wartości, która jest włączona domyślnie odbicie wewnętrzne, i jeśli udostępniasz również informacje <xref:System.Xaml.Schema.XamlMemberInvoker> niestandardowe.  
  
 Domyślna implementacja zwraca obiekt przez odczytanie <xref:System.Windows.Markup.XamlDeferLoadAttribute> lub użycie elementu <xref:System.Xaml.XamlDeferringLoader> z typu deklarującego. Jeśli żaden z tych obiektów nie jest dostępny, ta `null`Metoda może zwrócić.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę <see cref="T:System.Xaml.XamlMember" /> obiektów. Elementy na liście raportują elementy członkowskie, w których istnieją <see cref="T:System.Xaml.XamlMember" />relacje zależności dla kolejności inicjalizacji.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlMember" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z <xref:System.Xaml.XamlMember.DependsOn%2A> właściwości. Zastąp tę metodę, jeśli <xref:System.Xaml.XamlMember.DependsOn%2A> chcesz zwrócić wartość, która różni się od wartości, która jest włączona domyślnie odbicie wewnętrzne, i jeśli udostępniasz również informacje <xref:System.Xaml.Schema.XamlMemberInvoker> niestandardowe.  
  
 Implementacja czytnika i składnika zapisywania XAML WPF w tym przypadku z <xref:System.Windows.Markup.DependsOnAttribute>. Domyślna implementacja używa tej istniejącej <xref:System.Windows.Markup.DependsOnAttribute> techniki.  
  
 Zastąp tę metodę, jeśli nie <xref:System.Windows.Markup.DependsOnAttribute> używasz tego celu i zamierzasz zastąpić tę technikę wskazującą kolejność przetwarzania właściwości własną techniką. Jeśli nie zamierzasz obsługiwać kolejności przetwarzania właściwości, możesz użyć domyślnej implementacji, ponieważ nie zwraca żadnych wyników, co jest odpowiednie.  
  
 Lista jest tylko do odczytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, która jest skojarzona z <see cref="T:System.Xaml.XamlMember" />tym elementem. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></summary>
        <returns>Informacje dla tego <see cref="T:System.Xaml.XamlMember" />elementu; lub <see langword="null" />. <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wywołania do <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Implementacja domyślna nie wymaga, aby <xref:System.Xaml.XamlMember> można było utworzyć przy użyciu jednego z konstruktorów, które przekazują początkowe. <xref:System.Xaml.Schema.XamlMemberInvoker> Jednak wartość musi istnieć <xref:System.Xaml.XamlMember>dla elementu; w przeciwnym razie zostanie zwrócona `null`domyślna implementacja. <xref:System.Xaml.XamlMember.UnderlyingMember%2A>  
  
 Zastąp tę metodę, jeśli pochodzi również <xref:System.Xaml.Schema.XamlMemberInvoker> z i zamierzasz zwrócić klasę pochodną. W przypadku powrotu `null` <xref:System.Xaml.XamlMember.Invoker%2A> zwracamy <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> do wywoływania.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy ten <see cref="T:System.Xaml.XamlMember" /> raport jest raportowany jako Właściwość otoczenia.</summary>
        <returns><see langword="true" />Aby zgłosić ten <see cref="T:System.Xaml.XamlMember" /> element jako Właściwość otoczenia; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez wywołania wewnętrzne, które sprawdzają informacje o otaczających właściwościach XAML. Zachowanie właściwości otoczenia jest uwzględniane w publicznym zachowaniu interfejsu API dla czytników XAML i autorów XAML. Wywołania wewnętrzne, które <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> są zwykle częścią logiki przetwarzania XAML, aby upewnić się, że obiekty i wartości, które są zależne od użycia otoczenia dla kwalifikacji typów, mogą działać poprawnie. Domyślna .NET Framework implementacja usług XAML używa środowiska CLR, aby uzyskać te informacje przed odbiciem w typach zapasowych. W odniesieniu do definicji elementu <xref:System.Windows.Markup.AmbientAttribute> Członkowskiego `true` domyślnie <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> sprawdzane są implementacje dla i zwracane <xref:System.Windows.Markup.AmbientAttribute> .  
  
 Zastąp tę metodę, jeśli nie <xref:System.Windows.Markup.AmbientAttribute> używasz tego celu i zamierzasz zamienić tę technikę wskazującą na właściwości otaczającego języka XAML własną techniką.  
  
 Przykładowe interfejsy API z platformy WPF, <xref:System.Windows.Markup.AmbientAttribute> które <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> mają <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>atrybut with to i.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy to <see cref="T:System.Xaml.XamlMember" /> reprezentuje zdarzenie.</summary>
        <returns><see langword="true" />Aby zgłosić, że <see cref="T:System.Xaml.XamlMember" /> to oznacza zdarzenie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja sprawdza, czy <xref:System.Xaml.XamlMember.UnderlyingMember%2A> jest typu <xref:System.Reflection.EventInfo>, a jeśli jest, zwraca `true`.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.IsEvent%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub że masz dostępne specjalne metadane, które mogą być interpretowane w celu określenia reprezentacji systemu typów XAML na podstawie wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy reprezentuje <see cref="T:System.Xaml.XamlMember" /> ona zamierzoną właściwość tylko do odczytu.</summary>
        <returns><see langword="true" />Aby zgłosić ten <see cref="T:System.Xaml.XamlMember" /> element jako zamierzoną właściwość tylko do odczytu; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość `true` , <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Jeśli istnieje, ale publiczna `set` metoda dostępu nie istnieje dla niego, zgodnie z opisem w wyniku wewnętrznego odbicia.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.IsReadOnly%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub że masz dostępne specjalne metadane, które mogą być interpretowane w celu określenia reprezentacji systemu typów XAML na podstawie wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje właściwość, która ma publiczny <see langword="get" /> akcesor.</summary>
        <returns><see langword="true" />Jeśli reprezentuje właściwość, która ma publiczny <see langword="get" /> akcesor; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Xaml.XamlMember" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki w oparciu o odbicie wewnętrzne lub negację <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, przetwarzanie w tej kolejności.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>Zwraca czy sama składowa jest publiczna; zwraca `true` dla publicznej składowej w niepublicznym typie deklarującym. Użyj <xref:System.Xaml.XamlMember.IsReadPublic%2A> zamiast tego, jeśli chcesz również rozważyć widoczność typu deklarującego.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.IsReadPublic%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Metoda jest wirtualna i dlatego można ją zastąpić. Przesłonięcie ma możliwość zmiany (złośliwe lub inne) zgłoszonych informacji o dostępie do elementu członkowskiego języka XAML, tak aby nie był już wyrównany w oczekiwany sposób z informacjami o dostępie do systemu typu w jego źródłowej deklaracji środowiska CLR. W przypadku sprawdzania krytycznego pod względem zabezpieczeń poziomów dostępu należy zamiast tego użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który nie jest rozpoznawany przez system zapasowy używany do rozpoznawania typów i elementów członkowskich.</summary>
        <returns><see langword="true" />Jeśli reprezentuje <see cref="T:System.Xaml.XamlMember" /> to nierozpoznawalny element członkowski; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy wywołujący pobiera wartość z <xref:System.Xaml.XamlMember.IsUnknown%2A>. Domyślna implementacja zwraca wyniki, które są oparte na wewnętrznych odbiciach lub sprawdzaniu `null` <xref:System.Xaml.XamlMember.UnderlyingMember%2A>wartości, przetwarzania w tej kolejności.  
  
 Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publiczny <see langword="set" /> akcesor, ale nie jest publicznym <see langword="get" /> akcesorem.</summary>
        <returns><see langword="true" />Jeśli reprezentuje element członkowski tylko do zapisu, <see langword="false" />w przeciwnym razie. <see cref="T:System.Xaml.XamlMember" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość `true` , <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Jeśli istnieje, która ma publiczny `set` akcesor i niepubliczną `get` metodę dostępu określoną przez odbicie wewnętrzne.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.IsWriteOnly%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca czy <see cref="T:System.Xaml.XamlMember" /> reprezentuje element członkowski, który ma publiczny <see langword="set" /> akcesor.</summary>
        <returns><see langword="true" />Jeśli reprezentuje <see cref="T:System.Xaml.XamlMember" /> to zapisywalny element członkowski; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wyniki w oparciu o wewnętrzne odbicie lub negację <xref:System.Xaml.XamlMember.IsReadOnly%2A>, przetwarzanie w tej kolejności.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.IsWritePublic%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Metoda jest wirtualna i dlatego można ją zastąpić. Przesłonięcie ma możliwość zmiany (złośliwe lub inne) zgłoszonych informacji o dostępie do elementu członkowskiego języka XAML, tak aby nie był już wyrównany w oczekiwany sposób z informacjami o dostępie do systemu typu w jego źródłowej deklaracji środowiska CLR. W przypadku sprawdzania krytycznego pod względem zabezpieczeń poziomów dostępu należy zamiast tego użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca otwierające i zamykające nawiasy klamrowe dla rozszerzenia znacznika.</summary>
        <returns>Kolekcja zawierająca znaki otwierającego i zamykającego nawiasu klamrowego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Xaml.XamlType" /> Zwraca typ <see cref="T:System.Xaml.XamlMember" /> , który może istnieć.</summary>
        <returns>Typ, w którym <see cref="T:System.Xaml.XamlMember" /> może istnieć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja odróżnia elementy członkowskie, które nie są możliwe do dołączenia. W przypadku elementów członkowskich, które nie <xref:System.Xaml.XamlMember.LookupTargetType%2A> zostały dołączone <xref:System.Xaml.XamlMember.DeclaringType%2A>, zawsze zwraca. W przypadku dołączalnych <xref:System.Xaml.XamlMember.LookupTargetType%2A> elementów członkowskich zwraca wynik oparty na badaniu <xref:System.Xaml.XamlMember.UnderlyingMember%2A> typu parametru metody dostępu i interpretuje ten typ na podstawie kontekstu schematu XAML.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.TargetType%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Xaml.XamlType" /> Zwraca typ, który jest używany przez element członkowski.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> Typ, który jest używany przez element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.Type%2A>z. Zastąp tę metodę, jeśli <xref:System.Xaml.XamlMember.Type%2A> chcesz zwrócić wartość, która różni się od wartości, która jest włączona domyślnie odbicie wewnętrzne, i jeśli udostępniasz również informacje <xref:System.Xaml.Schema.XamlMemberInvoker> niestandardowe.  
  
 Implementacja domyślna używa różnych ścieżek kodu i podstaw dla zwracanych <xref:System.Xaml.XamlType> , które są oparte na tym <xref:System.Xaml.XamlMember> , czy reprezentuje właściwość, metodę lub zdarzenie.  
  
-   Dla właściwości zwracana <xref:System.Xaml.XamlType> jest typ, który ustawia właściwość lub jest zwracany przez właściwość.  
  
-   Dla zdarzenia zwracany <xref:System.Xaml.XamlType> jest wymagany typ programu obsługi zdarzeń (delegat w implementacji środowiska CLR).  
  
-   Dla metody <xref:System.Xaml.XamlType> jest typem zwracanym.  
  
 W każdym przypadku kontekst schematu XAML służy do szacowania typu XAML z bazowego typu systemu.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.Type%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca implementację konwertera typów, która jest skojarzona z tym <see cref="T:System.Xaml.XamlMember" />elementem.</summary>
        <returns>Wystąpienie z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczeniem; lub <see langword="null" />. <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następującej kolejności logiki i przetwarzania:  
  
-   Jeśli przypisanie istnieje na poziomie elementu członkowskiego (<xref:System.ComponentModel.TypeConverterAttribute>), informacje o atrybutach są używane do <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> wywołania względem kontekstu schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, jest zwracany konwerter typu, który jest skojarzony z typem.  
  
-   Jeśli element członkowski jest zdarzeniem, zwracany jest konwerter typu określonego dla zdarzenia.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.TypeConverter%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca metodę dostępu, która jest skojarzona <see cref="T:System.Xaml.XamlMember" />z tym elementem. <see langword="get" /></summary>
        <returns>Dla skojarzonej <see langword="get" /> metody dostępu; lub <see langword="null" />. <see cref="T:System.Reflection.MethodInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja domyślna interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Właściwość <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> jako <xref:System.Reflection.PropertyInfo> i zwraca wartość (z parametrem ustawionym na `true`), co oznacza, że zwracana metoda może być niepubliczna. Takie zachowanie może skutkować `null` w niektórych przypadkach. w tym przypadki, w których nie istnieje skojarzony akcesor lub element członkowski nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość z <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> właściwości na skojarzonej <xref:System.Xaml.Schema.XamlMemberInvoker>. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter. Upewnij się, że <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>Zaimplementuj, <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>i tak, aby wszystkie zwracały skorelowane wyniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca System <see cref="T:System.Reflection.MemberInfo" /> typów CLR, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />elementem.</summary>
        <returns>Obiekt systemu <see cref="T:System.Reflection.MemberInfo" /> typu CLR, który jest skojarzony z tym <see cref="T:System.Xaml.XamlMember" />; lub <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca podstawowe informacje o elemencie członkowskim, które są oparte na konstrukcji. Jeśli obiekt jest skonstruowany z podpisem, który nie zapewnia wystarczającej ilości informacji do ustawienia bazowego elementu członkowskiego, Metoda ta zwraca wartość `null`. <xref:System.Reflection.MemberInfo>  
  
 Jeśli bazowy element członkowski został ustawiony podczas konstruowania, nie należy wywoływać tej metody.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.UnderlyingMember%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter. Upewnij się, że <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>Zaimplementuj, <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>i tak, aby wszystkie zwracały skorelowane wyniki.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca metodę dostępu, która jest skojarzona <see cref="T:System.Xaml.XamlMember" />z tym elementem. <see langword="set" /></summary>
        <returns>Dla skojarzonej <see langword="set" /> metody dostępu; lub <see langword="null" />. <see cref="T:System.Reflection.MethodInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja domyślna interpretuje <xref:System.Xaml.XamlMember.UnderlyingMember%2A> jako <xref:System.Reflection.PropertyInfo> <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> i zwraca wartość (z parametrem ustawionym na `true`), co oznacza, że zwracana metoda może być niepubliczna. Może to skutkować `null` niektórymi przypadkami, w tym przypadki, w których nie ma takiego dostępu, lub członek nie jest właściwością.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> z elementu na <xref:System.Xaml.Schema.XamlMemberInvoker>skojarzonym elemencie. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter. Upewnij się, że <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>Zaimplementuj, <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>i tak, aby wszystkie zwracały skorelowane wyniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca implementację serializatora wartości, która jest skojarzona z tym <see cref="T:System.Xaml.XamlMember" />elementem.</summary>
        <returns>Wystąpienie z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczeniem lub <see langword="null" />. <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja używa następującej kolejności logiki i przetwarzania:  
  
-   Jeśli przypisanie istnieje na poziomie elementu członkowskiego (<xref:System.Windows.Markup.ValueSerializerAttribute>), informacje o atrybutach są używane do <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> wywołania względem kontekstu schematu XAML.  
  
-   Jeśli <xref:System.Xaml.XamlMember.Type%2A> jest prawidłowy, jest zwracany konwerter wartości, który jest skojarzony z typem.  
  
-   Jeśli poprzednie warunki nie mają zastosowania, `null` są zwracane.  
  
 Ta metoda jest wywoływana, gdy obiekt wywołujący pobiera wartość <xref:System.Xaml.XamlMember.ValueSerializer%2A>z. Zastąp tę metodę, jeśli chcesz zgłosić jednolite wyniki dla całej <xref:System.Xaml.XamlMember> klasy pochodnej lub jeśli masz specjalne metadane, aby określić to dla każdej wielkości liter.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiuje otwierające i zamykające nawiasy klamrowe dla rozszerzenia znacznika.</summary>
        <value>Kolekcja zawierająca znaki otwierającego i zamykającego nawiasu klamrowego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ciąg <see cref="T:System.Xaml.XamlMember" />nazwy, który deklaruje ten element. <see langword="xamlName" /></summary>
        <value>Ciąg nazwy, który deklaruje <see cref="T:System.Xaml.XamlMember" />ten element. <see langword="xamlName" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość jest zawsze ustawiana podczas konstruowania. Konstruktory zaimplementowane przez <xref:System.Xaml.XamlMember> zazwyczaj zgłaszają wyjątek, jeśli nie określono nazwy początkowej; w związku z tym nie należy oczekiwać, że ta właściwość będzie `null` lub jest pustym ciągiem, jeśli są używane domyślne usługi .NET Framework XAML metod.  
  
 [Gramatyka XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) i reguły nazewnictwa dla typu CLR i elementów członkowskich nie są dokładnymi przecięciami. Istnieje możliwość zadeklarowania nazwy elementu członkowskiego, który jest dozwolony w środowisku CLR, ale nie jest to prawidłowe w przypadku nazewnictwa XAML. Jeśli to możliwe, należy unikać takiej sytuacji.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa <see cref="T:System.Xaml.XamlMember" /> określone obiekty mają tę samą wartość.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="xamlMember1" /> jest taka sama jak <paramref name="xamlMember2" />wartość; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <param name="xamlMember2">A <see cref="T:System.Xaml.XamlMember" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa <see cref="T:System.Xaml.XamlMember" /> określone obiekty mają różne wartości.</summary>
        <returns><see langword="true" />Jeśli wartość <paramref name="xamlMember1" /> różni się od <paramref name="xamlMember2" />wartości; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator URI pojedynczego obszaru nazw XAML, który identyfikuje podstawową przestrzeń nazw <see cref="T:System.Xaml.XamlMember" />XAML.</summary>
        <value>Identyfikator podstawowej przestrzeni nazw XAML dla tego <see cref="T:System.Xaml.XamlMember" />, jako ciąg.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zapewnia taką samą wartość jak wywoływanie <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> , a następnie pobranie pierwszego ciągu wartości z zwróconej listy. <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Preferowana przestrzeń nazw XAML powinna zostać użyta podczas zapisywania elementu członkowskiego z powrotem do tekstu lub innych reprezentacji, które zachowują informacje o przestrzeni nazw XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> Pobiera wartość, która wskazuje, jak projektant wizualny powinien przetworzyć element członkowski.</summary>
        <value>Wartość <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> wyliczenia. Wartość domyślna to <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, <see cref="T:System.Xaml.XamlMember" /> który może istnieć. <see cref="T:System.Xaml.XamlType" /></summary>
        <value>Typ, w którym <see cref="T:System.Xaml.XamlMember" /> może istnieć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwracana wartość jest różna dla elementów członkowskich, które są możliwe do dołączenia. W przypadku elementów członkowskich, które nie <xref:System.Xaml.XamlMember.TargetType%2A> są <xref:System.Xaml.XamlMember.DeclaringType%2A>możliwe do dołączenia, zwraca. W przypadku dołączalnych <xref:System.Xaml.XamlMember.LookupTargetType%2A> elementów członkowskich zwraca wynik oparty na tej logice:  
  
-   Jeśli odbicie nie może rozpoznać kopii<xref:System.Xaml.XamlMember.IsUnknown%2A> zapasowej ( `true`), Metoda ta zwraca wewnętrzną stałą, która reprezentuje typ obiektu ogólnego.  
  
-   Jeśli poprzedni warunek nie ma zastosowania, <xref:System.Xaml.XamlMember.LookupTargetType%2A> jest wywoływana. Domyślna implementacja zwraca <xref:System.Xaml.XamlType> , który jest oparty na badaniu metod, które `get` implementują metody dostępu i `set` . Klasa może przesłonić <xref:System.Xaml.XamlMember.LookupTargetType%2A> użycie innego zachowania, takiego jak inne formularze metadanych, które mogą zgłaszać typy docelowe dla dołączalnych elementów członkowskich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację <see cref="T:System.Xaml.XamlMember" />ciągu.</summary>
        <returns>Reprezentacja <see cref="T:System.Xaml.XamlMember" />ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zwraca <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xaml.XamlType" /> Pobiera typ, który jest używany przez element członkowski.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Typ, który jest używany przez element członkowski.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.Type%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupType%2A> Dzieje się tak, gdy początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 W przypadku zachowania domyślnego (bez <xref:System.Xaml.XamlMember.LookupType%2A> zastępowania) zwracane <xref:System.Xaml.XamlType> mogą mieć różne znaczenie koncepcyjne. Znaczenie znaczenia jest zależne od tego, <xref:System.Xaml.XamlMember> czy reprezentuje on właściwość, metodę lub zdarzenie, jak pokazano na poniższej liście:  
  
-   Dla właściwości zwracana <xref:System.Xaml.XamlType> jest typ, który ustawia właściwość lub jest zwracany przez właściwość.  
  
-   Dla zdarzenia zwracany <xref:System.Xaml.XamlType> jest wymagany typ programu obsługi zdarzeń (delegat w implementacji środowiska CLR).  
  
-   Dla metody <xref:System.Xaml.XamlType> jest zwracanym typem tej metody, która może być `null`.  
  
 W każdym przypadku kontekst schematu XAML służy do szacowania typu XAML z typu zapasowego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Pobiera obiekt, który może być używany na potrzeby konstrukcji konwersji typów zadeklarowanych obiektów XAML.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Wartość, <see cref="T:System.ComponentModel.TypeConverter" /> z ograniczeniem ogólnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.TypeConverter%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupTypeConverter%2A> To zachowanie występuje, gdy początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 Implementacje zwracające wartość właściwości o <xref:System.Xaml.XamlMember.TypeConverter%2A> wartości innej niż null nie muszą być wykonywane. <xref:System.ComponentModel.TypeConverter> Poniżej znajduje się lista możliwych wartości zwracanych innych niż null dla <xref:System.Xaml.XamlMember.TypeConverter%2A> i jakie są następujące wartości:  
  
-   Wartość zwracana zgłasza konwerter typu, który jest przypisany do tego elementu członkowskiego lub bardziej ogólnie do typu docelowego konwertera. Takie zachowanie jest zazwyczaj najlepszym sposobem wyszukiwania przez większość systemów typu XAML i procesorów XAML w celu utworzenia wystąpienia konwertera typów i wywołania jego metod.  
  
-   Wartość zwracana zgłasza wbudowany konwerter wartości. Te konwertery istnieją dla pewnych operacji wewnętrznych wykonywanych przez składnik zapisywania języka XAML. W szczególności te wbudowane konwertery wartości konwertują wartości ciągów nieprzetworzonych atrybutów na elementy pierwotne na poziomie języka XAML. W przypadku .NET Framework implementacji usług XAML te wbudowane konwersje typów często przekazują do konwertera typów, który jest zdefiniowany w zestawie systemowym. Na przykład konwersja dla <xref:System.Int32> wartości ma wbudowaną konwersję przekazana, w związku z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> czym odwołania <xref:System.ComponentModel.Int32Converter>do wartości.  
  
-   Wartość zwracana zgłasza specjalny przypadek nieograniczonego modelu obiektów; oznacza to, <xref:System.Xaml.XamlMember> że <xref:System.Xaml.XamlMember.Type%2A> ma wartość <xref:System.Object>. W takim przypadku <xref:System.Xaml.Schema.XamlValueConverter%601> raporty <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> będące {`Object}`. Jednak jest to `null` spowodowane brakiem rzeczywistego typu lub wystąpienia, które nie jest dostępne do wykonania tej konwersji. <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> Zamiast tego zachowanie modelu obiektów nie może zostać określone do czasu uruchomienia, gdy środowisko uruchomieniowe określonej technologii określa obsługę grafu obiektów.  
  
 Jeśli możesz uzyskać dostęp do pracy <xref:System.ComponentModel.TypeConverter> z <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>poziomu, możesz wywołać jego metody konwersji. Jednak wiele metod konwersji polega na kontekście usługi. Jeśli nie masz dostępnego tego samego kontekstu usługi, który jest oczekiwany przez konwerter typu dla jego typowej roli pisania obiektów dla wykresów obiektów, metody konwerterów mogą generować wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera System <see cref="T:System.Reflection.MemberInfo" /> typów CLR, który jest dostępny dla elementu członkowskiego, który jest zbudowany <see cref="T:System.Reflection.MethodInfo" />przez <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />lub.</summary>
        <value>Informacje o systemie <see cref="T:System.Reflection.MemberInfo" /> typów CLR jako rzutowanie z początkowych parametrów konstruktora. Obiekt <see cref="T:System.Xaml.XamlMember" /> , który jest zbudowany <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> z zwracanymi <see langword="null" />sygnaturami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.UnderlyingMember%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Pobiera obiekt, który jest używany do serializacji wartości zadeklarowanych obiektów XAML.</summary>
        <value>With z <see cref="T:System.Windows.Markup.ValueSerializer" />ograniczeniemnaogólny. <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie wywoływania <xref:System.Xaml.XamlMember.ValueSerializer%2A> lubokreślonegoprzesłonięciatejmetody.<xref:System.Xaml.XamlMember.LookupValueSerializer%2A> To zachowanie występuje, gdy początkowa wewnętrzna logika odbicia nie ustawił jeszcze informacji.  
  
 Nie wszystkie przypadki, w <xref:System.Xaml.XamlMember.ValueSerializer%2A> których zwracana jest wartość właściwości inna niż null, muszą być w działaniu. <xref:System.Windows.Markup.ValueSerializer> Zobacz <xref:System.Xaml.XamlMember.TypeConverter%2A>: te same zagadnienia <xref:System.Xaml.XamlMember.ValueSerializer%2A>dotyczą programu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

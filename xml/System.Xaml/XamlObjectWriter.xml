<Type Name="XamlObjectWriter" FullName="System.Xaml.XamlObjectWriter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="31f36e0757a0ec127b5ff19e37dca6c8a490d0de" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69427203" /></Metadata><TypeSignature Language="C#" Value="public class XamlObjectWriter : System.Xaml.XamlWriter, System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlObjectWriter extends System.Xaml.XamlWriter implements class System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlObjectWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlObjectWriter&#xA;Inherits XamlWriter&#xA;Implements IXamlLineInfoConsumer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlObjectWriter : System::Xaml::XamlWriter, System::Xaml::IXamlLineInfoConsumer" />
  <TypeSignature Language="F#" Value="type XamlObjectWriter = class&#xA;    inherit XamlWriter&#xA;    interface IXamlLineInfoConsumer" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlWriter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xaml.IXamlLineInfoConsumer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Tworzy Graf obiektu na podstawie strumienia źródłowego węzła XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlWriter.WriteNode%2A> Metodyimplementacjiwzorca<xref:System.Xaml.XamlWriter> tak, <xref:System.Xaml.XamlObjectWriter> aby używały, który jest zdefiniowany przez metodę. <xref:System.Xaml.XamlObjectWriter> `Write` <xref:System.Xaml.XamlWriter.WriteNode%2A>przełączenia logiki `Write` między metodami, w zależności od tego, który typ węzła znajduje się na bieżącym miejscu w czytniku.  
  
## <a name="scope"></a>Scope  
 A <xref:System.Xaml.XamlObjectWriter> ma koncepcję zakresu <xref:System.Xaml.XamlObjectWriter> , czyli utrzymuje punkt koncepcyjny odwołania w jego grafie obiektów wyjściowych. W przypadku konkretnego zakresu niektóre operacje mogą być prawidłowe lub nieprawidłowe lub generować wynik braku operacji. Na przykład w przypadku wywołania <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> do dyrektywy Write w celu zainicjowania obiektu, który już istnieje jako wystąpienie, domyślna implementacja zgłasza wyjątek.  
  
 Możliwa metoda śledzenia zakresu w niestandardowym <xref:System.Xaml.XamlObjectWriter> polega na wyrównaniu akcji węzła z klasą stosu lub ramki. Stos lub ramka może śledzić wypchnięcie i wyskakujące dla każdego poziomu głębokości modelu obiektów, który jest wprowadzany lub zakończony podczas <xref:System.Xaml.XamlObjectWriter> zapisywania grafu obiektów.  
  
## <a name="callbacks"></a>Wywołania zwrotne  
 Aby zapewnić obsługę pośrednich i zaawansowanych <xref:System.Xaml.XamlObjectWriter> scenariuszy, mechanizm pisania grafu obiektów zapewnia punkty wejścia wywołania zwrotnego, które występują <xref:System.Xaml.XamlObjectWriter> podczas zatwierdzania lub ma zatwierdzić pewne akcje. Niektóre wywołania zwrotne są włączone w ustawieniach i nie są specyficzne dla typu obiektu lub elementu członkowskiego, który jest zapisywany; informacje dotyczące wywołania zwrotnego są jednak często dostępne w kontekście lub są danymi zdarzeń wysyłanych za pomocą wywołania zwrotnego. Poniżej znajduje się lista odpowiednich wywołań zwrotnych:  
  
-   Wywołanie zwrotne zadeklarowane przez <xref:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler%2A> jest wywoływane, gdy zakres przechodzi do nowego obiektu i <xref:System.ComponentModel.ISupportInitialize.BeginInit%2A> w fazie okresu istnienia obiektu dla każdego utworzonego obiektu.  
  
-   Wywołanie zwrotne zadeklarowane przez <xref:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler%2A> jest wywoływane, gdy zakres przechodzi do nowego obiektu i <xref:System.ComponentModel.ISupportInitialize.EndInit%2A> w fazie okresu istnienia obiektu dla każdego utworzonego obiektu.  
  
-   Wywołanie zwrotne zadeklarowane przez <xref:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler%2A> jest wywoływane, gdy zakres zaczyna się w obiekcie i występuje, gdy pierwsze <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> wywołanie do tego zakresu obiektu jest wykonane, ale jeszcze nie zostało zatwierdzone.  
  
-   Wywołanie zwrotne zadeklarowane przez <xref:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler%2A> jest wywoływane, gdy zakres zaczyna się w obiekcie i występuje, <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> gdy zostanie wykonane wywołanie do tego zakresu obiektu, ale jeszcze nie zostało zatwierdzone.  
  
-   Wywołanie zwrotne zadeklarowane przez <xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A> jest wywoływane, <xref:System.Xaml.XamlObjectWriter.OnSetValue%2A> gdy jest wywoływana.  
  
## <a name="writing-dictionary-keys"></a>Pisanie kluczy słownika  
 Domyślna implementacja programu <xref:System.Xaml.XamlObjectWriter> obsługuje konwersję typu w ograniczeniach <xref:System.Collections.Generic.Dictionary%602> , zanim zawartość słownika zostanie dodana do grafu obiektów. W ten sposób słownik ogólny może być konfigurowany w czasie wykonywania według obiektów i może być zgodny z odpowiednim zachowaniem `Add` ogólnym i indeksatorem. Jednak zgodnie z implementacją dla podstawy <xref:System.Xaml.XamlObjectWriter>, ta funkcja istnieje tylko dla tworzenia grafów obiektów z klasy <xref:System.Collections.Generic.Dictionary%602> bazowej, a <xref:System.Collections.Generic.Dictionary%602>nie dla klas pochodnych.  
  
## <a name="checks-for-disposed"></a>Sprawdza, czy usunięto  
 Moduły zapisujące XAML są potencjalnie używane dla operacji odroczonych lub w przypadku, gdy wywołanie zostało wykonane względem wystąpienia składnika zapisywania języka XAML, które zostało usunięte w tymczasowym elemencie. Różne interfejsy API <xref:System.Xaml.XamlObjectWriter> programu <xref:System.ObjectDisposedException> mogą zgłaszać w takich przypadkach.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlWriter" />
    <altmember cref="T:System.Xaml.XamlObjectReader" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlObjectWriter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter schemaContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="schemaContext">Kontekst schematu XAML, który jest współużytkowany z czytnikiem XAML, który zawiera węzły do zapisu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlObjectWriter" /> klasy przy użyciu kontekstu schematu XAML, który jest używany <see cref="T:System.Xaml.XamlReader" />przez.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext, System.Xaml.XamlObjectWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.XamlObjectWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext,System.Xaml.XamlObjectWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext, settings As XamlObjectWriterSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::XamlObjectWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext * System.Xaml.XamlObjectWriterSettings -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter (schemaContext, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="settings" Type="System.Xaml.XamlObjectWriterSettings" />
      </Parameters>
      <Docs>
        <param name="schemaContext">Kontekst schematu XAML, który jest współużytkowany z czytnikiem XAML, który zawiera węzły do zapisu.</param>
        <param name="settings">Obiekt ustawień, który określa niektóre opcje <see cref="T:System.Xaml.XamlObjectWriter" /> zachowania i danych wyjściowych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlObjectWriter" /> klasy przy użyciu kontekstu, który jest używany <see cref="T:System.Xaml.XamlReader" /> przez i jego ustawienia.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="xamlObjectWriter.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje wszystkie możliwe ramki i czyści wykres obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="xamlObjectWriter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zarządzane zasoby; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Xaml.XamlObjectWriter" />program, a opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterBeginInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterBeginInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterBeginInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterBeginInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterBeginInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterBeginInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterBeginInit : obj -&gt; unit&#xA;override this.OnAfterBeginInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterBeginInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, na którym ma być zgłaszane. Obiekt jest spakowany do <see cref="T:System.Xaml.XamlObjectEventArgs" /> momentu wywołania programu obsługi.</param>
        <summary>Wywołuje każdą <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler" /> metodę, która jest skojarzona z <see cref="T:System.Xaml.XamlObjectWriter" />tym elementem <see cref="T:System.Xaml.XamlObjectWriterSettings" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterEndInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterEndInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterEndInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterEndInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterEndInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterEndInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterEndInit : obj -&gt; unit&#xA;override this.OnAfterEndInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterEndInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, na którym ma być zgłaszane. Wartość jest pakowana do <see cref="T:System.Xaml.XamlObjectEventArgs" /> momentu wywołania programu obsługi.</param>
        <summary>Wywołuje każdą <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler" /> metodę, która jest skojarzona z <see cref="T:System.Xaml.XamlObjectWriter" />tym elementem <see cref="T:System.Xaml.XamlObjectWriterSettings" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterProperties : obj -&gt; unit&#xA;override this.OnAfterProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, na którym ma być zgłaszane. Jest to spakowane do <see cref="T:System.Xaml.XamlObjectEventArgs" /> momentu wywołania programu obsługi.</param>
        <summary>Wywołuje każdą <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler" /> metodę, do której istnieje odwołanie <see cref="T:System.Xaml.XamlObjectWriterSettings" /> , która <see cref="T:System.Xaml.XamlObjectWriter" />jest skojarzona z tym elementem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnBeforeProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeforeProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeforeProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnBeforeProperties : obj -&gt; unit&#xA;override this.OnBeforeProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnBeforeProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać <see cref="T:System.Xaml.XamlObjectEventArgs" /> przekazana po wywołaniu procedury obsługi.</param>
        <summary>Wywołuje każdą <see cref="P:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler" /> metodę, do której istnieje odwołanie <see cref="T:System.Xaml.XamlObjectWriterSettings" /> , która <see cref="T:System.Xaml.XamlObjectWriter" />jest skojarzona z tym elementem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetValue">
      <MemberSignature Language="C#" Value="protected virtual bool OnSetValue (object eventSender, System.Xaml.XamlMember member, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnSetValue(object eventSender, class System.Xaml.XamlMember member, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnSetValue(System.Object,System.Xaml.XamlMember,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnSetValue (eventSender As Object, member As XamlMember, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnSetValue(System::Object ^ eventSender, System::Xaml::XamlMember ^ member, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool&#xA;override this.OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool" Usage="xamlObjectWriter.OnSetValue (eventSender, member, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSender" Type="System.Object" />
        <Parameter Name="member" Type="System.Xaml.XamlMember" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventSender">Obiekt, który ma być raportowany jako źródło do procedury obsługi.</param>
        <param name="member">Nazwa właściwości do ustawienia, która jest przenoszona do procedury obsługi w ramach <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" />.</param>
        <param name="value">Wartość, która ma być określona dla właściwości o nazwie <paramref name="property" />. Wartość jest przenoszona do procedury obsługi w ramach programu <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" />.</param>
        <summary>Wywołuje każdą <see cref="P:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler" /> metodę, <see cref="T:System.Xaml.XamlObjectWriterSettings" /> do której odwołuje się dla tego <paramref name="handled" /> składnika zapisywania, tak długo <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> , jak w danych <see langword="true" />zdarzenia nie jest.</summary>
        <returns>Wartość logiczna, która jest ustawiana przez wszystkie powiązane procedury obsługi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja dla tego składnika zapisywania XAML ma skojarzoną procedurę obsługi <xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A> (jest zadeklarowana <xref:System.Xaml.XamlObjectWriterSettings>w elemencie), ta metoda <xref:System.Windows.Markup.XamlSetValueEventArgs> tworzy nowe i przekazuje je do programu obsługi. `SetValue` Wartość zwracana jest ustawiana przez odczytanie <xref:System.Windows.Markup.XamlSetValueEventArgs.Handled%2A> wartości, która jest przenoszona przez dane zdarzenia. Jeśli nie istnieje procedura obsługi i wywoływana jest metoda, wywołanie zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual object Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Result" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.Result" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Result As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Result { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : obj" Usage="System.Xaml.XamlObjectWriter.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ostatni zapisany obiekt. Zazwyczaj wywoływana tylko wtedy, gdy strumień węzłów jest na końcu, a wykres obiektu jest ukończony.</summary>
        <value>Ostatni obiekt z zapisem lub <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typowym użyciem <xref:System.Xaml.XamlObjectWriter.Result%2A> jest wywoływanie go tylko wtedy, gdy strumień węzła jest znany na końcu, a wykres obiektu jest ukończony. W przeciwnym razie Graf obiektu może być niekompletny i nie jest użyteczny w przypadku większości scenariuszy platformy.  
  
 <xref:System.Xaml.XamlObjectWriter.Result%2A>zwykle zawiera wartość różną od null, jeśli jest wywoływana natychmiast po wywołaniu do <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>, i jeśli bieżący zakres znajduje się w elemencie członkowskim, gdzie obiekt udostępnia wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootNameScope">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.INameScope RootNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.INameScope RootNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RootNameScope As INameScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::INameScope ^ RootNameScope { System::Windows::Markup::INameScope ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RootNameScope : System.Windows.Markup.INameScope" Usage="System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Markup.INameScope" /> Pobiera usługę, która utrzymuje namescope XAML dla bezwzględnego węzła nadrzędnego modułu zapisywania obiektów XAML.</summary>
        <value><see cref="T:System.Windows.Markup.INameScope" /> Usługa, która utrzymuje namescope XAML dla bieżącego elementu głównego modułu zapisywania obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości może pochodzić z kontekstu zapisywania obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public override System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktywny kontekst schematu XAML.</summary>
        <value>Kontekst schematu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst schematu XAML jest niezbędnym źródłem informacji dla większości praktycznych scenariuszy pisania obiektów. Kontekst schematu XAML ma wpływ na wyszukiwanie typu dla typów zapasowych i zawiera informacje o zestawach, w których istnieją typy kopii zapasowych. Domyślny kontekst schematu XAML jest oparty na regułach mapowania typów CLR. Struktury zwykle zapewniają własny kontekst schematu XAML, aby zapewnić, że mechanizmy ładowania zestawów są zgodne z modelami aplikacji firmy AMD programistycznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLineInfo">
      <MemberSignature Language="C#" Value="public void SetLineInfo (int lineNumber, int linePosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLineInfo(int32 lineNumber, int32 linePosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.SetLineInfo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLineInfo (lineNumber As Integer, linePosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetLineInfo(int lineNumber, int linePosition);" />
      <MemberSignature Language="F#" Value="abstract member SetLineInfo : int * int -&gt; unit&#xA;override this.SetLineInfo : int * int -&gt; unit" Usage="xamlObjectWriter.SetLineInfo (lineNumber, linePosition)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
        <Parameter Name="linePosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">Numer wiersza z czytnika.</param>
        <param name="linePosition">Położenie linii od czytnika.</param>
        <summary>Implementuje <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" /> i udostępnia informacje o wierszach dla wyjątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usługi nie jest przeznaczona do wywoływania bezpośrednio w kodzie. Jeśli jednak tworzysz klasę pochodną z <xref:System.Xaml.XamlObjectWriter> i oczekujesz, że dla kontekstu, w którym numery wierszy są niedostępne lub nie są przydatne, ta metoda może być wywoływana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldProvideLineInfo">
      <MemberSignature Language="C#" Value="public bool ShouldProvideLineInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldProvideLineInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldProvideLineInfo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldProvideLineInfo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldProvideLineInfo : bool" Usage="System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xaml.IXamlLineInfoConsumer.ShouldProvideLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która określa, czy usługa informacji o wierszu powinna podawać wartości, a w związku z <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" /> tym powinna wywołać metodę, gdy ma to zastosowanie.</summary>
        <value><see langword="true" />Jeśli moduł zapisujący używa informacji o wierszu, w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja zawsze zwraca `true`wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEndMember">
      <MemberSignature Language="C#" Value="public override void WriteEndMember ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndMember" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndMember ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndMember();" />
      <MemberSignature Language="F#" Value="override this.WriteEndMember : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący zakres elementów członkowskich i może napisać wartość zakresu elementu członkowskiego, gdy zostanie zamknięty. Nowy zakres zmieni zakres obiektu nadrzędnego elementu członkowskiego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">Nie można utworzyć wartości elementu członkowskiego z węzła wartości, który występuje między tym wywołaniem i <see langword="StartMember" />poprzednią.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject();" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący zakres obiektów w składniku zapisywania. Nowy zakres obiektów zostanie przekształcony w nadrzędny zakres elementu członkowskiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ten `EndObject` zakres położenia zamyka obiekt główny, nowy zakres obiektów stanie się głównym zakresem.  
  
 Wywołanie programu <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> mogło jeszcze nie utworzyć obiektu, ponieważ element członkowski obiektu może być niezbędną przyczyną inicjalizacji, taką jak tekst inicjujący lub parametry inicjalizacji. W takich przypadkach wywołanie w <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> rzeczywistości zapisuje obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteGetObject">
      <MemberSignature Language="C#" Value="public override void WriteGetObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteGetObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteGetObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteGetObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteGetObject();" />
      <MemberSignature Language="F#" Value="override this.WriteGetObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteGetObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje koncepcję <see langword="StartObject" /> do grafu obiektów, gdy określony obiekt jest wartością domyślną lub niejawną właściwości nadrzędnej. Wartość niejawna pochodzi z informacji uzyskanych z kontekstu schematu XAML i informacji o typie zapasowym, a nie jako wartość obiektu w wejściowym zestawie węzłów XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Różnica między pisaniem <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> i <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> pisaniem w programie może być widoczna na wynikowym wykresie obiektów. <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>nie tworzy wystąpienia typu, ponieważ <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> interfejs API nie ma informacji do poinformowania grafu obiektów o tym, co należy skonstruować. Zamiast tego obiekt został utworzony, gdy właściwość nadrzędna została zainicjowana; <xref:System.Xaml.XamlObjectWriter> dlatego nie musi to być konstrukcja. Z kolei <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> określa, że wystąpienie tego typu powinno być skonstruowane i wstawiane do grafu obiektów.  
  
 Jeśli chcesz traktować strumień węzłów XAML jako serię ramek, jest on <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> równoważony <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> do wywołania. W związku z tym liczba <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> wywołań <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> Plus <xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A> powinna być równa liczbie wywołań w ramach kompletnej oceny obiektu i zapisu strumienia węzła XAML.  
  
 Pozycja koncepcyjna `StartObject` dla niejawnego obiektu w grafie obiektów jest niezbędna, ponieważ chociaż sama wartość obiektu jest niejawną wartością domyślną, ten obiekt może nadal mieć elementy członkowskie, które muszą być zapisywane w oparciu o strumień węzłów XAML. Typowym scenariuszem, gdy występuje to <xref:System.Xaml.XamlObjectWriter> , jest zapisanie węzłów elementów członkowskich dla właściwości kolekcji, a inicjowanie kolekcji jest niejawne w przypadku tworzenia obiektu, który jest właścicielem właściwości kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteNamespace">
      <MemberSignature Language="C#" Value="public override void WriteNamespace (System.Xaml.NamespaceDeclaration namespaceDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteNamespace(class System.Xaml.NamespaceDeclaration namespaceDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteNamespace(System.Xaml.NamespaceDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteNamespace(System::Xaml::NamespaceDeclaration ^ namespaceDeclaration);" />
      <MemberSignature Language="F#" Value="override this.WriteNamespace : System.Xaml.NamespaceDeclaration -&gt; unit" Usage="xamlObjectWriter.WriteNamespace namespaceDeclaration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceDeclaration" Type="System.Xaml.NamespaceDeclaration" />
      </Parameters>
      <Docs>
        <param name="namespaceDeclaration">Deklaracja przestrzeni nazw do zapisu.</param>
        <summary>Definiuje deklarację przestrzeni nazw, która ma zastosowanie do następnego zakresu obiektu lub zakresu elementu członkowskiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deklarację przestrzeni nazw można zapisać, jeśli bieżący zakres jest zakresem głównym, zakresem obiektów lub zakresem elementu członkowskiego. Jednakże można wywołać tylko bezpośrednio przed wywołaniem jednego z następujących elementów: <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>, <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>, lub <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>. <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> Kolejnym <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> przypadkiem jest zapisanie wielu deklaracji przestrzeni nazw do tego samego węzła. Ostatecznie, <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A> <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A> albo musi być wywoływana.  
  
 <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>nie używa elementu `Start` / metaphor`End` . Chociaż przestrzeń nazw XAML ma elementy członkowskie w sensie reprezentacji CLR, elementy członkowskie są znane i nie trzeba ich reprezentować jako specjalnego typu <xref:System.Xaml.XamlMember> dla rozszerzalności. Aby uzyskać dostęp do wartości <xref:System.Xaml.NamespaceDeclaration>, można uzyskać dostęp do jej <xref:System.Xaml.NamespaceDeclaration.Prefix%2A> <xref:System.Xaml.NamespaceDeclaration.Namespace%2A> właściwości i.  
  
 Deklaracja przestrzeni nazw może mieć <xref:System.String.Empty?displayProperty=nameWithType> wartość dla prefiksu. <xref:System.String.Empty?displayProperty=nameWithType> Prefiks reprezentuje deklarację domyślnej przestrzeni nazw XAML. Nie należy próbować używać wartości null do reprezentowania domyślnego prefiksu;  zgłasza wyjątek w tym interfejsie API. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.NamespaceDeclaration>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="namespaceDeclaration" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException">Składnik programu <paramref name="namespaceDeclaration" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Xaml.XamlObjectReaderException">Podjęto próbę zapisania węzła przestrzeni nazw XAML w nieprawidłowym zakresie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartMember">
      <MemberSignature Language="C#" Value="public override void WriteStartMember (System.Xaml.XamlMember property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartMember(class System.Xaml.XamlMember property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartMember(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartMember (property As XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartMember(System::Xaml::XamlMember ^ property);" />
      <MemberSignature Language="F#" Value="override this.WriteStartMember : System.Xaml.XamlMember -&gt; unit" Usage="xamlObjectWriter.WriteStartMember property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="property">Właściwość XAML do zapisu. Zwykle uzyskujesz tę wartość z czytnika XAML za pośrednictwem pośredniego strumienia węzłów XAML.</param>
        <summary>Zapisuje nowy węzeł elementu członkowskiego w bieżącym zakresie obiektu, a zakres jest nowym zakresem elementu członkowskiego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Xaml.XamlDuplicateMemberException>Obserwuj, która występuje, gdy ta sama Właściwość XAML jest ustawiona dwukrotnie w danych wejściowych XAML. W prostych przypadkach, na przykład gdy ta sama właściwość jest ustawiona w składni atrybutów i składni elementu właściwości, można łatwo zobaczyć ten wyjątek w znacznikach wejściowych. Jednak mogą wystąpić bardziej delikatne przypadki, które są trudniejsze do zapamiętania. Na przykład ten wyjątek może wystąpić, jeśli ustawisz właściwość zawartości XAML, jeśli powiążesz się z właściwościami otoczenia XAML, a Właściwość włącza zarówno użycie możliwe do dołączenia, jak i wystąpienie. W fazach debugowania opracowywania można często zlokalizować ten wyjątek, wyświetlając pośrednią reprezentację węzła XAML, która łączy odczytywanie znaczników i zapis grafu obiektów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException"><paramref name="property" /><see cref="P:System.Xaml.XamlMember.IsUnknown" /> ma<see langword="true" />ustawioną wartość.  
  
—lub— 
 <see cref="P:System.Xaml.XamlLanguage.UnknownContent" />przeszedł, co oznacza, że strumień węzłów XAML zawiera zawartość dla obiektu, który nie obsługuje zawartości.  
  
—lub— 
Podjęto próbę zapisania początkowego elementu członkowskiego w nieprawidłowym zakresie.</exception>
        <exception cref="T:System.Xaml.XamlDuplicateMemberException"><paramref name="property" />Określa właściwość, która jest już jawnie ustawiona w zakresie obiektu nadrzędnego.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartObject(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xaml.XamlType -&gt; unit" Usage="xamlObjectWriter.WriteStartObject xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Typ do zapisu. Zwykle uzyskujesz tę wartość z czytnika XAML.</param>
        <summary>Zapisuje węzeł obiektu w bieżącym zakresie i ustawia zakres na nowy zakres obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException"><see cref="P:System.Xaml.XamlType.IsUnknown" /> Przetwarzanie typu i nie można utworzyć obiektu.  
  
—lub— 
Podjęto próbę zapisania obiektu początkowego w nieprawidłowym zakresie.</exception>
        <exception cref="T:System.Xaml.XamlParseException">Podjęto próbę zapisania obiektu głównego, gdy obiekt główny został już podany w ustawieniach.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlType" />jest <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Jeśli bieżący zakres znajduje się w kolekcji, słowniku lub tablicy, nowe wystąpienie należy dodać do kolekcji, słownika lub tablicy przy użyciu <see langword="Add" /> metody odpowiedniego typu. W przeciwnym razie element członkowski powinien zostać przypisany do nowego wystąpienia.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public override void WriteValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteValue : obj -&gt; unit" Usage="xamlObjectWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zapisu.</param>
        <summary>Zapisuje wartość do zakresu bieżącego elementu członkowskiego. Jeśli bieżący zakres znajduje się wewnątrz kolekcji, słownika lub obiektu Array, wartość należy dodać do kolekcji, słownika lub tablicy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">Podjęto próbę zapisania wartości w nieprawidłowym zakresie.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f660970c55af6a8e8be700e1df5ac2c266d1596" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56383495" /></Metadata><TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Raporty informacji na temat typów XAML jako część całego systemu XAML, który zaimplementowano w .NET Framework XAML Services.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele interfejsów API w <xref:System.Xaml.XamlType> klasy zawierają informacje o typach XAML, w którym koncepcja mogą raportować jest podobna do poszczególnych sekcji XAML specification [MS-XAML].  
  
 <xref:System.Xaml.XamlType> jest często używane w interfejsie API programu .NET Framework XAML Services raportowania informacji o typie XAML. <xref:System.Xaml.XamlType> Raporty informacje, które należy wiedzieć o typie XAML, aby móc pracować z wystąpieniem usługi lub uzyskać dostęp do jego członków z strumień węzłów XAML lub podobne reprezentacji XAML. Jego raportowania jest podobny jak <xref:System.Type> w CLR system typów, wraz z klasy odbicia takich jak <xref:System.Reflection.MemberInfo>, zawierają informacje dotyczące typu CLR i sposób jej użycia.  
  
 Aby rozszerzyć system typów XAML, może pochodzić z <xref:System.Xaml.XamlType>. Aby zrobić to efektywne, konieczne może być zaimplementować <xref:System.Xaml.Schema.XamlTypeInvoker>. <xref:System.Xaml.Schema.XamlTypeInvoker> Umożliwia uogólnionego system typów XAML do pracy z system typów kopii określisz jako część zachowanie wywołania. Określone niestandardowe <xref:System.Xaml.Schema.XamlTypeInvoker> zapewnia sposób zmniejszenia zależności w systemie typu CLR, które są używane przez domyślny <xref:System.Xaml.XamlType> zachowanie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Bazowego środowiska CLR <see cref="T:System.Type" /> dla typu XAML do utworzenia.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytników XAML lub moduły zapisujące XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy oparte na podstawowych informacji o typie CLR.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden <paramref name="underlyingType" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu do utworzenia.</param>
        <param name="typeArguments">Argumenty typu <see cref="T:System.Xaml.XamlType" /> który reprezentuje typ ogólny. Można (i często jest) <see langword="null" />, co oznacza, że reprezentowana typ nie jest typem ogólnym.</param>
        <param name="schemaContext">Kontekst schematu XAML dla XAML czytników i składników zapisywania XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy na podstawie ciągu nazwy typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to Konstruktor chroniony. Nie bieżącego publiczne klasy pochodne istnieje używających tej konkretnej ścieżki w celu konstruowania. Jako użytkownik istniejącej <xref:System.Xaml.XamlType>, należy użyć innych sygnatury konstruktora (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, lub <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) do zainicjowania <xref:System.Xaml.XamlType> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden <paramref name="typeName" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Podstawowy typ dla typu XAML do utworzenia.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytnika XAML.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Implementację, która obsługuje w czasie wykonywania odbicia wywołuje względem <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy na podstawie podstawowego typu informacji i <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> implementacji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden <paramref name="underlyingType" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Przestrzeń nazw XAML dla typu, w postaci ciągu.</param>
        <param name="unknownTypeName">Nazwa typu w określonych <paramref name="unknownTypeNamespace" /> przestrzeń nazw XAML.</param>
        <param name="typeArguments">Argumenty typu <see cref="T:System.Xaml.XamlType" /> który reprezentuje typ ogólny. Można (i często jest) <see langword="null" />, co oznacza, że reprezentowana typ nie jest typem ogólnym.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytników XAML lub moduły zapisujące XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy na podstawie przestrzeni nazw XAML i nazwy ciągu dla tego typu. Ten konstruktor jest przeznaczona wyłącznie do celów analizy i węzłów XAML rejestrowanie użycia typu, w których wiadomo, że nie ma zapasowy pomocnicze systemu typu i kontekst schematu XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyć tego konstruktora tylko dla typów "Nieznany", w którym typ XAML, który mapuje do zasadniczego systemu typu jest niedostępny. Ten konstruktor może nie dawać wyników gdzie <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> jest `true`. Zamiast tego domyślnej logiki odblaskowego raporty podstawowy typ jako <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Jednak to zachowanie można zmienić z powodu <xref:System.Xaml.XamlType.LookupIsUnknown%2A> zastąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jeden <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" />, lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typów które są możliwe do użycia jako tylko do odczytu <see cref="P:System.Xaml.XamlType.ContentProperty" /> wartość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Kolekcja tylko do odczytu możliwych typów zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy, które są można przypisać określonego typu zawartości (na przykład można przypisać do typu podstawowego, który jest dozwolony typ zawartości) nie są uważane za wiele typów na potrzeby <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> do natychmiastowego typ bazowy tego typu XAML. Określenie tej wartości jest oparty na podstawowym typem <see cref="T:System.Xaml.XamlType" /> i kontekst schematu.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Do natychmiastowego typ bazowy tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupBaseType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupBaseType%2A> dla tego typu. Domyślnie <xref:System.Xaml.XamlType.BaseType%2A> Zwraca wewnętrzny stałą, który reprezentuje <xref:System.Object> Jeśli <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić dane zgłoszonego typu o typie XAML, tak, aby go już wyrównane w oczekiwany sposób informacje o systemie typu bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny operacji przypisania i dostępu należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Typ do sprawdzania bieżącej <see cref="T:System.Xaml.XamlType" /> .</param>
        <summary>Zwraca wartość wskazującą, czy wystąpienie tego elementu <see cref="T:System.Xaml.XamlType" /> określonym <see cref="T:System.Xaml.XamlType" /> na liście typów można przypisać.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="xamlType" /> znajduje się na liście można przypisać typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że można przypisać typu nie ma możliwości typ odwołania, można użyć go do przypisania. Na przykład można użyć przypisania się dopasowań typu dla wartości właściwości. Pojęcia, które można przypisać typów w XAML jest podobny do koncepcji rzutowanie w górę w systemie typów CLR. Na przykład w obszarze system typu CLR, każdy typ ma <xref:System.Object> na liście można przypisać typu.  
  
 Jeśli jedna z dwóch <xref:System.Xaml.XamlType> wystąpień, które są używane w celu porównania ma <xref:System.Xaml.XamlType.IsUnknown%2A> równa `true`, ta metoda ma specjalne Nieznany tryb, która zwraca `true` Jeśli dwa <xref:System.Xaml.XamlType> wystąpienia są równoważne.  
  
 Domyślna implementacja używa środowiska CLR <xref:System.Type> z <xref:System.Xaml.XamlType.UnderlyingType%2A> tego <xref:System.Xaml.XamlType> i dane wejściowe <xref:System.Xaml.XamlType>i wywołuje <xref:System.Type.IsAssignableFrom%2A>. Należy przesłonić tę metodę, jeśli chcesz, aby określenie różnych typów można przypisać.  
  
 Przekazanie wartości null `xamlType` nie zgłasza wyjątku i zawsze zwraca `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić zbywalności typu XAML, tak, aby go już jest wyrównywany w oczekiwany sposób z zachowaniem rzutowania typu bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny operacji przypisania i dostępu należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> może mieć argumentów (ograniczenia ogólne za pośrednictwem <see langword="x:TypeArguments" />, tekst inicjowania lub innych technik XAML) do skonstruowania prawidłowe wystąpienie tego typu.</summary>
        <value><see langword="true" /> Jeśli tworzenia wystąpienia wymaga niektóre wartości argumentu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlMember" /> informacje dotyczące właściwość content <see cref="T:System.Xaml.XamlType" />.</summary>
        <value><see cref="T:System.Xaml.XamlMember" /> informacje dotyczące właściwość content <see cref="T:System.Xaml.XamlType" />. Może być <see langword="null" /> istnienia żadnej właściwości zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy za pomocą tego powiązania, albo tworzenie kopii systemu typu CLR, właściwość zawartości XAML można określić typu przez zastosowanie <xref:System.Windows.Markup.ContentPropertyAttribute> do definicji typu.  
  
 Ta właściwość jest wyrównywany do `[content property]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupContentProperty%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupContentProperty%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy, które są używane do opakowania zawartość właściwość zawartości, gdy nie jest dopasowanie typu strict, takich jak ciągi w silnie typizowany <see langword="Collection&lt;T&gt;" />.</summary>
        <value>Kolekcja tylko do odczytu typów możliwych otoki zawartości. w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych otoki dla dopasowanie typu zmniejszania, ta właściwość jest `null`.  
  
 Typy, które są interpretowane jako <xref:System.Xaml.XamlType.CanAssignTo%2A> dla określonego typu zawartości nie są uważane za wiele typów na potrzeby <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 Powiązanie CLR dla <xref:System.Xaml> i <xref:System.Xaml.XamlType>, typ otoki zawartości XAML, które można określić dla typu jako <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupContentWrappers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupContentWrappers%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> reprezentujący odroczonego ładowania zachowanie konwersji dla tego typu.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenie, które reprezentuje zachowanie odroczonego ładowania dla tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie szablonu XAML w WPF jest przykładem zachowanie odroczonego ładowania.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt.</summary>
        <returns><see langword="true" /> Jeśli bieżący obiekt jest równy <paramref name="obj" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam jak inny obiekt tego samego typu.</summary>
        <returns><see langword="true" /> Jeśli bieżący obiekt jest równy <paramref name="other" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Dyrektywa, dla której można znaleźć składowej aliasu.</param>
        <summary>Zwraca element członkowski XAML, która jest aliasem dyrektywy XAML, to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Alias elementu członkowskiego, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję, która zawiera wszystkie właściwości można dołączyć, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Kolekcja, która zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.Xaml.XamlMember> w zwrócona Kolekcja może zawierać wartości, które obsługują koncepcję, <xref:System.Xaml.XamlMember> jest elementem członkowskim można dołączyć. Na przykład, należy zwrócić elementy członkowskie `true` dla <xref:System.Xaml.XamlMember.IsAttachable%2A>, typ <xref:System.Xaml.XamlMember.TargetType%2A>i tak dalej.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję zawierającą wszystkie elementy członkowskie, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Kolekcja, która zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupAllMembers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwę można dołączyć elementu członkowskiego, aby uzyskać w <c>ownerTypeName.MemberName</c> formularza.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> reprezentującą określony o nazwie można dołączyć członkiem to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlMember" /> obiektu dla żądanego elementu członkowskiego można dołączyć; w przeciwnym razie <see langword="null" />, jeśli istnieje nie można dołączyć element członkowski o takiej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupAttachableMember%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić członków zgłoszonego typu XAML, tak, aby były wyrównane w oczekiwany sposób, korzystając z już <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny elementu członkowskiego raportowania należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Liczba całkowita wartość skrótu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego, aby uzyskać (jako ciąg).</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego nazwanego elementu członkowskiego z tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> Informacje dla elementu członkowskiego, jeśli taki członek został znaleziony; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `name` powinien być niekwalifikowane. Kwalifikowany typ nazwy na wskazujące członkowi dołączonych powinny zostać przesłane do <xref:System.Xaml.XamlType.GetAttachableMember%2A> zamiast tego. Prefiks elementu członkowskiego, który nie należy używać nazw; Prefiks, który jest sytuacyjnej do użycia i systemie typu XAML nie wiedzieć, kontekstu takiego użycia i jak prefiks jest zamapowana.  
  
 Wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupMember%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić członków zgłoszonego typu XAML, tak, aby były wyrównane w oczekiwany sposób, korzystając z już <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny elementu członkowskiego raportowania należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Liczba (argumentów) określonej składni lub Konstruktor tryb, w którym chcesz uzyskać informacje.</param>
        <summary>Typy rozszerzeń znaczników, zwraca typy parametry pozycyjne, które są obsługiwane przez użycie rozszerzenia znaczników w określonych dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości, gdzie każdy <see cref="T:System.Xaml.XamlType" /> jest typem dla tej pozycji w składni. Należy określić typy w tej samej kolejności, podczas dostarczania znaczników dane wejściowe na potrzeby rozszerzenia znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs API jest istotne, jeśli to tylko <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> jest `true`).  
  
 Dane wejściowe `parameterCount` nie jest do żądania typu określonego parametru pozycyjnych. Jest określenie liczby argumentów to użycia rozszerzenia znaczników. Użycie rozszerzenia znaczników często ma wiele "podpisów" i używa liczby argumentów (liczba) różnych parametrów pozycyjnych parametrów, aby odróżnić. Jednak należy skonfigurować do zezwalania na zduplikowane arities i użyć typów parametry pozycyjne różnicowania kontekst schematu. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Dla określonych argumentów (liczba) może się różnić pozycjach parametru i typów. Aby uzyskać pozycyjne typ użycia rozszerzenia znaczników dla określonej liczby argumentów, należy najpierw wywołać <xref:System.Xaml.XamlType.GetPositionalParameters%2A> określenia liczby argumentów. Następnie należy pobrać element na tej pozycji z zwrócona kolekcja.  
  
 Wywołania tej metody można wywołać <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę identyfikatorów ciągu dla tego typu znajduje się w przestrzeni nazw XAML.</summary>
        <returns>Lista wartości ciągu, gdzie każdego ciągu jest identyfikatorem URI przestrzeni nazw XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowe identyfikatory przestrzeni nazw XAML są ciągami w formie identyfikatora URI.  
  
 Domyślna implementacja sprawdza następujące polecenie, w kolejności: przestrzeń nazw XAML, która jest dostarczana w konstrukcji (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> tylko podpis); oraz przestrzenie nazw, które są dostępne w kontekście schematu. Jeśli są one każdego `null`, generowany jest nową listę, która zawiera jeden ciąg pusty. Można zastąpić tę metodę, aby zmienić metodę wyszukiwania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> wdrożenia, który jest skojarzony z tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Wdrożenia, który jest skojarzony z tym <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywoływania <xref:System.Xaml.XamlType.Invoker%2A> może wywołać albo <xref:System.Xaml.XamlType.LookupInvoker%2A> lub określone zastąpienia tej metody. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupInvoker%2A> dla tego typu.  
  
 Jeśli <xref:System.Xaml.XamlType.LookupInvoker%2A> zastąpienia zwraca `null`, lub Jeśli domyślna implementacja zwraca `null` z powodu braku <xref:System.Xaml.XamlType.UnderlyingType%2A> tego <xref:System.Xaml.XamlType>, następnie <xref:System.Xaml.XamlType.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ otoczenia, zgodnie z definicją XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ otoczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsAmbient%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsAmbient%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje tablicę.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje tablicę; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ konstrukcyjną, zgodnie z definicją XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ konstrukcyjną; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is default constructible]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsConstructible%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsConstructible%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik, zgodnie z definicją XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is dictionary]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ ogólny.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ ogólny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest właściwością pomocnika, która sprawdza, czy wartość null elementu <xref:System.Xaml.XamlType.TypeArguments%2A>. Nie ma żadnych określonych `Lookup` metoda związane z <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W warunkach specyfikacji XAML, ten typ musi być możliwy do przypisania do `x:MarkupExtension` celu zwrócenie `true` dla <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje namescope XAML, zgodnie z definicją XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje XAML namescope; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML namescope Wymusza unikatowość nazwy, właściwości lub właściwości używane dla `x:Name`  /  `[name property]`. Jeśli <xref:System.Xaml.XamlType.IsNameScope%2A> jest `true`, niektóre mechanizm wymuszania unikatowości powinna istnieć i należy ocenić pod względem tego typu, będącego właścicielem XAML namescope. XAML namescope następnie rozszerza z zawartością o typie, dopóki nie zostanie osiągnięty innego typu będącego właścicielem namescope XAML.  
  
 Ta właściwość jest wyrównywany do `[is name scope]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsNameScope%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> jest inicjowana przy użyciu prawidłowego <see langword="xamlName" /> ciąg jako jego <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> jest inicjowana przy użyciu prawidłowego <see langword="xamlName" /> ciągu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typu dopuszczającego wartość null, zgodnie z definicją XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is nullable]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsNullable%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny w systemie odpowiedniego typu.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsPublic%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić informacje zgłoszone dostępu o typie XAML, tak, aby go nie jest już zgodne w oczekiwany sposób z systemu i dostęp do informacji o typie bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny operacji przypisania i dostępu należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który nie jest rozpoznawany w systemie podstawowym typem.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ nierozpoznawalne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsUnknown%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlType> zawierający `true` dla <xref:System.Xaml.XamlType.IsUnknown%2A> nie mogą być zapisywane do wykresu obiektu. W domyślnej implementacji w <xref:System.Xaml> , <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlType> raporty `true` dla <xref:System.Xaml.XamlType.IsUnknown%2A>. Nie mają być przekazywane <xref:System.Xaml.XamlType> zawierający <xref:System.Xaml.XamlType.IsUnknown%2A> jako `true` o ile nie jest przygotowana do obsługi wyjątków z <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie lub strumień węzłów XAML przed zapisywania obiektu wykres.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> powstała góra dół podczas inicjowania XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> powstała góra dół podczas inicjowania XAML; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Góra dół to metaforyczna nazwa przybliżony XAML procesora zachowanie podczas tworzenia wykresu obiektu. Podczas kompilowania z góry na dół, typem jest tworzone wystąpienie dołączony do obiektu nadrzędnego, i następnie ustawił jego właściwości. Konstrukcja góra dół unika wywoływania obsługi zmiany właściwości wiele razy. Obsługa takich fale na górę wykresu obiektu i w związku z tym, eliminuje wiele wywołań obsługi oraz udostępnia zoptymalizować wydajność uruchamiania wykresu obiektu.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące odstępu, zgodnie z definicji XML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące białe znaki; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje XML <see langword="XDATA" />, jak to ma miejsce w każdej definicji XAML.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje <see langword="XDATA" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is xdata]` informacje o elemencie specification [MS-XAML].  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsXData%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsXData%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która zawiera informacje o typie dla <see langword="Items" /> właściwość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu elementów w kolekcji; w przeciwnym razie <see langword="null" />, jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje kolekcję.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest tylko istotne, jeśli ta <xref:System.Xaml.XamlType> reprezentuje kolekcję (<xref:System.Xaml.XamlType.IsCollection%2A> jest `true`). `Items` Właściwość jest dowolną właściwość przechowuje elementy w tym typie kolekcji lub tablicy.  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupItemType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupItemType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która zawiera informacje o typie dla właściwości key to <see cref="T:System.Xaml.XamlType" />, jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu klucza do użycia słownika, w przeciwnym razie <see langword="null" />, jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje słownik.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest tylko istotne, jeśli ta <xref:System.Xaml.XamlType> reprezentuje słownik (<xref:System.Xaml.XamlType.IsDictionary%2A> jest `true`).  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupKeyType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupKeyType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Dyrektywa, dla której można znaleźć składowej aliasu.</param>
        <summary>Zwraca element członkowski XAML, która jest aliasem dyrektywy XAML, to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Alias elementu członkowskiego, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 Domyślna implementacja może zwrócić wyniki dla następujących dyrektywach XAML: `Key`; `Name`; `Uid`; i `xml:lang`. Wartości te są zależne od podstawowego odbicia i nadal może zwrócić `null` Jeśli zostanie znaleziony żadnej właściwości aliasem.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zestaw, który zawiera wszystkie właściwości można dołączyć, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Wyliczalny zestaw, który zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Mimo że <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> zwraca kolekcję ogólną to `Lookup` metoda zwraca ogólny wyliczalny zestaw.  
  
 Domyślna implementacja używa wewnętrznego odbicia środowiska CLR. Gdy <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest ona dostępna. To zachowanie wywołuje <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> rekursywnie próbuje znaleźć prawidłowym typem podstawowym i zwraca `null` istnienia nie prawidłowym typem podstawowym.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu. Zwrócenia wartości null ma być zarezerwowana dla przypadków, w którym informacji nie można określić ze względu na brak obsługi typu systemu lub odbicia. Jeśli typ jest prawidłowy i odbicia lub innych technik są dostępne, ale typ nie ma członków można dołączyć, zamiast tego powinien zwrócić pustą <xref:System.Collections.Generic.IEnumerable%601> zestawu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestaw zawierający wszystkie elementy członkowskie, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Wyliczalny zestaw, który zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Mimo że <xref:System.Xaml.XamlType.GetAllMembers%2A> zwraca kolekcję ogólną to `Lookup` metoda zwraca ogólny wyliczalny zestaw.  
  
 Domyślna implementacja używa wewnętrznego odbicia środowiska CLR. W przypadkach, gdzie <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest ona dostępna. To zachowanie wywołuje <xref:System.Xaml.XamlType.LookupAllMembers%2A> rekursywnie próbuje znaleźć prawidłowym typem podstawowym i zwraca `null` istnienia nie prawidłowym typem podstawowym.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu. Zwrócenia wartości null ma być zarezerwowana dla przypadków, w którym informacji nie można określić ze względu na brak obsługi typu systemu lub odbicia. Jeśli typ jest prawidłowy, są dostępne; odbicia lub innych technik Jeśli typ nie ma elementów członkowskich, zamiast tego powinien zwrócić pustą <xref:System.Collections.Generic.IEnumerable%601> zestawu.  
  
 Wartości zwracane dla <xref:System.Xaml.XamlType.LookupAllMembers%2A> i <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> powinny być wzajemnie się wykluczają. W przypadku sytuacji, w którym właściwość zapasowy typ systemu może obsługiwać użycia wystąpienia standardowe, jak również użycie można dołączyć ten element członkowski powinny być raportowane jako dwa różne <xref:System.Xaml.XamlMember> wartości z jednej wartości, które pojawiają się na liście można dołączyć i drugiego w lista standardowych elementów członkowskich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę typów które są możliwe do użycia jako <see cref="P:System.Xaml.XamlType.ContentProperty" /> wartość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista możliwych typów zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Typy, które są interpretowane jako <xref:System.Xaml.XamlType.CanAssignTo%2A> dla określonego typu zawartości nie są uważane za wiele typów na potrzeby <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Domyślna implementacja może używać innych właściwości <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, lub <xref:System.Xaml.XamlType.ItemType%2A>) do uzyskania wyniku. `Lookup` Zastępuje dla powyższej liście właściwości można również wywołać w tym określenie.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwę można dołączyć elementu członkowskiego, aby uzyskać w <c>ownerTypeName.MemberName</c> formularza.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego o nazwie można dołączyć z tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlMember" /> obiektu dla żądanego elementu członkowskiego można dołączyć; w przeciwnym razie <see langword="null" />, jeśli istnieje nie można dołączyć element członkowski o takiej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 Domyślna implementacja używa wewnętrznego odbicia środowiska CLR. Gdy <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest ona dostępna. To zachowanie wywołuje <xref:System.Xaml.XamlType.LookupAttachableMember%2A> rekursywnie próbuje znaleźć prawidłowym typem podstawowym i zwraca `null` istnienia nie prawidłowym typem podstawowym.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić członków zgłoszonego typu XAML, tak, aby były wyrównane w oczekiwany sposób, korzystając z już <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny elementu członkowskiego raportowania należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> do natychmiastowego typ bazowy tego typu XAML. Określenie tej wartości jest oparty na podstawowym typem <see cref="T:System.Xaml.XamlType" /> i kontekst schematu.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> Do natychmiastowego typ bazowy tego typu XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 Domyślna implementacja może zwrócić wewnętrznego stałą, który reprezentuje <xref:System.Object> Jeśli <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić dane zgłoszonego typu o typie XAML, tak, aby go już wyrównane w oczekiwany sposób informacje o systemie typu bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny operacji przypisania i dostępu należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> typu wyliczenia, która deklaruje które określonej kolekcji, to <see cref="T:System.Xaml.XamlType" /> używa.</summary>
        <returns>Wartość <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metody wewnętrznej prywatny (bez publicznego `CollectionKind` lub `GetCollectionKind` interfejsu API znajduje się na <xref:System.Xaml.XamlType>).  
  
 Domyślna implementacja używa wewnętrznego odbicia środowiska CLR. W przypadkach, gdzie <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest ona dostępna. To zachowanie pośrednio wywołuje <xref:System.Xaml.XamlType.LookupCollectionKind%2A> rekursywnie próbuje znaleźć prawidłowym typem podstawowym; zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> istnienia nie prawidłowym typem podstawowym. Ogólnie rzecz biorąc, próbuje odnaleźć domyślną implementację `Add` metody typu podstawowego przez odbicie. Jeśli znaleziono <xref:System.Reflection.MethodInfo> z `Add` metodą jest wystarczająco dużo informacji, aby określić, które <xref:System.Xaml.Schema.XamlCollectionKind> powinna zostać zwrócona wartość. W przeciwnym razie zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> może mieć argumentów (ograniczenia ogólne za pośrednictwem <see langword="x:TypeArguments" />, tekst inicjowania lub innych technik XAML) do skonstruowania prawidłowe wystąpienie tego typu.</summary>
        <returns><see langword="true" /> Jeśli tworzenia wystąpienia wymaga niektóre wartości argumentu; w przeciwnym razie wartość false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 Domyślna implementacja zwraca `false` system typów dla typów uznawane za typy wartości w CLR. Dla innych niż typy wartości, CLR odbicia <xref:System.Reflection.ConstructorInfo> służy do określania, czy istnieje konstruktor domyślny.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> informacje dotyczące właściwość content <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> informacje dotyczące właściwość content <see cref="T:System.Xaml.XamlType" />. Może być <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 Sprawdza, czy domyślna implementacja <xref:System.Windows.Markup.ContentPropertyAttribute> w definicji typu. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli te testy nie wykryć typu zawartości, domyślna implementacja zwraca `null`.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrznego środowiska CLR i używają metadanych lub innych technik do raportowania, informacje o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę <see cref="T:System.Xaml.XamlType" /> wartości, które reprezentują zawartości otoki dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości, które reprezentują zawartości otoki dla tego <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Otoka zawartości jest klasa, która reprezentuje typ kolekcji zawartości, gdy typy, które są używane w tej kolekcji nie są ciągłe do systemu typów. Typy kolekcji elementów dla zawartości otoki powinny zostać ograniczone w jakikolwiek sposób poza <xref:System.Object> lub obiekt neutralne równoważne. Jednak to ograniczenie jest wymuszana tylko przez projekt lub celem właściwości, które używają tego typu, a nie przez system typów. Więcej niż jeden otoki zawartość może znajdować się w danym typie.  
  
 Przykład klasy i scenariusz od implementacji WPF XAML, zobacz <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej zwraca <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementacji.</summary>
        <returns><see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępuje tę metodę zapewnienie wewnętrznego odbicia alternatywny sposób uzyskiwania wartości atrybutu CLR. W przypadku braku zastąpienia wewnętrzne odblaskowego używa typowe logiki odbicia środowiska CLR.  
  
 Domyślna implementacja zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który jest używany dla odroczone ładowanie obiektów zadeklarowana XAML.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> zawierający <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenia na ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywołana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.DeferringLoader%2A>. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.DeferringLoader%2A> do zwrotu innej wartości niż został włączony przez odbicie wewnętrzny domyślny, a także udostępniają niestandardowe <xref:System.Xaml.Schema.XamlTypeInvoker> informacji.  
  
 Domyślna implementacja zwraca obiekt na podstawie odczytu <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, Metoda ta zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> skojarzony z tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Informacje na temat tego <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 Domyślna implementacja nie wymaga <xref:System.Xaml.XamlType> można skonstruować przy użyciu jednego z konstruktorów, zaliczonych początkową <xref:System.Xaml.Schema.XamlTypeInvoker>. Jednak <xref:System.Xaml.XamlType.UnderlyingType%2A> wartości, musi istnieć przez <xref:System.Xaml.XamlType>; w przeciwnym razie zwraca wartość domyślną implementację `null`.  
  
 Należy przesłonić tę metodę po utworzeniu klasy pochodnej od <xref:System.Xaml.Schema.XamlTypeInvoker> i zamierzony zwracany typ klasy pochodnej. Po powrocie `null`, <xref:System.Xaml.XamlType.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> dotyczące obiektów wywołujących.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ otoczenia, zgodnie z definicją XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ otoczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 Domyślna implementacja używa odbicia środowiska CLR na <xref:System.Xaml.XamlType.UnderlyingType%2A> i sprawdź, czy typy podstawowe. Sprawdza, czy ta implementacja <xref:System.Windows.Markup.AmbientAttribute> , jest stosowany do definicji odpowiedniego typu na poziomie klasy i zwraca `true` w tym przypadku. Zwróć wszystkich innych przypadkach `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsAmbient%2A> do zwrotu innej wartości niż został włączony przez odbicie wewnętrzny domyślny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ konstrukcyjną, zgodnie z definicją XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ konstrukcyjną; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 Domyślna implementacja używa odbicia środowiska CLR na <xref:System.Xaml.XamlType.UnderlyingType%2A>. Typ musi być konkretnych-nested i zamknięte. Domyślna implementacja sprawdza, czy typ jest typem wartości i zyski z <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, Metoda ta zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsConstructible%2A> do zwrotu innej wartości niż został włączony przez odbicie wewnętrzny domyślny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Domyślna implementacja składa się tylko z tego wywołania:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsMarkupExtension%2A> używać różnych logiki.  
  
 W warunkach specyfikacji XAML, ten typ musi być możliwy do przypisania do `x:MarkupExtension` celu zwrócenie `true` dla <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje namescope XAML, zgodnie z definicją XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje XAML namescope; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 Domyślna implementacja sprawia, że <xref:System.Xaml.XamlType.CanAssignTo%2A> pośrednio wywołania względem typu <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> to interfejs, który jest zdefiniowany w zestawie WindowsBase.dll. Tej techniki w celu identyfikacji namescope XAML jest używany zarówno przez implementacje WPF i Windows Workflow Foundation XAML.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsNameScope%2A> używać różnych logiki.  
  
 XAML namescope Wymusza unikatowość nazwy, właściwości lub właściwości, które są używane na potrzeby `x:Name`  /  `[name property]`. Jeśli <xref:System.Xaml.XamlType.IsNameScope%2A> jest `true`, a niektóre mechanizm wymuszania unikatowości powinna istnieć należy ocenić pod względem tego typu, będącego właścicielem XAML namescope. XAML namescope następnie rozszerza z zawartością o typie, dopóki nie zostanie osiągnięty innego typu będącego namescope XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typu dopuszczającego wartość null, zgodnie z definicją XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 Domyślna implementacja sprawdza oparte na CLR biblioteki nullable ideą, sprawdza, czy <xref:System.Xaml.XamlType.UnderlyingType%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, funkcja zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsNullable%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny w systemie odpowiedniego typu.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 Domyślna implementacja używa odbicia CLR względem innych niż null <xref:System.Xaml.XamlType.UnderlyingType%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, funkcja zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsPublic%2A> używać różnych logiki.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić informacje zgłoszone dostępu o typie XAML, tak, aby go już jest wyrównywany w oczekiwany sposób system lub dostęp do informacji o typach bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny operacji przypisania i dostępu należy użyć bazowego typu CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który nie jest rozpoznawany w systemie podstawowym typem.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ nonresolvable; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 Domyślna implementacja może używać odbicia środowiska CLR. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, funkcja zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsUnknown%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące odstępu, zgodnie z definicji XML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące odstępu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje XML <see langword="XDATA" />, jak to ma miejsce w każdej definicji XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje <see langword="XDATA" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 Domyślna implementacja sprawia, że <xref:System.Xaml.XamlType.CanAssignTo%2A> pośrednio wywołania względem typu <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsXData%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która zawiera informacje o typie dla <see langword="Items" /> właściwość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu elementów w kolekcji; w przeciwnym razie <see langword="null" /> Jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 Domyślna implementacja można użyć koncepcji odbicia, CLR, takich jak sprawdzanie `Add` metody przez <xref:System.Reflection.MethodInfo> i przy użyciu <xref:System.Reflection.ParameterInfo>; sprawdzania <xref:System.Xaml.XamlType.IsArray%2A>; i sprawdzanie <xref:System.Xaml.XamlType.BaseType%2A> i podjęcie próby wykonania tej samej logiki.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.ItemType%2A> używać różnych logiki. Przypadków, gdy <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> powinna zwrócić `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która zawiera informacje o typie dla właściwości key to <see cref="T:System.Xaml.XamlType" />, jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu klucza do użycia słownika lub <see langword="null" /> Jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje słownik</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 Domyślna implementacja można użyć koncepcji odbicia, CLR, takich jak sprawdzanie `Add` metody przez <xref:System.Reflection.MethodInfo> i przy użyciu <xref:System.Reflection.ParameterInfo>; i sprawdzanie <xref:System.Xaml.XamlType.BaseType%2A> i podjęcie próby wykonania tej samej logiki.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.KeyType%2A> używać różnych logiki. Przypadków, gdy <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nie zwraca <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> powinna zwrócić `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która dostarcza informacji o zwracanym typie <see langword="ProvideValue" /> to <see cref="T:System.Xaml.XamlType" />, jeśli termin reprezentuje rozszerzenie znaczników.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla zwracanego typu dla użycia rozszerzenia znaczników; w przeciwnym razie <see langword="null" />, jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje rozszerzenie znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType> na podstawie odczytu <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego, aby uzyskać (jako ciąg).</param>
        <param name="skipReadOnlyCheck"><see langword="true" /> Aby zwrócić składowej, nawet jeśli ten element członkowski ma <see langword="true" /> wartość <see cref="P:System.Xaml.XamlMember.IsReadOnly" />; <see langword="false" /> nie zwracać <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> elementu członkowskiego. Wartość domyślna to <see langword="false" />.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego nazwanego elementu członkowskiego z tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> Informacje dla elementu członkowskiego, jeśli element członkowski został znaleziony; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType> na podstawie wewnętrznych odbicia środowiska CLR i oceny względem kontekst schematu.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.GetMember%2A> używać różnych logiki.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> jest wirtualny i dlatego może zostać zastąpiona. Zastąpienie może potencjalnie (czy do złośliwych celów i w inny sposób) Aby zmienić członków zgłoszonego typu XAML, tak, aby były wyrównane w oczekiwany sposób, korzystając z już <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat bazowego typu CLR. Dla kontroli zabezpieczenia krytyczny elementu członkowskiego raportowania należy używać podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Liczba (argumentów) określonej składni lub Konstruktor tryb, w którym chcesz uzyskać informacje.</param>
        <summary>Typy rozszerzeń znaczników, zwraca typy parametry pozycyjne, które są obsługiwane przez użycie rozszerzenia znaczników w określonych dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości, w których każdy przykład <see cref="T:System.Xaml.XamlType" /> jest typem dla tej pozycji w składni. Należy określić te typy w tej samej kolejności, w przypadku określenia znaczników dane wejściowe na potrzeby rozszerzenia znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 Domyślna implementacja używa informacji wewnętrznych odbicia, na podstawie wyszukiwania konstruktorów i sprawdzanie liczby argumentów. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.GetPositionalParameters%2A> używać różnych logiki.  
  
 Ten interfejs API jest istotne, jeśli to tylko <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> jest `true`).  
  
 Dane wejściowe `parameterCount` nie jest do żądania typu określonego parametru pozycyjnych. Jest określenie liczby argumentów to użycia rozszerzenia znaczników. Użycie rozszerzenia znaczników często posiada wiele sygnatur i używa liczby argumentów (liczba) różnych parametrów pozycyjnych parametrów, aby odróżnić. Jednak należy skonfigurować do zezwalania na zduplikowane arities i użyć typów parametry pozycyjne różnicowania kontekst schematu. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Liczba określonych argumentów może się różnić pozycjach parametru i typów. Aby uzyskać pozycyjne typ użycia rozszerzenia znaczników dla określonej liczby argumentów, należy najpierw wywołać <xref:System.Xaml.XamlType.GetPositionalParameters%2A> z liczbą argumentów. Następnie należy pobrać element na tej pozycji z zwrócona kolekcja.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca program obsługi wywołania zwrotnego na potrzeby operacje na zestawie rozszerzenia znaczników.</summary>
        <returns>Wywołanie zwrotne obsługi na potrzeby operacje na zestawie rozszerzenia znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca program obsługi do użycia dla konwertera typów ustawienie przypadków.</summary>
        <returns>Program obsługi do użycia dla konwertera typów ustawienie przypadków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> powinien zostać Zserializowany trybie przycina odstępu otaczającego.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> powinny być serializowane w trybie który przycina odstępu otaczającego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> zawierający <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie reprezentuje zachowanie konwersji typu wartości to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie, które reprezentuje zachowanie konwersji typu wartości to <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.ComponentModel.TypeConverterAttribute>. Domyślna implementacja można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Zawiera on również logikę specjalną konwersję domyślne wyliczenia, Popularne typy wartości i typami ogólnymi. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.TypeConverter%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca CLR <see cref="T:System.Type" /> , to źródłową <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Środowisko CLR <see cref="T:System.Type" /> , to źródłową <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 Domyślna implementacja zwraca pola wewnętrznego. To pole jest ogólnie jest inicjowany podczas konstruowania i jego wartość na podstawie konstruktora została wywołana i podane informacje.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.UnderlyingType%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> powstała góra dół podczas inicjowania XAML.</summary>
        <returns><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> powstała góra dół podczas inicjowania XAML; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Góra dół to metaforyczna nazwa przybliżony XAML procesora zachowanie podczas tworzenia wykresu obiektu. Podczas kompilowania z góry na dół, typem jest tworzone wystąpienie dołączony do obiektu nadrzędnego, i ustawi jego właściwości. Konstrukcja góra dół unika wywoływania obsługi zmiany właściwości wiele razy. Obsługa takich fale na górę wykresu obiektu i w związku z tym, eliminuje wiele wywołań obsługi oraz udostępnia zoptymalizować wydajność uruchamiania wykresu obiektu.  
  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> zawierający <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenia, która reprezentuje wartość zachowanie serializacji dla wartości tej <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości tego <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczytywanie <xref:System.Windows.Markup.ValueSerializerAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli atrybut nie zostanie znalezione na natychmiastowe typ podstawowy. Zawiera on również logikę specjalną serializacji domyślny wyliczenia, Popularne typy wartości i typów ogólnych. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.ValueSerializer%2A> używać różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która dostarcza informacji o zwracanym typie <see langword="ProvideValue" /> to <see cref="T:System.Xaml.XamlType" />, jeśli termin reprezentuje rozszerzenie znaczników.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla zwracanego typu dla użycia rozszerzenia znaczników; w przeciwnym razie <see langword="null" />, jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje rozszerzenie znaczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest tylko istotne, jeśli ta <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (`x:MarkupExtension` znajduje się na liście typów można przypisać).  
  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę ciągu typu, który to <see cref="T:System.Xaml.XamlType" /> reprezentuje.</summary>
        <value>Nazwa ciągu tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj pobiera nazwę skonstruowany schematu (na <xref:System.Xaml.XamlType.%23ctor%2A> podpis), lub nazwę <xref:System.Type>, jeśli jest tworzona przy użyciu odpowiednich konstruktora system typów CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <param name="xamlType2">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlType" /> obiekty mają taką samą wartość.</summary>
        <returns><see langword="true" /> Jeśli wartość <paramref name="xamlType1" /> jest taka sama jak wartość <paramref name="xamlType2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <param name="xamlType2">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlType" /> obiekty mają różne wartości.</summary>
        <returns><see langword="true" /> Jeśli wartość <paramref name="xamlType1" /> różni się od wartości <paramref name="xamlType2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pojedynczy przestrzeni nazw XAML, który jest podstawowa przestrzeń nazw XAML, w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Identyfikator jako ciąg głównej przestrzeni nazw XAML dla tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja udostępnia taką samą wartość jak wywołanie <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> i następnie pobieranie pierwszy ciąg wartości ze zwracanego wyliczalny zestaw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktywny <see cref="T:System.Xaml.XamlSchemaContext" /> przetwarzania to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Aktywny <see cref="T:System.Xaml.XamlSchemaContext" /> przetwarzania to <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> jest wpis określający wymaganego parametru podczas tworzenia <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Reprezentacja ciągu tego <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlType> Implementacji <xref:System.Object.ToString%2A> zwraca <xref:System.Xaml.XamlType.Name%2A> właściwość <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> zawiera białe znaki, obsługa zachowania serializacji, który usuwa otaczającego odstęp w jego zawartości.</summary>
        <value><see langword="true" /> Jeśli ten <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który używa odstępów przycinania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę argumentów typu w przypadkach, gdzie to <see cref="T:System.Xaml.XamlType" /> reprezentuje ogólnego.</summary>
        <value>Lista typów argumentów typu; w przeciwnym razie <see langword="null" />, jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją pewne scenariusze <xref:System.Xaml.XamlType> w przypadku, gdy wywołanie <xref:System.Xaml.XamlType.TypeArguments%2A> parametr zwraca listę, gdy typy są nadal otwarte. W tym przypadku, co najmniej zwracanego <xref:System.Xaml.XamlType> wartości mają wartości symboli zastępczych <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, takich jak `T`, do reprezentowania, że ogólnego jest wciąż otwarty. Ten scenariusz może wystąpić, jeśli <xref:System.Xaml.XamlType> po wywołaniu <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, a nie od implementacji czytnika XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie, aby reprezentuje typ zachowanie konwersji wartości to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie, aby reprezentuje typ zachowanie konwersji wartości to <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupTypeConverter%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupTypeConverter%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera środowisko CLR <see cref="T:System.Type" /> , to źródłową <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Środowisko CLR <see cref="T:System.Type" /> , to źródłową <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości tej <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości tego <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślnego wewnętrznego CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości można wywołać <xref:System.Xaml.XamlType.LookupValueSerializer%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat wartości zwracane i innych zachowań, zobacz dokumentację dla <xref:System.Xaml.XamlType.LookupValueSerializer%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
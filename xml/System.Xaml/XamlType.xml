<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="020ca716a40d40ea944a7fea51f12d5251b33596" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36444013" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Raportuje informacje o typach języka XAML w ramach całego systemu XAML wdrożonej usługi XAML .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele interfejsów API w <xref:System.Xaml.XamlType> klasy zawierają informacje o typach języka XAML, gdzie koncepcji zgłaszają na jest podobny do poszczególnych sekcji XAML specification [MS-XAML].  
  
 <xref:System.Xaml.XamlType> jest bardzo często używane w interfejsu API programu .NET Framework XAML usług raportowania informacji o typie XAML. <xref:System.Xaml.XamlType> Raporty informacje, które trzeba wiedzieć o typu XAML, aby pracować z wystąpieniem lub uzyskać dostępu do jego elementów członkowskich z strumień węzłów XAML lub podobne reprezentacja XAML. Jego raportowania jest podobny do sposobu <xref:System.Type> w środowisku CLR system typów, wraz z odbiciem klas takich jak <xref:System.Reflection.MemberInfo>, zawierają informacje dotyczące typu CLR i jego obciążenie.  
  
 Aby rozszerzyć system typów języka XAML, może pochodzić od <xref:System.Xaml.XamlType>. Aby zrobić to skutecznie, może również należy wdrożyć <xref:System.Xaml.Schema.XamlTypeInvoker>. <xref:System.Xaml.Schema.XamlTypeInvoker> Umożliwia uogólniony system typów języka XAML do pracy w systemie typów kopii określisz jako część zachowanie wywołania. Niestandardowe określonych <xref:System.Xaml.Schema.XamlTypeInvoker> umożliwia zmniejszenie zależności w systemie typ CLR, które są używane przez domyślny <xref:System.Xaml.XamlType> zachowanie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Podstawowy CLR <see cref="T:System.Type" /> dla typu XAML do utworzenia.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytników XAML lub zapisywania pliku XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy oparte na podstawowych informacji o typie CLR.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jednego <paramref name="underlyingType" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu do utworzenia.</param>
        <param name="typeArguments">Argumentów typu dla <see cref="T:System.Xaml.XamlType" /> reprezentujący typu ogólnego. Może być (i często jest) <see langword="null" />, co oznacza, że reprezentowanego typ nie jest typem ogólnym.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytników XAML i autorzy XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy na podstawie ciągu nazwy typu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to Konstruktor chroniony. Nie bieżącego publicznych klas pochodnych istnieje używające tej ścieżki określonej dla konstrukcji. Klientów istniejącej <xref:System.Xaml.XamlType>, należy użyć innych sygnatury konstruktora (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, lub <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) zainicjować <xref:System.Xaml.XamlType> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jednego <paramref name="typeName" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Typ podstawowy dla typu XAML do utworzenia.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytnika XAML.</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Implementację, która obsługuje w czasie wykonywania odbicia wywołuje przed <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy oparte na podstawowych informacji o typie i <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> implementacji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jednego <paramref name="underlyingType" /> lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Przestrzeń nazw XAML dla typu, jako łańcuch znaków.</param>
        <param name="unknownTypeName">Nazwa typu w określonych <c>unknownTypeNamespace</c> przestrzeni nazw XAML.</param>
        <param name="typeArguments">Argumentów typu dla <see cref="T:System.Xaml.XamlType" /> reprezentujący typu ogólnego. Może być (i często jest) <see langword="null" />, co oznacza, że reprezentowanego typ nie jest typem ogólnym.</param>
        <param name="schemaContext">Kontekst schematu XAML dla czytników XAML lub zapisywania pliku XAML.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlType" /> klasy oparte na przestrzeni nazw XAML i nazwy ciągu dla typu. Ten konstruktor jest wyłącznie do analizy i węzłów XAML rejestrowanie użycia typu, które są znane nie zapasowy system obsługi typów i kontekst schematu XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego konstruktora tylko dla typów "Nieznany", gdzie typu XAML, który jest mapowany na podstawowym systemie typ jest niedostępny. Ten konstruktor może nie dawać wyników gdzie <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> jest `true`. Zamiast tego domyślna logika reflektora raporty podstawowy typ jako <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Jednak to zachowanie można zmienić z powodu <xref:System.Xaml.XamlType.LookupIsUnknown%2A> zastąpienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Co najmniej jednego <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" />, lub <paramref name="schemaContext" /> są <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję typów, które są możliwe do użycia jako tylko do odczytu <see cref="P:System.Xaml.XamlType.ContentProperty" /> wartość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Kolekcja tylko do odczytu możliwych typów zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy, które są można przypisać określonego typu zawartości (na przykład można przypisać do typu podstawowego, który jest dozwolonym typem zawartości) nie są uważane za wiele typów dla celów <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlType" /> do natychmiastowego typ bazowy tego typu XAML. Określenie tej wartości jest oparte na typ bazowy <see cref="T:System.Xaml.XamlType" /> i kontekst schematu.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> Do natychmiastowego typ bazowy tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupBaseType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupBaseType%2A> dla tego typu. Domyślnie <xref:System.Xaml.XamlType.BaseType%2A> Zwraca wewnętrzny stała, który reprezentuje <xref:System.Object> Jeśli <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić zgłoszone informacje o typie XAML, aby go już wyrównane w oczekiwany sposób informacje o systemie typ podstawowy typu CLR. Dla żadnych krytyczny dla zabezpieczeń kontroli dostępu i przypisania operacji w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Typ do sprawdzenia przed bieżącą <see cref="T:System.Xaml.XamlType" /> .</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie <see cref="T:System.Xaml.XamlType" /> z określonym <see cref="T:System.Xaml.XamlType" /> swoją listę typów możliwych do przypisania.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="xamlType" /> znajduje się na liście można przypisać typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że można przypisać typu nie ma wszystkich funkcji typu odwołania, służy ona do przypisania. Na przykład umożliwia przypisanie utworzyć zgodny typ wartości właściwości. Koncepcja typów możliwych do przypisania w języku XAML jest podobny do koncepcji rzutowanie w górę w systemie typów CLR. Na przykład w obszarze system typu CLR, co typ ma <xref:System.Object> na liście można przypisać typu.  
  
 Jeśli jedna z dwóch <xref:System.Xaml.XamlType> wystąpień, które są używane dla porównania ma <xref:System.Xaml.XamlType.IsUnknown%2A> równa `true`, ta metoda ma specjalne Nieznany tryb, który zwraca `true` Jeśli dwa <xref:System.Xaml.XamlType> wystąpienia są równoważne.  
  
 Domyślna implementacja używa CLR <xref:System.Type> z <xref:System.Xaml.XamlType.UnderlyingType%2A> tego <xref:System.Xaml.XamlType> i dane wejściowe <xref:System.Xaml.XamlType>i wywołania <xref:System.Type.IsAssignableFrom%2A>. Należy przesłonić tę metodę, jeśli chcesz, aby określenie różnych typów możliwych do przypisania.  
  
 Przekazywanie wartości null `xamlType` nie zgłasza wyjątek i zawsze zwraca `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić assignability typu XAML, aby go już wyrównuje w oczekiwany sposób z zachowaniem rzutowanie typów jego typem podstawowym CLR. Dla żadnych krytyczny dla zabezpieczeń kontroli dostępu i przypisania operacji w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> może mieć argumentów (ograniczenia ogólne za pośrednictwem <see langword="x:TypeArguments" />, tekst inicjowania lub innych technik XAML) do utworzenia prawidłowe wystąpienie typu.</summary>
        <value>
          <see langword="true" /> Jeśli konstrukcji wystąpienia wymaga niektórych wartości argumentu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.XamlMember" /> informacji dla właściwości content tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Xaml.XamlMember" /> informacje dla właściwości content tego <see cref="T:System.Xaml.XamlType" />. Może być <see langword="null" /> Jeśli istnieje ma właściwości zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy za pomocą tego powiązania lub tworzenie kopii systemu typu CLR, właściwości zawartości XAML można określić dla takiego typu, stosując <xref:System.Windows.Markup.ContentPropertyAttribute> do definicji typu.  
  
 Ta właściwość jest wyrównywany do `[content property]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupContentProperty%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupContentProperty%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy, które są stosowane do zakodowania zawartości dla właściwości content, gdy nie jest ona dopasowania ścisłe zasady, na przykład ciągi w silnie typizowaną <see langword="Collection&lt;T&gt;" />.</summary>
        <value>Kolekcja tylko do odczytu typów możliwych otoki zawartości. w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych otoki dla typu dopasowania zmniejszania, ta właściwość jest `null`.  
  
 Typy, które są interpretowane jako <xref:System.Xaml.XamlType.CanAssignTo%2A> dla określonego typu zawartości nie są uznawane za wiele typów dla celów <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 Powiązanie CLR dla <xref:System.Xaml> i <xref:System.Xaml.XamlType>, można określić typ otoki zawartości XAML w typie jako <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupContentWrappers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupContentWrappers%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> reprezentujący odroczonego ładowania zachowanie konwersji dla tego typu.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenia, która reprezentuje zachowanie ładowanie odłożone dla tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem ładowanie odłożone zachowanie jest zachowanie szablonu XAML w WPF.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący obiekt jest taki sam <paramref name="obj" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z tym obiektem.</param>
        <summary>Wskazuje, czy bieżący obiekt jest taki sam, jak inny obiekt tego samego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący obiekt jest taki sam <paramref name="other" /> parametru; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Dyrektywa, dla którego można znaleźć elementu członkowskiego aliasu.</param>
        <summary>Zwraca element członkowski XAML, który jest aliasem do dyrektywy XAML, to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Alias elementu członkowskiego, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję, która zawiera wszystkie możliwe do dołączenia właściwości, które są udostępniane przez to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Kolekcja, która zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.Xaml.XamlMember> zwracana Kolekcja powinna zawierać wartości, które obsługują pojęcie który <xref:System.Xaml.XamlMember> jest dołączalny element członkowski. Na przykład członkowie powinien zwrócić `true` dla <xref:System.Xaml.XamlMember.IsAttachable%2A>, typ <xref:System.Xaml.XamlMember.TargetType%2A>i tak dalej.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję, która zawiera wszystkie elementy członkowskie, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Kolekcja, która zawiera zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupAllMembers%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego możliwej do pobrania w <c>ownerTypeName.MemberName</c> formularza.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> reprezentującą określony o nazwie dołączalny element członkowski tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlMember" /> obiektu dla żądanego dołączalny element członkowski; w przeciwnym razie <see langword="null" />, jeśli istnieje nie dołączalny element członkowski o takiej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupAttachableMember%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić członków zgłoszonego typu XAML tak, aby już wyrównane, w oczekiwany sposób, z <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat podstawowy typ CLR. Dla kontroli krytyczny dla zabezpieczeń elementu członkowskiego raportowania należy używać podstawowy typ CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla tego obiektu.</summary>
        <returns>Liczba całkowita wartość skrótu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego do pobrania (jako ciąg).</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego o nazwie elementu członkowskiego to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> Informacji dla elementu członkowskiego, jeśli taki element członkowski został znaleziony, a w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość `name` powinien być niekwalifikowane. Przesłano kwalifikowanego typu nazwy na wskazujące elementu członkowskiego dołączonych <xref:System.Xaml.XamlType.GetAttachableMember%2A> zamiast tego. Prefiks element członkowski, który nie należy używać nazw; Prefiks jest oparty na analizie sytuacji do użytkowania i system typów języka XAML nie może znać kontekście takie użycia i odwzorowania prefiks.  
  
 Wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupMember%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić członków zgłoszonego typu XAML tak, aby już wyrównane, w oczekiwany sposób, z <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat podstawowy typ CLR. Dla kontroli krytyczny dla zabezpieczeń elementu członkowskiego raportowania należy używać podstawowy typ CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Liczba (argumentów) określonej składni lub konstruktora tryb, w którym chcesz uzyskać informacje.</param>
        <summary>W przypadku typów rozszerzenia znaczników zwraca typy parametrów pozycyjnych, które są obsługiwane przez użycie rozszerzenia znaczników określonego dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości, gdzie każdy <see cref="T:System.Xaml.XamlType" /> typ dla tej pozycji w składni. Jeśli podasz wprowadzania znaczników dla rozszerzenia znacznika, należy określić typy w tej samej kolejności.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs API jest ważne, jeśli to tylko <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> jest `true`).  
  
 Dane wejściowe `parameterCount` nie jest przeznaczony dla żądania typu określonych parametrów pozycyjnych. Jest określenie liczby argumentów użycie rozszerzenia znaczników. Użycie rozszerzenia znaczników często ma wiele "podpisów" i używa parametru innej liczby argumentów skonkretyzowanego (licznik) parametrów pozycyjnych do odróżnienia. Można jednak skonfigurować kontekst schematu zezwala na zduplikowane arities i typy parametrów pozycyjnych na użytek zróżnicowanie. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Dla określonych argumentów (licznik) może się różnić pozycji parametrów i typy. Można pobrać typu pozycyjnych użycia rozszerzenia znaczników określonej liczby argumentów, należy najpierw wywołać <xref:System.Xaml.XamlType.GetPositionalParameters%2A> określenie liczby argumentów. Następnie Pobierz elementu na tej pozycji z zwracana kolekcja.  
  
 Wywołania tej metody można wywoływać <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę identyfikatorów ciągu dla tego typu znajduje się w przestrzeni nazw XAML.</summary>
        <returns>Lista wartości ciągu, w których każdy ciąg jest identyfikator URI przestrzeni nazw XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowy identyfikatory przestrzeni nazw XAML są ciągami w formie identyfikatora URI.  
  
 Domyślna implementacja sprawdza następujące polecenie, w kolejności: przestrzeni nazw XAML, która jest dostarczana w konstrukcji (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> tylko podpis); i przestrzenie nazw, które są dostępne w kontekście schematu. Jeśli są one każdego `null`, Nowa lista jest generowana zawierający pojedynczy ciąg pusty. Można zastąpić tę metodę, aby zmienić metodę wyszukiwania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> implementację, która jest skojarzona z tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Implementację, która jest skojarzona z tym <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywoływania <xref:System.Xaml.XamlType.Invoker%2A> może wywołać albo <xref:System.Xaml.XamlType.LookupInvoker%2A> lub określonego zastąpienia tej metody. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupInvoker%2A> dla tego typu.  
  
 Jeśli <xref:System.Xaml.XamlType.LookupInvoker%2A> zastąpienia zwraca `null`, lub Jeśli domyślna implementacja zwraca `null` z powodu braku <xref:System.Xaml.XamlType.UnderlyingType%2A> tego <xref:System.Xaml.XamlType>, następnie <xref:System.Xaml.XamlType.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typem otoczenia, zgodnie z definicją XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typem otoczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsAmbient%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsAmbient%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje tablicę.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje tablicę; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ umożliwia konstrukcji, zgodnie z definicją XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje umożliwia konstrukcji typu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is default constructible]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsConstructible%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsConstructible%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik, zgodnie z definicją XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is dictionary]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupCollectionKind%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typu ogólnego.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ ogólny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest właściwością pomocnika, która sprawdza, czy wartości równej null <xref:System.Xaml.XamlType.TypeArguments%2A>. Nie istnieje żadne określonych `Lookup` metody związane z <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W warunkach specyfikacji języka XAML, ten typ musi być można przypisać do `x:MarkupExtension` celu powrotu `true` dla <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje namescope XAML, zgodnie z definicją XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje XAML namescope; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML namescope Wymusza unikatowość nazwy właściwości lub właściwości używanej do `x:Name`  /  `[name property]`. Jeśli <xref:System.Xaml.XamlType.IsNameScope%2A> jest `true`, mechanizmu wymuszania unikatowości powinna istnieć i należy ocenić, z punktu widzenia ten typ będący właścicielem XAML namescope. XAML namescope następnie rozszerza do typu zawartości, dopóki napotkano inny typ będący właścicielem namescope XAML.  
  
 Ta właściwość jest wyrównywany do `[is name scope]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsNameScope%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> została zainicjowana przy użyciu prawidłowej <see langword="xamlName" /> ciąg jako jego <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> została zainicjowana przy użyciu prawidłowej <see langword="xamlName" /> , ciąg; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null, zgodnie z definicją XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is nullable]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsNullable%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny w systemie odpowiedniego typu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsPublic%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić informacje zgłoszone dostępu typu XAML, tak aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu i dostęp do informacji o jego typem podstawowym CLR. Dla żadnych krytyczny dla zabezpieczeń kontroli dostępu i przypisania operacji w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który nie jest rozpoznawany w podstawowym systemie typu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje nierozpoznany typ; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsUnknown%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych.  
  
 Dla ścieżki obciążenia, która obejmuje <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlType> mający `true` dla <xref:System.Xaml.XamlType.IsUnknown%2A> nie można zapisać do obiektu wykresu. W domyślnej implementacji w <xref:System.Xaml> , <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> wywołać zgłasza <xref:System.Xaml.XamlObjectWriterException> podczas odpowiedniego <xref:System.Xaml.XamlType> raporty `true` dla <xref:System.Xaml.XamlType.IsUnknown%2A>. Nie należy przekazać <xref:System.Xaml.XamlType> mający <xref:System.Xaml.XamlType.IsUnknown%2A> jako `true` o ile nie jest przygotowana do obsługi wyjątków z <xref:System.Xaml.XamlObjectWriter>, lub w inny sposób, aby dopasować <xref:System.Xaml.XamlObjectWriter> zachowanie lub strumień węzłów XAML przed zapisywanie obiektu wykres.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> jest wbudowana góra dół podczas inicjowania XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> jest wbudowana góra dół podczas inicjowania XAML; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Góra dół jest metaphor, zbliżony zachowanie procesora XAML podczas tworzenia wykresu obiektu. Podczas tworzenia góry do dołu, typem wystąpienia dołączony do obiektu nadrzędnego, a następnie jego właściwości ma Ustaw. Góra dół konstrukcji pozwala uniknąć wywoływania obsługi zmienić właściwości wiele razy. Takie Obsługa fale się wykres obiektu i w związku z tym eliminuje wiele wywołań obsługi oraz zapewnia optymalizację wydajności podczas uruchamiania obiektu wykresu.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczących odstępu, zgodnie z harmonogramem definicji XML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące światła; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje XML <see langword="XDATA" />, jak na definicji XAML.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje <see langword="XDATA" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest wyrównywany do `[is xdata]` elementu informacji w specification [MS-XAML].  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsXData%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsXData%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która zawiera informacje o typie dla <see langword="Items" /> właściwości tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu elementów w kolekcji; w przeciwnym razie <see langword="null" />, jeśli to <see cref="T:System.Xaml.XamlType" /> nie reprezentuje kolekcję.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy tylko jeśli <xref:System.Xaml.XamlType> reprezentuje kolekcję (<xref:System.Xaml.XamlType.IsCollection%2A> jest `true`). `Items` Właściwość jest niezależnie od właściwość przechowuje elementy w kolekcji lub tablicy typu.  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupItemType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupItemType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która zawiera informacje o typie dla właściwości klucza tego <see cref="T:System.Xaml.XamlType" />, jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu klucza słownika użycia, w przeciwnym razie <see langword="null" />, jeśli to <see cref="T:System.Xaml.XamlType" /> nie reprezentuje słownik.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy tylko jeśli <xref:System.Xaml.XamlType> reprezentuje słownik (<xref:System.Xaml.XamlType.IsDictionary%2A> jest `true`).  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupKeyType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupKeyType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Dyrektywa, dla którego można znaleźć elementu członkowskiego aliasu.</param>
        <summary>Zwraca element członkowski XAML, który jest aliasem do dyrektywy XAML, to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Alias elementu członkowskiego, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 Domyślna implementacja może zwrócić wyniki dla następujących dyrektyw XAML: `Key`; `Name`; `Uid`; i `xml:lang`. Wartości te są zależne od podstawowej odbicia i nadal mogą zwracać `null` przypadku nieznalezienia żadnej właściwości aliasu.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestaw zawierający wszystkie możliwe do dołączenia właściwości, które są udostępniane przez to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Wyliczalny zestaw zawierający zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Mimo że <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> zwraca kolekcję ogólną to `Lookup` metoda zwraca ogólnego wyliczalny zestaw.  
  
 Domyślna implementacja używa wewnętrznego odbicia CLR. Gdy <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest dostępna. Wymaga to zachowanie <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> rekursywnie próbuje odnaleźć prawidłowym typem podstawowym i zwraca `null` Jeśli nie ma prawidłową typu podstawowego.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu. Zwracane wartości null ma być zarezerwowana dla przypadków, w których nie można ustalić informacji ze względu na brak obsługi typu systemu lub odbicia. Jeśli typ jest nieprawidłowy i odbicia lub innych technik są dostępne, ale typ nie ma możliwe do dołączenia elementy członkowskie, zamiast tego powinien zwrócić pustą <xref:System.Collections.Generic.IEnumerable%601> ustawiony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zestaw zawierający wszystkie elementy członkowskie, które są dostępne w tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Wyliczalny zestaw zawierający zero lub więcej <see cref="T:System.Xaml.XamlMember" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Mimo że <xref:System.Xaml.XamlType.GetAllMembers%2A> zwraca kolekcję ogólną to `Lookup` metoda zwraca ogólnego wyliczalny zestaw.  
  
 Domyślna implementacja używa wewnętrznego odbicia CLR. W przypadkach, gdzie <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest dostępna. Wymaga to zachowanie <xref:System.Xaml.XamlType.LookupAllMembers%2A> rekursywnie próbuje odnaleźć prawidłowym typem podstawowym i zwraca `null` Jeśli nie ma prawidłową typu podstawowego.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu. Zwracane wartości null ma być zarezerwowana dla przypadków, w których nie można ustalić informacji ze względu na brak obsługi typu systemu lub odbicia. Jeśli typ jest prawidłowy, odbicia lub innych technik są dostępne; Jeśli typ nie ma elementów członkowskich, zamiast tego powinien zwrócić pustą <xref:System.Collections.Generic.IEnumerable%601> ustawiony.  
  
 Zwracane wartości dla <xref:System.Xaml.XamlType.LookupAllMembers%2A> i <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> powinny być wykluczają się wzajemnie. Jeśli sytuacja, w której właściwością zapasowy typ systemu może obsługiwać użycie standardowego wystąpienia, a także możliwe do dołączenia do użycia, należy podać ten element członkowski jako dwa różne <xref:System.Xaml.XamlMember> wartości z jednej wartości znajdujących się na liście możliwej i inną w listę standardowych członków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę typów, które są możliwe do użycia jako <see cref="P:System.Xaml.XamlType.ContentProperty" /> wartość to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista możliwych typów zawartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Typy, które są interpretowane jako <xref:System.Xaml.XamlType.CanAssignTo%2A> dla określonego typu zawartości nie są uznawane za wiele typów dla celów <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Domyślna implementacja można użyć innych właściwości <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, lub <xref:System.Xaml.XamlType.ItemType%2A>) do uzyskania wyniku. `Lookup` Zastąpienia dla w to również można wywołać z powyższej listy właściwości.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego możliwej do pobrania w <c>ownerTypeName.MemberName</c> formularza.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego o nazwie możliwej tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlMember" /> obiektu dla żądanego dołączalny element członkowski; w przeciwnym razie <see langword="null" />, jeśli istnieje nie dołączalny element członkowski o takiej nazwie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 Domyślna implementacja używa wewnętrznego odbicia CLR. Gdy <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest dostępna. Wymaga to zachowanie <xref:System.Xaml.XamlType.LookupAttachableMember%2A> rekursywnie próbuje odnaleźć prawidłowym typem podstawowym i zwraca `null` Jeśli nie ma prawidłową typu podstawowego.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić członków zgłoszonego typu XAML tak, aby już wyrównane, w oczekiwany sposób, z <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat podstawowy typ CLR. Dla kontroli krytyczny dla zabezpieczeń elementu członkowskiego raportowania należy używać podstawowy typ CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> do natychmiastowego typ bazowy tego typu XAML. Określenie tej wartości jest oparte na typ bazowy <see cref="T:System.Xaml.XamlType" /> i kontekst schematu.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> Do natychmiastowego typ bazowy tego typu XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 Domyślna implementacja może zwrócić wewnętrzny stała, który reprezentuje <xref:System.Object> Jeśli <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić zgłoszone informacje o typie XAML, aby go już wyrównane w oczekiwany sposób informacje o systemie typ podstawowy typu CLR. Dla żadnych krytyczny dla zabezpieczeń kontroli dostępu i przypisania operacji w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> wyliczenia, który deklaruje które określonej kolekcji, wpisz to <see cref="T:System.Xaml.XamlType" /> używa.</summary>
        <returns>Wartość <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę prywatnej wewnętrzny (żadnego elementu publicznego public `CollectionKind` lub `GetCollectionKind` interfejsu API istnieje na <xref:System.Xaml.XamlType>).  
  
 Domyślna implementacja używa wewnętrznego odbicia CLR. W przypadkach, gdzie <xref:System.Xaml.XamlType.UnderlyingType%2A> jest `null`, można użyć w implementacji domyślnej <xref:System.Xaml.XamlType.BaseType%2A>, jeśli jest dostępna. To zachowanie pośrednio wywołuje <xref:System.Xaml.XamlType.LookupCollectionKind%2A> rekursywnie próbuje odnaleźć prawidłowym typem podstawowym; zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> Jeśli nie ma prawidłową typu podstawowego. Ogólnie rzecz biorąc, próbuje odnaleźć Domyślna implementacja `Add` metody typu podstawowego przez odbicie. Jeśli znaleziono <xref:System.Reflection.MethodInfo> z `Add` metoda jest zebranie informacji umożliwiających ustalenie, który <xref:System.Xaml.Schema.XamlCollectionKind> powinna zostać zwrócona wartość. W przeciwnym razie zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> może mieć argumentów (ograniczenia ogólne za pośrednictwem <see langword="x:TypeArguments" />, tekst inicjowania lub innych technik XAML) do utworzenia prawidłowe wystąpienie typu.</summary>
        <returns>
          <see langword="true" /> Jeśli konstrukcji wystąpienia wymaga niektórych wartości argumentu; w przeciwnym razie wartość false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 Domyślna implementacja zwraca `false` system typów dla typów traktowane jako typów wartości w środowisku CLR. Dla innych niż typy wartości, odbicia CLR <xref:System.Reflection.ConstructorInfo> służy do określania, czy istnieje konstruktora domyślnego.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> informacji dla właściwości content tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> informacje dla właściwości content tego <see cref="T:System.Xaml.XamlType" />. Może być <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 Sprawdza, czy domyślna implementacja <xref:System.Windows.Markup.ContentPropertyAttribute> w definicji typu. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli te testy nie odnajdzie typu zawartości, domyślna implementacja zwraca `null`.  
  
 Należy przesłonić tę metodę, jeśli nie jednostki uzależnionej na podstawie odbicia domyślne wewnętrzny CLR i używania metadanych lub innych technik raportowania informacji o systemie typu XAML lub informacji o schemacie typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę <see cref="T:System.Xaml.XamlType" /> wartości, które reprezentują zawartości otoki dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości, które reprezentują zawartości otoki dla tego <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Otoka zawartości jest klasa, która reprezentuje typu zawartości kolekcji, gdy typy, które są używane w tej kolekcji nie są ciągłe w systemie typów. Typy kolekcji elementów dla zawartości otoki powinny być ograniczone w jakikolwiek sposób poza <xref:System.Object> lub obiektu neutralne równoważne. Jednak to ograniczenie jest wymuszane tylko przez projekt lub cel właściwości, które używają tego typu, a nie przez system typów. Więcej niż jeden otoki zawartości może istnieć w danym typie.  
  
 Przykład klasy i scenariusz od wdrożenia programu WPF XAML, zobacz <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej zwraca <see cref="T:System.Reflection.ICustomAttributeProvider" /> implementacji.</summary>
        <returns>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> Implementacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przesłonić tę metodę, aby zapewnić wewnętrzny odbicia z alternatywny sposób uzyskiwania wartości atrybutów CLR. W przypadku braku zastąpienia wewnętrzny reflektora używa typowej logiki odbicia CLR.  
  
 Domyślna implementacja zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> obiektu, który jest używany dla ładowanie odłożone zadeklarowany XAML obiektów.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mający <see cref="T:System.Xaml.XamlDeferringLoader" /> ograniczenie ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana, gdy obiekt wywołujący pobiera wartość z zakresu od <xref:System.Xaml.XamlType.DeferringLoader%2A>. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.DeferringLoader%2A> zwraca wartość inną niż jest włączana przez odbicie wewnętrzny domyślne, a także podaje niestandardowych <xref:System.Xaml.Schema.XamlTypeInvoker> informacji.  
  
 Domyślna implementacja zwraca obiekt na podstawie odczytu <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępna, ta metoda zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> skojarzonego z tym <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Informacje na temat tego <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 Domyślna implementacja nie wymaga, aby <xref:System.Xaml.XamlType> można skonstruować za pomocą jednego z konstruktorów, które przekazują początkowej <xref:System.Xaml.Schema.XamlTypeInvoker>. Jednak <xref:System.Xaml.XamlType.UnderlyingType%2A> wartości musi istnieć dla <xref:System.Xaml.XamlType>; w przeciwnym razie wartość domyślna implementacja zwraca `null`.  
  
 Przesłonić tę metodę, jeśli tworzysz klasy pochodnej z <xref:System.Xaml.Schema.XamlTypeInvoker> i zamierzony zwracany typ klasy pochodnej. Jeśli `null`, <xref:System.Xaml.XamlType.Invoker%2A> zwraca <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> dotyczące obiektów wywołujących.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typem otoczenia, zgodnie z definicją XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typem otoczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 Domyślna implementacja używa odbicia CLR na <xref:System.Xaml.XamlType.UnderlyingType%2A> i sprawdź, czy typy podstawowe. Sprawdza, czy ta implementacja <xref:System.Windows.Markup.AmbientAttribute> jest stosowany do definicji odpowiedniego typu na poziomie klasy i zwraca `true` w takim przypadku. Zwraca wszystkich innych przypadkach `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsAmbient%2A> aby zwracać wartość inną niż jest włączana przez domyślny odbicia wewnętrznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ umożliwia konstrukcji, zgodnie z definicją XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje umożliwia konstrukcji typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 Domyślna implementacja używa odbicia CLR na <xref:System.Xaml.XamlType.UnderlyingType%2A>. Typ musi być konkretnych-nested i zamknięte. Domyślna implementacja sprawdza, czy typ jest typem wartości i powrotu <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, ta metoda zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsConstructible%2A> aby zwracać wartość inną niż jest włączana przez domyślny odbicia wewnętrznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje rozszerzenie znaczników; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Domyślna implementacja składa się tylko z tego połączenia:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsMarkupExtension%2A> do używania różnych logiki.  
  
 W warunkach specyfikacji języka XAML, ten typ musi być można przypisać do `x:MarkupExtension` celu powrotu `true` dla <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje namescope XAML, zgodnie z definicją XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje XAML namescope; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 Udostępnia domyślną implementację <xref:System.Xaml.XamlType.CanAssignTo%2A> pośrednio wywoływać względem typu <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> to interfejs, który jest zdefiniowany w zestawie WindowsBase.dll. Ta technika identyfikacji namescope XAML jest używany zarówno przez implementacje WPF i Windows Workflow Foundation języka XAML.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsNameScope%2A> do używania różnych logiki.  
  
 XAML namescope Wymusza unikatowość nazwy właściwości lub właściwości, które są używane do `x:Name`  /  `[name property]`. Jeśli <xref:System.Xaml.XamlType.IsNameScope%2A> jest `true`, a następnie mechanizmu wymuszania unikatowości powinny istnieć i należy ocenić, z punktu widzenia ten typ będący właścicielem XAML namescope. XAML namescope następnie rozszerza do typu zawartości, dopóki napotkano inny typ będący właścicielem namescope XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null, zgodnie z definicją XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ dopuszczający wartość null; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 Domyślna implementacja sprawdza oparty na CLR core biblioteki nullable koncepcji, sprawdza, czy <xref:System.Xaml.XamlType.UnderlyingType%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsNullable%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny w systemie odpowiedniego typu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ publiczny; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 Domyślna implementacja używa odbicia CLR względem innych niż null <xref:System.Xaml.XamlType.UnderlyingType%2A>. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsPublic%2A> do używania różnych logiki.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić informacje zgłoszone dostępu typu XAML, tak aby go już wyrównuje w oczekiwany sposób, przy użyciu typu systemu lub dostępu do informacji o jego typem podstawowym CLR. Dla żadnych krytyczny dla zabezpieczeń kontroli dostępu i przypisania operacji w zamian użyj podstawowego typu środowiska CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który nie jest rozpoznawany w podstawowym systemie typu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje nonresolvable typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 Domyślna implementacja służy odbicia CLR. Null <xref:System.Xaml.XamlType.UnderlyingType%2A>, zwraca `true`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsUnknown%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczących odstępu, zgodnie z harmonogramem definicji XML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje kolekcję znaczące białe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> reprezentuje XML <see langword="XDATA" />, jak na definicji XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje <see langword="XDATA" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 Udostępnia domyślną implementację <xref:System.Xaml.XamlType.CanAssignTo%2A> pośrednio wywoływać względem typu <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsXData%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która zawiera informacje o typie dla <see langword="Items" /> właściwości tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu elementów w kolekcji; w przeciwnym razie <see langword="null" /> Jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje kolekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 Domyślna implementacja można użyć koncepcji odbicia CLR, takich jak sprawdzanie `Add` metody <xref:System.Reflection.MethodInfo> i przy użyciu <xref:System.Reflection.ParameterInfo>; sprawdzanie <xref:System.Xaml.XamlType.IsArray%2A>; i sprawdzanie <xref:System.Xaml.XamlType.BaseType%2A> i podjęcie próby tej samej logiki.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.ItemType%2A> do używania różnych logiki. Przypadków, gdy <xref:System.Xaml.XamlType.LookupCollectionKind%2A> zwraca <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> powinien zwrócić `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która zawiera informacje o typie dla właściwości klucza tego <see cref="T:System.Xaml.XamlType" />, jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje słownik.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu klucza słownika użycia, lub <see langword="null" /> Jeśli <see cref="T:System.Xaml.XamlType" /> nie reprezentuje słownik</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 Domyślna implementacja można użyć koncepcji odbicia CLR, takich jak sprawdzanie `Add` metody <xref:System.Reflection.MethodInfo> i przy użyciu <xref:System.Reflection.ParameterInfo>; i sprawdzanie <xref:System.Xaml.XamlType.BaseType%2A> i podjęcie próby tej samej logiki.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.KeyType%2A> do używania różnych logiki. Przypadków, gdy <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nie zwraca <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> powinien zwrócić `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość, która zawiera informacje o typie dla zwróconego <see langword="ProvideValue" /> tego <see cref="T:System.Xaml.XamlType" />, jeśli stanowi rozszerzenie znaczników.</summary>
        <returns>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu zwracanych danych użycia rozszerzenia znaczników; w przeciwnym razie <see langword="null" />, jeśli to <see cref="T:System.Xaml.XamlType" /> nie reprezentuje rozszerzenie znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType> na podstawie odczytu <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa elementu członkowskiego do pobrania (jako ciąg).</param>
        <param name="skipReadOnlyCheck">
          <see langword="true" /> Aby zwrócić elementu członkowskiego, nawet jeśli ten element członkowski ma <see langword="true" /> wartość <see cref="P:System.Xaml.XamlMember.IsReadOnly" />; <see langword="false" /> aby nie zwracał <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> elementu członkowskiego. Wartość domyślna to <see langword="false" />.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlMember" /> dla określonego o nazwie elementu członkowskiego to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> Informacji dla elementu członkowskiego, jeśli element członkowski został znaleziony, a w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 Domyślna implementacja zwraca <xref:System.Xaml.XamlType> na podstawie wewnętrznych odbicia CLR i kontekst schematu, dopasowując.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.GetMember%2A> do używania różnych logiki.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> jest wirtualna i w związku z tym może zostać zastąpiona. Zastąpienie może potencjalnie (czy do celów złośliwego lub w inny sposób) Aby zmienić członków zgłoszonego typu XAML tak, aby już wyrównane, w oczekiwany sposób, z <xref:System.ComponentModel.TypeDescriptor> `Get*` informacji na temat podstawowy typ CLR. Dla kontroli krytyczny dla zabezpieczeń elementu członkowskiego raportowania należy używać podstawowy typ CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Liczba (argumentów) określonej składni lub konstruktora tryb, w którym chcesz uzyskać informacje.</param>
        <summary>W przypadku typów rozszerzenia znaczników zwraca typy parametrów pozycyjnych, które są obsługiwane przez użycie rozszerzenia znaczników określonego dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista <see cref="T:System.Xaml.XamlType" /> wartości gdzie każdy taki <see cref="T:System.Xaml.XamlType" /> typ dla tej pozycji w składni. Należy określić tych typów w tej samej kolejności, dostarczając danych wejściowych znaczników dla rozszerzenia znacznika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 Domyślna implementacja używa informacji wewnętrznych odbicia na podstawie znajdowanie konstruktory i sprawdzanie liczby argumentów. Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.GetPositionalParameters%2A> do używania różnych logiki.  
  
 Ten interfejs API jest ważne, jeśli to tylko <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> jest `true`).  
  
 Dane wejściowe `parameterCount` nie jest przeznaczony dla żądania typu określonych parametrów pozycyjnych. Jest określenie liczby argumentów użycie rozszerzenia znaczników. Użycie rozszerzenia znaczników często posiada wiele sygnatur i używa parametru innej liczby argumentów skonkretyzowanego (licznik) parametrów pozycyjnych do odróżnienia. Można jednak skonfigurować kontekst schematu zezwala na zduplikowane arities i typy parametrów pozycyjnych na użytek zróżnicowanie. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Liczba określonych argumentów może się różnić pozycji parametrów i typy. Można pobrać typu pozycyjnych użycia rozszerzenia znaczników określonej liczby argumentów, należy najpierw wywołać <xref:System.Xaml.XamlType.GetPositionalParameters%2A> o liczbie argumentów. Następnie Pobierz elementu na tej pozycji z zwracana kolekcja.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca program obsługi wywołania zwrotnego na potrzeby operacji zestaw rozszerzeń znaczników.</summary>
        <returns>Wywołanie zwrotne obsługi do użycia dla operacji zestaw rozszerzeń znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca program obsługi do użycia dla konwertera typu Ustawianie przypadki.</summary>
        <returns>Program obsługi do użycia dla konwertera typu Ustawianie przypadki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> powinny być serializowane w trybie przycina otaczającego odstępu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> powinny być serializowane w trybie przycina odstępu otaczającego je; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mający <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenia, która reprezentuje zachowanie konwersji typu wartości tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenia, która reprezentuje zachowanie konwersji typu wartości tego <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.ComponentModel.TypeConverterAttribute>. Domyślna implementacja można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Obejmuje on też specjalną logikę przetwarzania domyślne wyliczenia, Popularne typy wartości i typy ogólne. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.TypeConverter%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca CLR <see cref="T:System.Type" /> który źródłową to <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Środowisko CLR <see cref="T:System.Type" /> który źródłową to <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 Domyślna implementacja zwraca pola wewnętrznego. To pole jest zazwyczaj zainicjowany podczas konstruowania i jego wartość jest oparta na konstruktora, która została wywołana i podane informacje.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.UnderlyingType%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> jest wbudowana góra dół podczas inicjowania XAML.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> jest wbudowana góra dół podczas inicjowania XAML; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Góra dół jest metaphor, zbliżony zachowanie procesora XAML podczas tworzenia wykresu obiektu. Podczas tworzenia góry do dołu, wystąpienia typu dołączony do obiektu nadrzędnego, i ma ustawiony jego właściwości. Góra dół konstrukcji pozwala uniknąć wywoływania obsługi zmienić właściwości wiele razy. Takie Obsługa fale się wykres obiektu i w związku z tym eliminuje wiele wywołań obsługi oraz zapewnia optymalizację wydajności podczas uruchamiania obiektu wykresu.  
  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Jeśli wartość jest niedostępny, zwraca `false`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mający <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenia, która reprezentuje zachowanie serializacji wartości dla wartości tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości to <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływany przez wywołania <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 Domyślna implementacja zwraca wartość opartą na odczyt <xref:System.Windows.Markup.ValueSerializerAttribute>. Można również sprawdzić <xref:System.Xaml.XamlType.BaseType%2A> dla atrybutu, jeśli nie jest odnaleźć atrybutu w typie podstawowym natychmiastowego. Obejmuje on też specjalne logikę domyślnej serializacji wyliczenia, wspólnych typów wartości lub typów ogólnych. Jeśli wartość jest niedostępny, zwraca `null`.  
  
 Przesłonić tę metodę, jeśli chcesz <xref:System.Xaml.XamlType.ValueSerializer%2A> do używania różnych logiki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która zawiera informacje o typie dla zwróconego <see langword="ProvideValue" /> tego <see cref="T:System.Xaml.XamlType" />, jeśli stanowi rozszerzenie znaczników.</summary>
        <value>A <see cref="T:System.Xaml.XamlType" /> obiektu dla typu zwracanych danych użycia rozszerzenia znaczników; w przeciwnym razie <see langword="null" />, jeśli to <see cref="T:System.Xaml.XamlType" /> nie reprezentuje rozszerzenie znaczników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość dotyczy tylko jeśli <xref:System.Xaml.XamlType> reprezentuje rozszerzenie znaczników (`x:MarkupExtension` znajduje się na liście można przypisać typów).  
  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę ciągu typu, który to <see cref="T:System.Xaml.XamlType" /> reprezentuje.</summary>
        <value>Nazwa ciągu tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zazwyczaj pobiera nazwę skonstruowany schematu (na <xref:System.Xaml.XamlType.%23ctor%2A> podpis), lub nazwę <xref:System.Type>, jeśli jest tworzony przy użyciu odpowiednich konstruktora system typów CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <param name="xamlType2">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlType" /> obiekty mają taką samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="xamlType1" /> jest taka sama jak wartość <paramref name="xamlType2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <param name="xamlType2">A <see cref="T:System.Xaml.XamlType" /> lub <see langword="null" />.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.Xaml.XamlType" /> obiekty mają różne wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość <paramref name="xamlType1" /> różni się od wartości <paramref name="xamlType2" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera jednej przestrzeni nazw XAML, która jest głównej przestrzeni nazw XAML dla tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Identyfikator jako ciąg głównej przestrzeni nazw XAML dla tego typu XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja udostępnia taką samą wartość jak wywołanie <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> i następnie pobieranie pierwszy ciąg wartości z zwrócony wyliczalny zestaw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktywny <see cref="T:System.Xaml.XamlSchemaContext" /> przetwarzania to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Aktywne <see cref="T:System.Xaml.XamlSchemaContext" /> przetwarzania to <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> jest wpisem wymaganego parametru podczas tworzenia <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Reprezentacja ciągu tego <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlType> Implementacja <xref:System.Object.ToString%2A> zwraca <xref:System.Xaml.XamlType.Name%2A> właściwość <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy to <see cref="T:System.Xaml.XamlType" /> ma odstępu obsługi zachowania w przypadku serializacji, który przycina otaczającego odstęp w jego zawartości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Xaml.XamlType" /> reprezentuje typ, który korzysta z odstępem przycinanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę argumentów typu dla przypadków, gdy to <see cref="T:System.Xaml.XamlType" /> reprezentuje ogólnego.</summary>
        <value>Lista typów argumentów typu. w przeciwnym razie <see langword="null" />, jeśli to <see cref="T:System.Xaml.XamlType" /> nie reprezentuje ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją pewne scenariusze <xref:System.Xaml.XamlType> w przypadku, gdy wywołanie <xref:System.Xaml.XamlType.TypeArguments%2A> parametru zwraca listę, których typy są nadal otwarte. W tym przypadku co najmniej więcej zwracana <xref:System.Xaml.XamlType> wartości będą miały wartości symbolu zastępczego dla <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, takich jak `T`, do reprezentowania, że ogólnego jest wciąż otwarty. Ten scenariusz może wystąpić, jeśli <xref:System.Xaml.XamlType> po wywołaniu <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, a nie z implementacją czytnika XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie, aby reprezentuje typ zachowanie konwersji wartości to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.ComponentModel.TypeConverter" /> ograniczenie, aby reprezentuje typ zachowanie konwersji wartości to <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupTypeConverter%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupTypeConverter%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera środowisko CLR <see cref="T:System.Type" /> który źródłową to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Środowisko CLR <see cref="T:System.Type" /> który źródłową to <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości to <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z <see cref="T:System.Windows.Markup.ValueSerializer" /> ograniczenie, które reprezentuje wartość zachowanie serializacji dla wartości to <see cref="T:System.Xaml.XamlType" />; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie używasz domyślne wewnętrzny CLR odbicia technika <xref:System.Xaml.XamlType>, wywołania do tej właściwości może wywołać <xref:System.Xaml.XamlType.LookupValueSerializer%2A> zastępuje na <xref:System.Xaml.XamlType> klas pochodnych. Aby uzyskać więcej informacji na temat zwracanych wartości i inne zachowanie, zobacz dokumentację <xref:System.Xaml.XamlType.LookupValueSerializer%2A> dla tego typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="XamlSchemaContext" FullName="System.Xaml.XamlSchemaContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="efd865db192851c2d0fc38d5e634296126fa55f0" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69427123" /></Metadata><TypeSignature Language="C#" Value="public class XamlSchemaContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlSchemaContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlSchemaContext" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlSchemaContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlSchemaContext" />
  <TypeSignature Language="F#" Value="type XamlSchemaContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje kontekst wielokrotnego użytku dla interpretacji lub mapowania typów XAML oraz typów w zestawach, które je podstawą.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst schematu XAML zapewnia warstwę abstrakcji między schematem lub słownictwem języka XAML a określoną implementacją parsera. Wstawiając koncepcję kontekstu schematu, schemat może być używany z różnymi analizatorami kodu XAML, a kontekst schematu wypełnia szczegóły, które są konieczne do współpracy z określonym parserem XAML. Na przykład kontekst schematu XAML zawiera interfejsy API zapytania, które odnoszą się do pojęć języka XAML lub do powiązania CLR z systemem typu XAML. Kontekst schematu XAML jest również odpowiedzialny za konserwację listy zestawów załadowanych zestawów, która definiuje, gdzie Analizator XAML szuka typów zapasowych.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.AppDomain" /> W<see cref="T:System.Xaml.XamlSchemaContext" /> , może być współużytkowane przez wiele wywołań, które obejmują zarówno pełne, jak i częściowe obiekty wywołujące zaufania. Ta sytuacja istnieje w strukturach, takich jak WPF, zapewniająca dostęp częściowo Ufaj do ładowania XAML dla części modelu aplikacji WPF. Domyślna <see cref="T:System.Xaml.XamlSchemaContext" /> implementacja zapewnia zabezpieczenia w tym scenariuszu, zachowując jednocześnie wszystkie jego właściwości i ustawienia. Implementacje pochodne należy również rozważyć po tym modelu niezmienności dla właściwości i ustawień kontekstu schematu XAML.  
  
Klasa <see cref="T:System.Xaml.XamlSchemaContext" /> bazowa jest zaprojektowana tak, aby wyszukiwania nie miały na zewnątrz efektów ubocznych. Typy, do których odwołują <see cref="T:System.Xaml.XamlSchemaContext" /> się interfejsy API w klasie bazowej, takie <see cref="T:System.Xaml.XamlType" /> jak <see cref="T:System.Xaml.XamlMember" />lub, również nie generują żadnych efektów ubocznych z odnośników. Wszystkie dane, które są konieczne do określenia schematu, powinny być dostępne z konstruowania i ustawień <see cref="T:System.AppDomain" />. Zwróć uwagę, że żadne interfejsy API wyszukiwania nie bazują na jawnych usługach przekazywania; dane wejściowe są oparte tylko na danych wejściowych.  
  
Klasa bazowa i <see cref="T:System.Xaml.XamlType" /> i<see cref="T:System.Xaml.XamlMember" /> są wszystkie wątki bezpieczne w ich implementacjach podstawowych. <see cref="T:System.Xaml.XamlSchemaContext" /> Jeśli pochodzą z <see cref="T:System.Xaml.XamlSchemaContext" /> klas systemowych typu XAML, takich jak <see cref="T:System.Xaml.XamlType" /> i <see cref="T:System.Xaml.XamlMember" /> , możesz wybrać, czy klasy będą zachowywać się jako bezpieczny wątkowo.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext referenceAssemblies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Wyliczalny zestaw elementów informacji zestawu. Każdy element informacji o zestawie jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlSchemaContext" /> klasy na podstawie zestawu zestawów referencyjnych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Obiekt ustawień służący do konstruowania <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlSchemaContext" /> klasy na podstawie obiektu ustawień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt Settings przechowuje informacje dotyczące konwertera tekstu i rozszerzenia znaczników dla kontekstu schematu. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContextSettings>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies, System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies, class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly), settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies, System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; * System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext (referenceAssemblies, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Wyliczalny zestaw informacji o zestawie. Każdy element informacji o zestawie jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</param>
        <param name="settings">Obiekt ustawień służący do konstruowania <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Xaml.XamlSchemaContext" /> klasy na podstawie zestawu zestawów odwołań i obiektu ustawień.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!XamlSchemaContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="xamlSchemaContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera niestandardową <see langword="Finalize" /> implementację, która nie <see langword="Dispose" />jest wywoływać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konteksty schematu XAML nie powinny być usuwane przez automatyczne odzyskiwanie pamięci lub operacje wykonywane ręcznie. Chociaż konteksty schematu XAML nie mają żadnych niezarządzanych zasobów, <xref:System.Windows.Markup.XamlDeferLoadAttribute> właściwości mogą nadal być aktywne i usuwanie kontekstu schematu XAML może zakłócać pokrewną operację odroczonego ładowania.  
  
 <xref:System.AppDomain.AssemblyLoad>programy obsługi zdarzeń, które są podłączane wewnętrznie jako słabe odwołania, są czyszczone w tej implementacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifyAssemblyNamesInClrNamespaces">
      <MemberSignature Language="C#" Value="public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifyAssemblyNamesInClrNamespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FullyQualifyAssemblyNamesInClrNamespaces { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifyAssemblyNamesInClrNamespaces : bool" Usage="System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy schemat XAML i jego kontekst używają w pełni kwalifikowanych nazw zestawów w wartościach zwracanych przez interfejs API wyszukiwania.</summary>
        <value><see langword="true" />Jeśli schemat XAML i jego kontekst używają w pełni kwalifikowanych nazw zestawów w wartości, które są zwracane przez interfejsy API wyszukiwania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> wartość ustanowioną w ustawieniach <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> dla sygnatury konstruktora. Jeśli inne podpisy zostały użyte do konstrukcji lub <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> Jeśli nie są określone jako `true`, wartość tej właściwości to `false`.  
  
 Wartość tej właściwości ma wpływ na ciągi, które są zwracane przez <xref:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces%2A>. Jeśli <xref:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces%2A> <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>jest `true`, część zestawu ciągu raportuje odpowiednik.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetAllXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetAllXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlNamespaces () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetAllXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;&#xA;override this.GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;" Usage="xamlSchemaContext.GetAllXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przeszukuje zestawy, które są przechowywane przez <see cref="T:System.Xaml.XamlSchemaContext" /> ten program, i zwraca zestaw przestrzeni nazw.</summary>
        <returns>Wyliczalny zestaw identyfikatorów przestrzeni nazw. Identyfikatory te są dostarczane jako ciągi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje tylko zestawy referencyjne, jeśli są one przenoszone za pomocą ustawienia konstrukcji lub właściwości. Jeśli żadne zestawy nie są ustanowione jako zestawy referencyjne, logika tej metody bada wszystkie załadowane zestawy, <xref:System.Xaml.XamlSchemaContext> gdy jest to aktywne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt; GetAllXamlTypes (string xamlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlType&gt; GetAllXamlTypes(string xamlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlTypes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlTypes (xamlNamespace As String) As ICollection(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::ICollection&lt;System::Xaml::XamlType ^&gt; ^ GetAllXamlTypes(System::String ^ xamlNamespace);" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;&#xA;override this.GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;" Usage="xamlSchemaContext.GetAllXamlTypes xamlNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML, dla której mają zostać zwrócone typy.</param>
        <summary>Przeszukuje zestawy, które są przechowywane przez <see cref="T:System.Xaml.XamlSchemaContext" /> ten element i zwraca zestaw typów z określonej przestrzeni nazw XAML.</summary>
        <returns>Wyliczalny zestaw typów XAML. Każdy typ XAML w zestawie jest reprezentowany przez <see cref="T:System.Xaml.XamlType" /> obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetPreferredPrefix (string xmlns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPreferredPrefix(string xmlns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetPreferredPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredPrefix (xmlns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPreferredPrefix(System::String ^ xmlns);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredPrefix : string -&gt; string&#xA;override this.GetPreferredPrefix : string -&gt; string" Usage="xamlSchemaContext.GetPreferredPrefix xmlns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlns">Przestrzeń nazw XAML, w której ma zostać pobrany preferowany prefiks.</param>
        <summary>Pobiera ciąg, który jest raportowany jako preferowany prefiks używany przez odbiorców podczas mapowania określonej przestrzeni nazw XAML.</summary>
        <returns>Ciąg, który powinien być używany przez odbiorców, gdy mapują określoną przestrzeń nazw XAML do użycia znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej bezpośrednim konsumentem informacji jest zazwyczaj składnik zapisywania XAML. Inni odbiorcy pośrednim obejmują narzędzia projektowania.  
  
 W ramach powiązania XAML dla środowiska uruchomieniowego języka wspólnego (CLR) można określić te informacje, stosując <xref:System.Windows.Markup.XmlnsPrefixAttribute> na poziomie zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlns" />ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter&lt;TConverterBase&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt; GetValueConverter&lt;TConverterBase&gt; (Type converterType, System.Xaml.XamlType targetType) where TConverterBase : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Xaml.Schema.XamlValueConverter`1&lt;!!TConverterBase&gt; GetValueConverter&lt;class TConverterBase&gt;(class System.Type converterType, class System.Xaml.XamlType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetValueConverter``1(System.Type,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueConverter(Of TConverterBase As Class) (converterType As Type, targetType As XamlType) As XamlValueConverter(Of TConverterBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TConverterBase&gt;&#xA; where TConverterBase : class System::Xaml::Schema::XamlValueConverter&lt;TConverterBase&gt; ^ GetValueConverter(Type ^ converterType, System::Xaml::XamlType ^ targetType);" />
      <MemberSignature Language="F#" Value="member this.GetValueConverter : Type * System.Xaml.XamlType -&gt; System.Xaml.Schema.XamlValueConverter&lt;'ConverterBase (requires 'ConverterBase : null)&gt; (requires 'ConverterBase : null)" Usage="xamlSchemaContext.GetValueConverter (converterType, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConverterBase">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <typeparam name="TConverterBase">Klasa bazowa określonego konwertera.</typeparam>
        <param name="converterType">Implementacja konwertera.</param>
        <param name="targetType">Żądany typ docelowy dla konwertera.</param>
        <summary>Zwraca konwerter wartości, który może zostać przekonwertowany na <paramref name="targetType" />żądany.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> Z ograniczeniem, które jest zgodne z ograniczeniem, które jest umieszczane w wywołaniu metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlDirective">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlDirective GetXamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlDirective GetXamlDirective(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlDirective(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlDirective (xamlNamespace As String, name As String) As XamlDirective" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlDirective ^ GetXamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective&#xA;override this.GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective" Usage="xamlSchemaContext.GetXamlDirective (xamlNamespace, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlDirective</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML, która zawiera nazwę dyrektywy.</param>
        <param name="name">Nazwa dyrektywy do uzyskania.</param>
        <summary><see cref="T:System.Xaml.XamlDirective" /> Zwraca wartość reprezentującą dyrektywę dla języka XAML lub dla określonej implementacji.</summary>
        <returns><see cref="T:System.Xaml.XamlDirective" /> Obiekt, który reprezentuje żądaną dyrektywę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp tę metodę w przypadku utworzenia klasy pochodnej z <xref:System.Xaml.XamlDirective> poziomu scenariusza rozszerzenia systemu typu XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" />lub <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXamlType">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xaml.XamlType" /> Zwraca, który jest oparty na identyfikatorze typu CLR lub XAML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlType GetXamlType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : Type -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : Type -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ, dla którego ma <see cref="T:System.Xaml.XamlType" /> zostać uzyskana wartość.</param>
        <summary><see cref="T:System.Xaml.XamlType" /> Zwraca, który jest oparty na identyfikatorze typu CLR.</summary>
        <returns>Dopasowuje dane wejściowe <paramref name="type" />. <see cref="T:System.Xaml.XamlType" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym przeciążeniu przyjęto założenie, że używane jest środowisko CLR dla systemu typu zapasowego. Jeśli nie używasz systemu typów CLR, użyj polecenia <xref:System.Xaml.XamlSchemaContext.GetXamlType%28System.Xaml.Schema.XamlTypeName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType GetXamlType (System.Xaml.Schema.XamlTypeName xamlTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlType GetXamlType(class System.Xaml.Schema.XamlTypeName xamlTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Xaml.Schema.XamlTypeName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlType ^ GetXamlType(System::Xaml::Schema::XamlTypeName ^ xamlTypeName);" />
      <MemberSignature Language="F#" Value="member this.GetXamlType : System.Xaml.Schema.XamlTypeName -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType xamlTypeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlTypeName" Type="System.Xaml.Schema.XamlTypeName" />
      </Parameters>
      <Docs>
        <param name="xamlTypeName">Nazwa typu XAML, dla którego ma <see cref="T:System.Xaml.XamlType" /> zostać uzyskana wartość.</param>
        <summary><see cref="T:System.Xaml.XamlType" /> Zwraca, który jest oparty na nazwie typu systemu XAML.</summary>
        <returns>Dopasowuje dane wejściowe <paramref name="xamlTypeName" />. <see cref="T:System.Xaml.XamlType" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Składnik <paramref name="xamlTypeName" /> (<see cref="P:System.Xaml.Schema.XamlTypeName.Name" /> lub )<see cref="P:System.Xaml.Schema.XamlTypeName.Namespace" />jest .<see langword="null" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlTypeName" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xaml.Schema.XamlTypeName" />
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xaml.XamlType GetXamlType (string xamlNamespace, string name, params System.Xaml.XamlType[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(string xamlNamespace, string name, class System.Xaml.XamlType[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.String,System.String,System.Xaml.XamlType[])" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetXamlType (xamlNamespace As String, name As String, ParamArray typeArguments As XamlType()) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(System::String ^ xamlNamespace, System::String ^ name, ... cli::array &lt;System::Xaml::XamlType ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType (xamlNamespace, name, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Xaml.XamlType[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML, która zawiera żądany typ.</param>
        <param name="name">Nazwa ciągu żądanego typu.</param>
        <param name="typeArguments">Argumenty typu inicjalizacji dla typu ogólnego.</param>
        <summary>Zwraca obiekt <see cref="T:System.Xaml.XamlType" /> , który jest oparty na przestrzeni nazw XAML i ciągu dla nazwy typu. Ta sygnatura może określać argumenty typu dla przypadków, w których żądany typ jest typem ogólnym.</summary>
        <returns>Jest <see cref="T:System.Xaml.XamlType" /> to zgodne z kryteriami wejściowymi.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAssemblyResolve">
      <MemberSignature Language="C#" Value="protected internal virtual System.Reflection.Assembly OnAssemblyResolve (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Reflection.Assembly OnAssemblyResolve(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.OnAssemblyResolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function OnAssemblyResolve (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Reflection::Assembly ^ OnAssemblyResolve(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member OnAssemblyResolve : string -&gt; System.Reflection.Assembly&#xA;override this.OnAssemblyResolve : string -&gt; System.Reflection.Assembly" Usage="xamlSchemaContext.OnAssemblyResolve assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu do załadowania.</param>
        <summary>Wywołuje się, gdy operacje używają tego kontekstu schematu do rozwiązania zestawu, który jest wymagany w celu rozpoznania przestrzeni nazw XAML, które zawiera.</summary>
        <returns>Rozpoznany zestaw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowa technika rozpoznawania zestawu, która jest wewnętrznym interfejsem API, ma wbudowaną tolerancję dla różnych postaci ciągów nazw zestawów w oparciu o <xref:System.Reflection.AssemblyName> zachowanie konstrukcji.  
  
 Celem tego interfejsu API jest włączenie rozdzielczości pierwszej szansy dla znanych zestawów zestawów, takich jak względem zestawów referencyjnych, a nie do globalnej pamięci podręcznej zestawów. Jeśli zostanie wypełniona lista zestawów odwołań, domyślna implementacja może uzyskać dostęp do znanych zestawów odwołań.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt; ReferenceAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Reflection.Assembly&gt; ReferenceAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferenceAssemblies As IList(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ ReferenceAssemblies { System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceAssemblies : System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;" Usage="System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyliczalny zestaw zestawów odwołań dla kontekstu schematu XAML.</summary>
        <value>Wyliczalny zestaw zestawów odwołań dla kontekstu schematu. Każdy element informacji o zestawie jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportMarkupExtensionsWithDuplicateArity">
      <MemberSignature Language="C#" Value="public bool SupportMarkupExtensionsWithDuplicateArity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportMarkupExtensionsWithDuplicateArity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportMarkupExtensionsWithDuplicateArity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportMarkupExtensionsWithDuplicateArity : bool" Usage="System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy schemat XAML i jego kontekst obsługują rozszerzenia znaczników, które mają dwa konstruktory z taką samą liczbą argumentów (liczba parametrów wejściowych).</summary>
        <value><see langword="true" />Jeśli kontekst schematu zezwala na rozszerzenia znaczników, które mają zduplikowane liczby argumentów; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> wartość ustanowioną w ustawieniach <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> dla sygnatury konstruktora. Jeśli inne podpisy są używane do konstruowania <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> lub jeśli nie są określone `true`jako, wartość tej właściwości to `false`.  
  
 Zduplikowane liczby argumentów rozszerzeń znaczników nie są szczególnie obsługiwane przez specyfikację XAML [MS-XAML], sekcja 6.6.7.2. Wynika to z faktu, że tworzenie elementu informacji XAML dla rozszerzenia znacznika jest identyczne niezależnie od zduplikowanych argumentów, które mogą istnieć w implementacji rozszerzenia znaczników. Tylko rzeczywiste wywołanie rozszerzenia znacznika i jego `ProvideValue` uwidacznia wszelkie problemy związane ze zduplikowanymi liczbami argumentów. Zachowanie podczas obsługi zduplikowanych argumentów jest w związku z tym niezdefiniowane i jest pozostawiane do każdego implementującego kontekstu schematu XAML i jego integracji z modułem zapisywania XAML. Domyślny kontekst schematu XAML zaimplementowanego dla .NET Framework operacji usług XAML nie obsługuje zduplikowanych argumentów; różne .NET Framework interfejsów API usług XAML będą generować wyjątki podczas przetwarzania użycia rozszerzenia znaczników przy użyciu podstawowej zduplikowanej liczby argumentów.  
  
 Aby uzyskać więcej informacji o definiowaniu rozszerzeń znaczników, zobacz [znaczniki rozszerzeń dla języka XAML — Omówienie](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetCompatibleXamlNamespace">
      <MemberSignature Language="C#" Value="public virtual bool TryGetCompatibleXamlNamespace (string xamlNamespace, out string compatibleNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetCompatibleXamlNamespace(string xamlNamespace, [out] string&amp; compatibleNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.TryGetCompatibleXamlNamespace(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetCompatibleXamlNamespace (xamlNamespace As String, ByRef compatibleNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetCompatibleXamlNamespace(System::String ^ xamlNamespace, [Runtime::InteropServices::Out] System::String ^ % compatibleNamespace);" />
      <MemberSignature Language="F#" Value="abstract member TryGetCompatibleXamlNamespace : string *  -&gt; bool&#xA;override this.TryGetCompatibleXamlNamespace : string *  -&gt; bool" Usage="xamlSchemaContext.TryGetCompatibleXamlNamespace (xamlNamespace, compatibleNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="compatibleNamespace" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace"><see langword="xmlns" /> Ciąg dla przestrzeni nazw XAML, który ma zostać sprawdzony pod kątem zgodnego wyniku.</param>
        <param name="compatibleNamespace">Gdy ta metoda zwraca, <see langword="xmlns" /> ciąg dla zgodnego żądania przestrzeni nazw XAML. Może to być takie samo <paramref name="xamlNamespace" /> , jak w przypadku <see langword="false" />, gdy metoda zwraca.</param>
        <summary>Zwraca powodzenie lub niepowodzenie żądania dla zgodnej przestrzeni nazw XAML. Pomyślne żądanie zgłasza, że przestrzeń nazw XAML jest parametrem out.</summary>
        <returns><see langword="true" />Jeśli <paramref name="compatibleNamespace" /> zawiera użyteczny wynik; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wewnętrznie metoda używa następującej kolejności wyszukiwania:  
  
1.  Wewnętrznie zaimplementowany słownik zgodności, który mógł zostać wypełniony przy użyciu wcześniejszego wyszukiwania.  
  
2.  Obliczanie <xref:System.Windows.Markup.XmlnsCompatibleWithAttribute> parametru.  
  
 Jeśli nie zostanie odnaleziona inna zgodna przestrzeń nazw i ta `false`Metoda zwróci `compatibleNamespace` metodę, dane wyjściowe parametru mogą mieć taką samą `xamlNamespace` wartość jak dane wejściowe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

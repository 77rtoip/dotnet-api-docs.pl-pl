<Type Name="XamlSchemaContext" FullName="System.Xaml.XamlSchemaContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30dfd7e6872cbf5555a5fecd6d6b0694782c7865" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52251652" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlSchemaContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlSchemaContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlSchemaContext" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlSchemaContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlSchemaContext" />
  <TypeSignature Language="F#" Value="type XamlSchemaContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje kontekst wielokrotnego użytku dla interpretacji lub mapowania typów XAML i typów w zestawach, które opierają się je.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst schematu XAML zapewnia warstwę abstrakcji między schematu lub słownika dla XAML i implementacji określonego analizatora. Wstawiając koncepcji kontekst schematu, schemat może być używany z różnych parsery XAML i kontekst schematu wypełnia szczegółowe informacje, które są potrzebne do interakcji z określonego analizatora XAML. Na przykład kontekst schematu XAML zawiera zapytanie interfejsów API, które odnoszą się do koncepcji XAML lub do powiązania CLR w systemie typu XAML. Kontekst schematu XAML jest również odpowiedzialna za listy zestawów załadowanych zestawów, definiujący, gdzie analizatora XAML szuka kopii typów.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>W <see cref="T:System.AppDomain" />, <see cref="T:System.Xaml.XamlSchemaContext" /> mogą być współużytkowane w wielu wywołań, które obejmują zarówno pełne i wywoływania w częściowej relacji zaufania. Takiej sytuacji istnieje w struktur, takich jak WPF, które umożliwiają dostęp do częściowego zaufania XAML podczas ładowania dla części modelu aplikacji WPF. Wartość domyślna <see cref="T:System.Xaml.XamlSchemaContext" /> implementacja udostępnia zabezpieczenia, w tym scenariuszu przechowując jej właściwości i ustawienia niezmienne. Pochodne implementacji należy również rozważyć następujące ten model systemu niezmienność we właściwościach i ustawieniach kontekst schematu XAML.  
  
<see cref="T:System.Xaml.XamlSchemaContext" /> Klasy bazowej jest zaprojektowana tak, że wyszukiwanie nie ma żadnych widocznych zewnętrznie efektów ubocznych. Typy, które są przywoływane przez <see cref="T:System.Xaml.XamlSchemaContext" /> klasy interfejsów API w podstawowym, takich jak <see cref="T:System.Xaml.XamlType" /> lub <see cref="T:System.Xaml.XamlMember" />, utworzyć również żadnych efektów ubocznych z wyszukiwania. Wszystkie dane, które jest potrzebne zapewnienie określenie schematu powinien być dostępny na konstrukcji i ustawienia <see cref="T:System.AppDomain" />. Zwróć uwagę, że żadne wyszukiwanie interfejsów API nie korzysta z usług jawnie przekazanego; swoje dane wejściowe, zależy od parametrów tylko wejściowych.  
  
<see cref="T:System.Xaml.XamlSchemaContext" /> Klasy, podstawowej i <see cref="T:System.Xaml.XamlType" /> i <see cref="T:System.Xaml.XamlMember" /> są bezpieczne w podstawowej implementacji wszystkich wątków. W przypadku klasy wyprowadzonej z <see cref="T:System.Xaml.XamlSchemaContext" /> lub pochodzić klasy systemie typu XAML, takich jak <see cref="T:System.Xaml.XamlType" /> i <see cref="T:System.Xaml.XamlMember" /> , można wybrać, czy Twoich zajęciach, będzie ona działać jak bezpieczne dla wątków.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext referenceAssemblies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Wyliczalny zestaw elementów informacji zestawu. Każdy element informacji zestaw jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy, na podstawie zestawu zestawów odwołań.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Obiekt ustawień do użycia do konstruowania <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy, w oparciu o obiekt ustawień.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt ustawień przechowuje informacje dotyczące konwerter tekstu i charakterystyki rozszerzenia znaczników dla kontekst schematu. Aby uzyskać więcej informacji, zobacz <xref:System.Xaml.XamlSchemaContextSettings>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies, System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies, class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly), settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies, System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; * System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext (referenceAssemblies, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Wyliczalny zestaw informacji o zestawie. Każdy element informacji zestaw jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</param>
        <param name="settings">Obiekt ustawień do użycia do konstruowania <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xaml.XamlSchemaContext" /> klasy, na podstawie zestawu zestawów odwołań i obiekt ustawień.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!XamlSchemaContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="xamlSchemaContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera niestandardowy <see langword="Finalize" /> implementację, która nie jest wywoływany <see langword="Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst schematu XAML nie powinny zostać usunięte, przez automatyczne wyrzucanie elementów bezużytecznych lub operacji ręcznych. Mimo że kontekst schematu XAML nie ma żadnych niezarządzanych zasobów, <xref:System.Windows.Markup.XamlDeferLoadAttribute> właściwości mogą być aktywne i usuwania kontekst schematu XAML może zakłócać operacji powiązanych odroczone obciążenia.  
  
 <xref:System.AppDomain.AssemblyLoad> procedury obsługi zdarzeń, które są podłączone wewnętrznie jako słabe odwołania, są czyszczone przez tę implementację.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifyAssemblyNamesInClrNamespaces">
      <MemberSignature Language="C#" Value="public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifyAssemblyNamesInClrNamespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FullyQualifyAssemblyNamesInClrNamespaces { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifyAssemblyNamesInClrNamespaces : bool" Usage="System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy schematu XAML i kontekst jej użyć w pełni kwalifikowane nazwy zestawów w wartości, które są zwracane przez interfejs API wyszukiwania.</summary>
        <value>
          <see langword="true" /> Użycie schematu XAML i kontekst w pełni kwalifikowane nazwy zestawów w wartości, które są zwracane przez wyszukiwanie interfejsów API; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> wartość, która jest określana w ustawienia <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> sygnatury konstruktora. Jeśli inne podpisy były używane do tworzenia lub <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> specjalnie nie jest ustawiony na `true`, wartość tej właściwości jest `false`.  
  
 Wartość ta właściwość ma wpływ na ciągi, które są zwracane przez <xref:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces%2A>. Jeśli <xref:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces%2A> jest `true`, część zestawu ciągu raportuje odpowiednik <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetAllXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetAllXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlNamespaces () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetAllXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;&#xA;override this.GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;" Usage="xamlSchemaContext.GetAllXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyszukuje zestawy, które są przechowywane w tym <see cref="T:System.Xaml.XamlSchemaContext" /> i zwraca zestaw przestrzeni nazw.</summary>
        <returns>Wyliczalny zestaw przestrzeni nazw identyfikatorów. Te identyfikatory są dostarczane jako ciągi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje zestawy referencyjne tylko, jeśli są one przekazywane za pomocą ustawienia konstrukcji lub właściwość. Jeśli żadne zestawy nie są określane jako zestawy odwołań, logika ta metoda sprawdza, czy wszystkie załadowane zestawy gdzie to <xref:System.Xaml.XamlSchemaContext> jest aktywny.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt; GetAllXamlTypes (string xamlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlType&gt; GetAllXamlTypes(string xamlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlTypes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlTypes (xamlNamespace As String) As ICollection(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::ICollection&lt;System::Xaml::XamlType ^&gt; ^ GetAllXamlTypes(System::String ^ xamlNamespace);" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;&#xA;override this.GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;" Usage="xamlSchemaContext.GetAllXamlTypes xamlNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML do zwracanych typów dla.</param>
        <summary>Wyszukuje zestawy, które są przechowywane w tym <see cref="T:System.Xaml.XamlSchemaContext" /> i zwraca zestaw typów z określonego obszaru nazw XAML.</summary>
        <returns>Wyliczalny zestaw typów XAML. Każdy typ XAML w zestawie jest reprezentowane przez <see cref="T:System.Xaml.XamlType" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetPreferredPrefix (string xmlns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPreferredPrefix(string xmlns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetPreferredPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredPrefix (xmlns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPreferredPrefix(System::String ^ xmlns);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredPrefix : string -&gt; string&#xA;override this.GetPreferredPrefix : string -&gt; string" Usage="xamlSchemaContext.GetPreferredPrefix xmlns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlns">Przestrzeń nazw XAML można pobrać preferowanych prefiks.</param>
        <summary>Pobiera ciąg, który jest zgłaszany jako prefiks preferowane dla klientów do użycia podczas mapowania ich określonego obszaru nazw XAML.</summary>
        <returns>Użyj ciągu, którego konsumentów ma używać podczas mapowania ich określonego obszaru nazw XAML dla kodu znaczników.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej bezpośrednim konsumenta informacji jest zazwyczaj Edytor XAML. Innych klientów pośrednich obejmują narzędzia do projektowania.  
  
 Te informacje jako część powiązania XAML dla środowisko uruchomieniowe języka wspólnego (CLR), można określić, stosując <xref:System.Windows.Markup.XmlnsPrefixAttribute> na poziomie zestawu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlns" /> ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter&lt;TConverterBase&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt; GetValueConverter&lt;TConverterBase&gt; (Type converterType, System.Xaml.XamlType targetType) where TConverterBase : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Xaml.Schema.XamlValueConverter`1&lt;!!TConverterBase&gt; GetValueConverter&lt;class TConverterBase&gt;(class System.Type converterType, class System.Xaml.XamlType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetValueConverter``1(System.Type,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueConverter(Of TConverterBase As Class) (converterType As Type, targetType As XamlType) As XamlValueConverter(Of TConverterBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TConverterBase&gt;&#xA; where TConverterBase : class System::Xaml::Schema::XamlValueConverter&lt;TConverterBase&gt; ^ GetValueConverter(Type ^ converterType, System::Xaml::XamlType ^ targetType);" />
      <MemberSignature Language="F#" Value="member this.GetValueConverter : Type * System.Xaml.XamlType -&gt; System.Xaml.Schema.XamlValueConverter&lt;'ConverterBase (requires 'ConverterBase : null)&gt; (requires 'ConverterBase : null)" Usage="xamlSchemaContext.GetValueConverter (converterType, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConverterBase">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <typeparam name="TConverterBase">Klasa bazowa określonego konwertera.</typeparam>
        <param name="converterType">Implementacji konwertera.</param>
        <param name="targetType">Typ docelowej lokalizacji dla konwertera.</param>
        <summary>Zwraca konwerter wartości, który można przekonwertować na żądany <paramref name="targetType" />.</summary>
        <returns>A <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> z ograniczeniem, odpowiadający ograniczenie, które jest umieszczany na wywołania metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlDirective">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlDirective GetXamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlDirective GetXamlDirective(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlDirective(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlDirective (xamlNamespace As String, name As String) As XamlDirective" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlDirective ^ GetXamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective&#xA;override this.GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective" Usage="xamlSchemaContext.GetXamlDirective (xamlNamespace, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlDirective</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML, który zawiera dyrektywy o nazwie.</param>
        <param name="name">Nazwa dyrektywy w celu uzyskania.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlDirective" /> wartość, która reprezentuje dyrektywę dla języka XAML lub dla określonej implementacji.</summary>
        <returns>A <see cref="T:System.Xaml.XamlDirective" /> obiekt, który reprezentuje żądany dyrektywy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy przesłonić tę metodę w przypadku tworzenia klasy pochodnej od <xref:System.Xaml.XamlDirective> w ramach scenariusza rozszerzenia systemie typu XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlNamespace" /> lub <paramref name="name" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXamlType">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> opartego na identyfikator typu CLR lub XAML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlType GetXamlType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : Type -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : Type -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ do pobrania <see cref="T:System.Xaml.XamlType" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> opartego na identyfikator typu CLR.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> Danych wejściowych, które odpowiadają <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie przyjęto założenie, że używasz środowiska CLR zapasowy typ systemu. Jeśli nie używasz systemu typu CLR, użyj <xref:System.Xaml.XamlSchemaContext.GetXamlType%28System.Xaml.Schema.XamlTypeName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType GetXamlType (System.Xaml.Schema.XamlTypeName xamlTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlType GetXamlType(class System.Xaml.Schema.XamlTypeName xamlTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Xaml.Schema.XamlTypeName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlType ^ GetXamlType(System::Xaml::Schema::XamlTypeName ^ xamlTypeName);" />
      <MemberSignature Language="F#" Value="member this.GetXamlType : System.Xaml.Schema.XamlTypeName -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType xamlTypeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlTypeName" Type="System.Xaml.Schema.XamlTypeName" />
      </Parameters>
      <Docs>
        <param name="xamlTypeName">Nazwa typu XAML, aby uzyskać <see cref="T:System.Xaml.XamlType" /> dla.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> opartego na Nazwa typu systemu XAML.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> Danych wejściowych, które odpowiadają <paramref name="xamlTypeName" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Składnik <paramref name="xamlTypeName" /> (<see cref="P:System.Xaml.Schema.XamlTypeName.Name" /> lub <see cref="P:System.Xaml.Schema.XamlTypeName.Namespace" />) jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlTypeName" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Xaml.Schema.XamlTypeName" />
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xaml.XamlType GetXamlType (string xamlNamespace, string name, params System.Xaml.XamlType[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(string xamlNamespace, string name, class System.Xaml.XamlType[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.String,System.String,System.Xaml.XamlType[])" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetXamlType (xamlNamespace As String, name As String, ParamArray typeArguments As XamlType()) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(System::String ^ xamlNamespace, System::String ^ name, ... cli::array &lt;System::Xaml::XamlType ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType (xamlNamespace, name, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Xaml.XamlType[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Przestrzeń nazw XAML, zawierająca żądanego typu.</param>
        <param name="name">Nazwa ciągu żądanego typu.</param>
        <param name="typeArguments">Inicjowanie argumentów typu dla typu ogólnego.</param>
        <summary>Zwraca <see cref="T:System.Xaml.XamlType" /> opartego na przestrzeń nazw XAML i ciągu dla nazwy typu. Ta sygnatura można określić argumentów typu w przypadkach, w których żądany typ jest typem ogólnym.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> Kryteria wejściowe, które odpowiadają.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAssemblyResolve">
      <MemberSignature Language="C#" Value="protected internal virtual System.Reflection.Assembly OnAssemblyResolve (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Reflection.Assembly OnAssemblyResolve(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.OnAssemblyResolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function OnAssemblyResolve (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Reflection::Assembly ^ OnAssemblyResolve(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member OnAssemblyResolve : string -&gt; System.Reflection.Assembly&#xA;override this.OnAssemblyResolve : string -&gt; System.Reflection.Assembly" Usage="xamlSchemaContext.OnAssemblyResolve assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu do załadowania.</param>
        <summary>Wywołuje się, gdy operacje używać ten kontekst schematu do rozpoznawania zestawu, który jest wymagany w celu rozwiązania przestrzeni nazw XAML, które zawiera.</summary>
        <returns>Rozpoznanego zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowy technika rozpoznawania zestawu, czyli wewnętrznego interfejsu API ma wbudowane tolerancji innym ciągiem formularze nazwy zestawu, jak na podstawie <xref:System.Reflection.AssemblyName> zachowanie konstrukcji.  
  
 Celem tego interfejsu API jest umożliwiające rozpoznawanie szansy sprzedaży pierwszy względem znanych zbiory zestawów, takich jak względem zestawów odwołań zamiast z globalnej pamięci podręcznej. Lista zestawów odwołań zostanie wypełnione, domyślna implementacja przejść do zestawów odwołań znane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt; ReferenceAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Reflection.Assembly&gt; ReferenceAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferenceAssemblies As IList(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ ReferenceAssemblies { System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceAssemblies : System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;" Usage="System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyliczalny zestaw zestawów referencyjnych dla kontekst schematu XAML.</summary>
        <value>Wyliczalny zestaw zestawów referencyjnych dla kontekst schematu. Każdy element informacji zestaw jest określony przez <see cref="T:System.Reflection.Assembly" /> wartość.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportMarkupExtensionsWithDuplicateArity">
      <MemberSignature Language="C#" Value="public bool SupportMarkupExtensionsWithDuplicateArity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportMarkupExtensionsWithDuplicateArity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportMarkupExtensionsWithDuplicateArity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportMarkupExtensionsWithDuplicateArity : bool" Usage="System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy schematu XAML i kontekst obsługiwać rozszerzenia znaczników, które mają dwa konstruktory przy użyciu tej samej liczby argumentów (liczba parametrów wejściowych).</summary>
        <value>
          <see langword="true" /> Jeśli kontekst schematu zezwala na — rozszerzenia znaczników, które mają zduplikowane argumentów; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> wartość, która jest określana w ustawienia <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> sygnatury konstruktora. Jeśli inne podpisy są używane do tworzenia lub <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> specjalnie nie jest ustawiony na `true`, wartość tej właściwości jest `false`.  
  
 Zduplikowane liczby argumentów — rozszerzenia znaczników nie jest specjalnie opisane w specyfikacji XAML [MS-XAML] sekcja 6.6.7.2. Jest to spowodowane tworzenia elementu informacji XAML dla rozszerzenia znaczników jest taka sama niezależnie od tego, zduplikowane liczby argumentów, które mogą istnieć w implementacji rozszerzenia znaczników. Rzeczywiste wywołanie rozszerzenie znaczników i jego `ProvideValue` uwidacznia wszystkie problemy związane z liczbą zduplikowanych ról. Zachowanie dotyczące obsługi zduplikowane specifikaci związku z tym jest nieokreślone i pozostanie do każdego implementującej kontekst schematu XAML i jej włączania zapisywania XAML. Domyślny kontekst schematu XAML zaimplementowany dla operacji programu .NET Framework XAML Services nie obsługuje zduplikowane argumentów; różne platformy .NET Framework XAML Services interfejsy API będzie zgłaszają wyjątki, gdy przetwarzania użycia rozszerzenia znaczników przy użyciu podstawowych zduplikowane liczby argumentów.  
  
 Aby uzyskać więcej informacji na temat definiowania rozszerzenia znaczników, zobacz [rozszerzenia znaczników dla przeglądu XAML](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetCompatibleXamlNamespace">
      <MemberSignature Language="C#" Value="public virtual bool TryGetCompatibleXamlNamespace (string xamlNamespace, out string compatibleNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetCompatibleXamlNamespace(string xamlNamespace, [out] string&amp; compatibleNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.TryGetCompatibleXamlNamespace(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetCompatibleXamlNamespace (xamlNamespace As String, ByRef compatibleNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetCompatibleXamlNamespace(System::String ^ xamlNamespace, [Runtime::InteropServices::Out] System::String ^ % compatibleNamespace);" />
      <MemberSignature Language="F#" Value="abstract member TryGetCompatibleXamlNamespace : string *  -&gt; bool&#xA;override this.TryGetCompatibleXamlNamespace : string *  -&gt; bool" Usage="xamlSchemaContext.TryGetCompatibleXamlNamespace (xamlNamespace, compatibleNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="compatibleNamespace" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">
          <see langword="xmlns" /> Parametrów dla przestrzeni nazw XAML, które mają być sprawdzane zgodnych wyników.</param>
        <param name="compatibleNamespace">Po powrocie z tej metody <see langword="xmlns" /> ciąg zgodny żądania przestrzeń nazw XAML. Może to być taka sama jak <paramref name="xamlNamespace" /> Jeśli metoda zwraca <see langword="false" />.</param>
        <summary>Zwraca powodzenie lub Niepowodzenie żądania zgodne przestrzeni nazw XAML. Żądania zakończonego powodzeniem raportuje tej przestrzeni nazw XAML jako parametrem out.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="compatibleNamespace" /> zawiera użyteczne wynik; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wewnętrznie ta metoda używa następującej kolejności wyszukiwania:  
  
1.  Słownik zaimplementowany wewnętrznie zgodności, który może być wypełnione przez wcześniejszego wyszukiwania.  
  
2.  <xref:System.Windows.Markup.XmlnsCompatibleWithAttribute> Parametru oceny.  
  
 Jeśli został odnaleziony innych nazw zgodnych, a ta metoda zwraca `false`, `compatibleNamespace` parametr wyjściowy może mieć taką samą wartość jak `xamlNamespace` danych wejściowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlNamespace" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
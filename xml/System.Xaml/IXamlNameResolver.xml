<Type Name="IXamlNameResolver" FullName="System.Xaml.IXamlNameResolver">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="667f1314cf421526dbdde15bf44a215978170d3b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30741341" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IXamlNameResolver" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IXamlNameResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.IXamlNameResolver" />
  <TypeSignature Language="VB.NET" Value="Public Interface IXamlNameResolver" />
  <TypeSignature Language="C++ CLI" Value="public interface class IXamlNameResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Zawiera opis usługi, która może zwracać obiekty, które są określone przez nazwę XAML, lub też zwraca token, który różni się rozpoznawania nazw. Usługę można także wrócić wyliczalny zestaw wszystkie nazwane obiekty, które znajdują się w XAML namescope.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten interfejs nie jest przeznaczony do implementacji zewnętrznej typowych scenariuszy XAML, ponieważ usługa. Usługa ta umożliwia rozszerzenia znaczników i konwertery typu do rozpoznawania nazw XAML do innych obiektów z tego samego źródła XAML, gdy są one nadal w reprezentacji węzła XAML. Usługę można rozwiązać odwołania w przód dowolnego mechanizmu zależy od nazw XAML rożne dostępu do produkcji otaczającego XAML. Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  
  
 Typy konwerterów i rozszerzeń znaczników mogą wykonywać kwerendę o <xref:System.Xaml.IXamlNameResolver> jako usługa w kontekście usługi zapewnianej przez moduł zapisujący obiektu XAML, gdy moduł zapisywania obiektów XAML wywoła zachowanie konwersji wartości. Aby uzyskać więcej informacji, zobacz [typy konwerterów i rozszerzenia znaczników dla XAML](~/docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md) i [usługi kontekstów dostępne dla typów konwerterów i rozszerzeń znaczników](~/docs/framework/xaml-services/service-contexts-available-to-type-converters-and-markup-extensions.md).  
  
 Ta usługa udostępnia interfejs API, który może odroczyć rozpoznawania nazw. Metaphor zaimplementowanych przez usługę to, że przechowywane i używane do utworzenia tokenu naprawy nazw, których nie można rozpoznać w pierwszym przebiegu z częściowa wykres obiektu nazwy. Zachowanie domyślne nazwy te są przesyłane do kolejnej próby rozwiązania w drugim przebiegu. W drugim przebiegu wykres ogólna nazwa obiektu została zakończona, a wszystkie tokeny naprawy są w stanie rozwiązać.  
  
> [!NOTE]
>  Nawet jeśli mogą przez implementację określonego odwołania w przód w języku XAML natychmiastową mieć skutki wydajności. Najlepszym rozwiązaniem dla XAML jakości produkcji należy unikać odwołania w przód, jeśli to możliwe.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.INameScopeDictionary" />
    <altmember cref="T:System.Windows.NameScope" />
  </Docs>
  <Members>
    <Member MemberName="GetAllNamesAndValuesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetAllNamesAndValuesInScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetAllNamesAndValuesInScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetAllNamesAndValuesInScope" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllNamesAndValuesInScope () As IEnumerable(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetAllNamesAndValuesInScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zestaw wszystkich obiektów o nazwie XAML namescope.</summary>
        <returns>Wyliczalny zestaw <see cref="T:System.Collections.Generic.KeyValuePair`2" /> obiektów. Dla każdego <see cref="T:System.Collections.Generic.KeyValuePair`2" />, <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> składnik jest ciąg znaków i <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" /> składnik jest obiekt, który używa <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" /> nazwie w XAML namescope.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFixupToken">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca obiekt, który można usunąć niektórych wzorce znaczników, które powodują powstanie odwołania w przód.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFixupToken">
      <MemberSignature Language="C#" Value="public object GetFixupToken (System.Collections.Generic.IEnumerable&lt;string&gt; names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFixupToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFixupToken (names As IEnumerable(Of String)) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFixupToken(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="names">Kolekcja nazw, które są możliwe odwołania w przód.</param>
        <summary>Zwraca obiekt, który można usunąć niektórych wzorce znaczników, które powodują powstanie odwołania w przód.</summary>
        <returns>Obiekt, który zawiera token dla zachowanie wyszukiwania ma zostać obliczone później.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące wewnętrzne dostawców, którzy są dostępne w kontekstach schematu dla rozszerzenia znaczników i wpisz konwerterów można zaimplementować tej usługi; jednak zwracają wewnętrzny typ, który może przetwarzać tylko istniejących zapisywania XAML, które działają w ramach domyślny kontekst schematu XAML.  
  
 W przypadku rozpoznawany do przodu przywoływanego nazwy kod użytkownika jest nazywany do ponownej analizy nazwy na liście.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFixupToken">
      <MemberSignature Language="C#" Value="public object GetFixupToken (System.Collections.Generic.IEnumerable&lt;string&gt; names, bool canAssignDirectly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFixupToken(class System.Collections.Generic.IEnumerable`1&lt;string&gt; names, bool canAssignDirectly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFixupToken (names As IEnumerable(Of String), canAssignDirectly As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFixupToken(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ names, bool canAssignDirectly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="canAssignDirectly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="names">Kolekcja nazw, które są możliwe odwołania w przód.</param>
        <param name="canAssignDirectly">
          <see langword="true" /> Aby przypisać natychmiast nazwa rozpoznać odwołania do właściwości target. <see langword="false" /> Wywoływanie kodu użytkownika dla ponownej analizy. Domyślnym zachowaniem jest <see langword="false" />.</param>
        <summary>Zwraca obiekt, który można usunąć niektórych wzorce znaczników, które powodują powstanie odwołania w przód.</summary>
        <returns>Obiekt, który zawiera token dla zachowanie wyszukiwania ma zostać obliczone później.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące wewnętrzne dostawców, którzy są dostępne w kontekstach schematu dla rozszerzenia znaczników i wpisz konwertery wdrożenia tej usługi; jednak zwracają typów wewnętrznych, które mogą być przetwarzane tylko przez istniejące autorów XAML, które działają w ramach domyślny kontekst schematu XAML.  
  
 Jeśli `canAssignDirectly` jest `false`, gdy do przodu przywoływanego nazwy są rozpoznawalną, kod użytkownika jest wywoływana w celu ponownej analizy nazwy na liście.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixupTokenAvailable">
      <MemberSignature Language="C#" Value="public bool IsFixupTokenAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixupTokenAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.IXamlNameResolver.IsFixupTokenAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixupTokenAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixupTokenAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy wywołanie <see cref="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" /> jest dostępny w celu rozpoznania nazwy w tokenie rozpoznanie do przodu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.Xaml.IXamlNameResolver.GetFixupToken(System.Collections.Generic.IEnumerable{System.String},System.Boolean)" /> jest dostępna jako implementacja zwraca token przydatne dla rozpoznawanie nazw w przód; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `false` podczas <xref:System.Xaml.IXamlNameResolver.GetFixupToken%2A> nie zwrócił tokenu, ponieważ <xref:System.Xaml.Schema.XamlValueConverter%601> uczestniczy w drugim przebiegu na istniejący token.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNameScopeInitializationComplete">
      <MemberSignature Language="C#" Value="event EventHandler OnNameScopeInitializationComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler OnNameScopeInitializationComplete" />
      <MemberSignature Language="DocId" Value="E:System.Xaml.IXamlNameResolver.OnNameScopeInitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Event OnNameScopeInitializationComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ OnNameScopeInitializationComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy procesor XAML został zarejestrowany wszystkie odpowiednie nazwy namescope XAML zapasowego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resolve">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa obiekt z odwołania do nazwy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public object Resolve (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Resolve(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.Resolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resolve (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Resolve(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa odwołania do rozpoznania.</param>
        <summary>Usuwa obiekt z odwołania do nazwy.</summary>
        <returns>Obiekt rozpoznać; lub wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość jest zwracana jako `null`, może istnieć odwołaniem w przód. Można użyć implementacji, które mają być obsługiwane odwołania w przód `FixupToken` do wzorca za pomocą <xref:System.Xaml.IXamlNameResolver.GetFixupToken%2A> i <xref:System.Xaml.IXamlNameResolver.IsFixupTokenAvailable%2A> interfejsów API.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.INameScope.FindName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public object Resolve (string name, out bool isFullyInitialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Resolve(string name, [out] bool&amp; isFullyInitialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.IXamlNameResolver.Resolve(System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resolve (name As String, ByRef isFullyInitialized As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Resolve(System::String ^ name, [Runtime::InteropServices::Out] bool % isFullyInitialized);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="isFullyInitialized" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa odwołania do rozpoznania.</param>
        <param name="isFullyInitialized">Gdy metoda zwróci wartość, <see langword="true" /> Jeśli zwrócony obiekt ma zależności w nierozpoznanych odwołań; w przeciwnym razie <see langword="false" />.</param>
        <summary>Usuwa obiekt z odwołania do nazwy i dostarcza wartość śledzenia, która raportuje, czy obiekt jest w pełni zainicjowany w celach wykresu obiektu.</summary>
        <returns>Obiekt, który zawiera token dla zachowanie wyszukiwania ma zostać obliczone później.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ManagementObjectCollection" FullName="System.Management.ManagementObjectCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="361b167a3d03bfa491639166c7a765b7762e1bc7" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55402415" /></Metadata><TypeSignature Language="C#" Value="public class ManagementObjectCollection : IDisposable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ManagementObjectCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Management.ManagementObjectCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class ManagementObjectCollection&#xA;Implements ICollection, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManagementObjectCollection : IDisposable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type ManagementObjectCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Management</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje różne kolekcje obiektów zarządzania pobierane za pomocą usługi WMI. Obiekty w tej kolekcji są <see cref="T:System.Management.ManagementBaseObject" />-pochodne typy, takie jak <see cref="T:System.Management.ManagementObject" /> i <see cref="T:System.Management.ManagementClass" />. Kolekcja może być wynik kwerendy usługi WMI wykonywane za pośrednictwem <see cref="T:System.Management.ManagementObjectSearcher" />, lub wyliczenie obiektów zarządzania o określonym typie pobierane w drodze <see cref="T:System.Management.ManagementClass" /> reprezentujący tego typu. Ponadto może to być kolekcją obiekty powiązane w określony sposób, aby obiekt zarządzania przeznaczone dla określonych — w tym przypadku kolekcja będzie można pobrać za pośrednictwem metody takie jak zarządzanie <see cref="M:System.Management.ManagementObject.GetRelated" />. Kolekcja może być dodawanym przy użyciu <see cref="T:System.Management.ManagementObjectCollection.ManagementObjectEnumerator" /> i obiektów w nim mogą być kontrolowane lub zmieniane dla różnych zadań zarządzania.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje kolekcję do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="managementObjectCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica do skopiowania do.</param>
        <param name="index">Indeks, aby rozpocząć od.</param>
        <summary>Kopiuje kolekcję do tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Management.ManagementBaseObject[] objectCollection, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Management.ManagementBaseObject[] objectCollection, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.CopyTo(System.Management.ManagementBaseObject[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (objectCollection As ManagementBaseObject(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Management::ManagementBaseObject ^&gt; ^ objectCollection, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Management.ManagementBaseObject[] * int -&gt; unit" Usage="managementObjectCollection.CopyTo (objectCollection, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectCollection" Type="System.Management.ManagementBaseObject[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="objectCollection">Tablica docelowa.</param>
        <param name="index">Indeks, aby rozpocząć od.</param>
        <summary>Kopiuje elementy kolekcji do <see cref="T:System.Management.ManagementBaseObject" /> tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Management.ManagementObjectCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Management.ManagementObjectCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą liczbę obiektów w kolekcji.</summary>
        <value>Liczba obiektów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest bardzo kosztowny — wymaga, że można wyliczyć wszystkie elementy członkowskie kolekcji.  
  
## <a name="property-value"></a>Wartość właściwości  
 Liczba obiektów w kolekcji.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="managementObjectCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby skojarzone z tym obiektem. Po wywołaniu tej metody, próba użycia tego obiektu spowoduje <see cref="T:System.ObjectDisposedException" /> zgłaszane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IDisposable.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ManagementObjectCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ManagementObjectCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="managementObjectCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa zasoby, które zawiera obiekt. Jest to destruktor dla obiektu. Finalizatory są wyrażone za pomocą składni destruktora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Management.ManagementObjectCollection.ManagementObjectEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Management.ManagementObjectCollection/ManagementObjectEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ManagementObjectCollection.ManagementObjectEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Management::ManagementObjectCollection::ManagementObjectEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Management.ManagementObjectCollection.ManagementObjectEnumerator" Usage="managementObjectCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.ManagementObjectCollection+ManagementObjectEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tylko można wykonać iterację (tak jak w języku Visual Basic .NET `For Each` instrukcji lub C# `For` instrukcji) za pośrednictwem tylko do przodu wyliczający jeden raz. Pamięć zawierającą wystąpienia jest zwalniany przez usługę WMI tak, aby nie może być przewinięta modułu wyliczającego. W związku z tym <xref:System.Management.ManagementObjectCollection.Count%2A> nie można użyć metody, ponieważ wymaga ona przewijanie modułu wyliczającego.  
  
 Tylko do przodu moduły wyliczające są zwykle dużo szybsze i używać mniej pamięci niż moduły wyliczające konwencjonalnych, ale nie zezwalają na wywołania <xref:System.Management.ManagementObjectCollection.ManagementObjectEnumerator.Reset%2A>.  
  
 Jeśli moduł wyliczający jest rewindable, obiektów w kolekcji pozostaną dostępne dla wielu wyliczenia.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Management.ManagementObjectCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Management.ManagementObjectCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt jest synchronizowany (bezpieczna wątkowo).</summary>
        <value><see langword="true" /> Jeśli obiekt jest zsynchronizowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Wartość właściwości  
 `true`, jeśli obiekt jest zsynchronizowana, w przeciwnym razie `false`.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Management.ManagementObjectCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Management.ManagementObjectCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który ma być używany do synchronizacji.</summary>
        <value>Obiekt, który może służyć do synchronizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Wartość właściwości  
 Obiekt, który ma być używany do synchronizacji.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Pełne zaufanie do bezpośredniego wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany. Aby uzyskać więcej informacji, zobacz [przy użyciu biblioteki z częściowo zaufanego kodu](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.ManagementObjectCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> iterację, która <see cref="T:System.Management.ManagementObjectCollection" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Dla <see cref="T:System.Management.ManagementObjectCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja języka C# (`for each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających.  W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji. Co to położenie, wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>. W przypadku modyfikowania kolekcji między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwraca element, który jest ustawiony, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji w związku z tym wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
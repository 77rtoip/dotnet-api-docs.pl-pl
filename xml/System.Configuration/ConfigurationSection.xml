<Type Name="ConfigurationSection" FullName="System.Configuration.ConfigurationSection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b68952bbc0f63d934edd49d4d2f1dad57c1f566" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69378614" /></Metadata><TypeSignature Language="C#" Value="public abstract class ConfigurationSection : System.Configuration.ConfigurationElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationSection extends System.Configuration.ConfigurationElement" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationSection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationSection&#xA;Inherits ConfigurationElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationSection abstract : System::Configuration::ConfigurationElement" />
  <TypeSignature Language="F#" Value="type ConfigurationSection = class&#xA;    inherit ConfigurationElement" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje sekcję w pliku konfiguracji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Configuration.ConfigurationSection> klasy do zaimplementowania niestandardowego typu sekcji. <xref:System.Configuration.ConfigurationSection> Rozszerzając klasę, aby zapewnić niestandardową obsługę i dostęp programistyczny do sekcji konfiguracji niestandardowej. Aby uzyskać informacje na temat korzystania z sekcji konfiguracji niestandardowej [, zobacz How to: Tworzenie niestandardowych sekcji konfiguracji przy użyciu](https://msdn.microsoft.com/library/febaca98-c727-4017-95ed-82e2fb6cf234)elementu ConfigurationSection.  
  
 Sekcja rejestruje swój typ obsługi z wpisem w `configSections` elemencie. Aby zapoznać się z przykładem, zobacz fragment pliku konfiguracji przedstawiony w sekcji przykład.  
  
> [!NOTE]
>  W poprzednich wersjach .NET Framework programy obsługi sekcji konfiguracji były używane do programistycznego wprowadzania zmian w ustawieniach konfiguracji. Teraz wszystkie domyślne sekcje konfiguracji są reprezentowane przez klasy, które zwiększają <xref:System.Configuration.ConfigurationSection> klasę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak programowo zaimplementować sekcję niestandardową.  
  
 Pełny przykład pokazujący sposób implementacji i używania sekcji niestandardowej zaimplementowane przy użyciu modelu z atrybutami można znaleźć w temacie <xref:System.Configuration.ConfigurationElement>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationSection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#1)]  
  
 Poniższy przykład to fragment pliku konfiguracji, który ma zastosowanie do poprzedniego przykładu.  
  
 ```xml
<?xml version="1.0" encoding="utf-8"?>
  <configuration>  
    <configSections>
      <section name="CustomSection" type="Samples.AspNet. CustomSection, CustomConfigurationSection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" />
    </configSections>  

    <CustomSection fileName="default.txt" maxUsers="1000" maxIdleTime="00:15:00" /> 
 
  </configuration>
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Możesz użyć programistycznego lub deklaracyjnego modelu kodowania, aby utworzyć sekcje konfiguracji niestandardowej: 
-Model programistyczny. Ten model wymaga, aby dla każdego atrybutu sekcji utworzyć właściwość w celu pobrania lub ustawienia jej wartości i dodania jej do wewnętrznego zbioru <see cref="T:System.Configuration.ConfigurationElement" /> właściwości bazowej klasy bazowej.  
  
-Deklaratywny model. Ten prostszy model, nazywany również modelem atrybutu, umożliwia zdefiniowanie atrybutu Section przy użyciu właściwości i dekorowania nazwy go z atrybutami. Te atrybuty instruują system konfiguracji ASP.NET o typach właściwości i ich wartościach domyślnych. Dzięki tym informacjom uzyskanym w wyniku odbicia system konfiguracji ASP.NET tworzy obiekty właściwości sekcji i wykonuje wymaganą inicjalizację.  
  
<see cref="T:System.Configuration.Configuration" /> Klasa umożliwia programistyczny dostęp do edytowania plików konfiguracji. Dostęp do tych plików można uzyskać w następujący sposób: 
Odczytu. Używasz programu <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> lub do odczytywania informacji o konfiguracji. <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> Należy pamiętać, że użytkownik lub proces odczytywania musi mieć następujące uprawnienia: 
-Uprawnienia do odczytu pliku konfiguracji na bieżącym poziomie hierarchii konfiguracji.  
  
— Uprawnienia do odczytu wszystkich nadrzędnych plików konfiguracji.  
  
Jeśli aplikacja wymaga dostępu tylko do odczytu do własnej konfiguracji, zaleca się używanie <see cref="Overload:System.Web.Configuration.WebConfigurationManager.GetSection" /> przeciążonych metod w przypadku aplikacji sieci Web <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> lub metody w przypadku aplikacji klienckich.  
  
Te metody zapewniają dostęp do buforowanych wartości konfiguracyjnych dla bieżącej aplikacji, które mają lepszą wydajność niż <see cref="T:System.Configuration.Configuration" /> Klasa.  
  
 <block subset="none" type="note"><para>  
 Jeśli używasz statycznej <see langword="GetSection" /> metody, która <paramref name="path" /> przyjmuje parametr, <paramref name="path" /> parametr musi odwoływać się do aplikacji, w której jest uruchomiony kod; w przeciwnym razie parametr jest ignorowany i informacje o konfiguracji aktualnie uruchomionego Aplikacja została zwrócona.  
  
</para></block>  
  
Napisane. Aby zapisać informacje o konfiguracji <see cref="Overload:System.Configuration.Configuration.Save" /> , należy użyć jednej z metod. Należy pamiętać, że użytkownik lub proces zapisu musi mieć następujące uprawnienia: 
-Uprawnienia do zapisu w pliku konfiguracji i katalogu na bieżącym poziomie hierarchii konfiguracji.  
  
— Uprawnienia do odczytu wszystkich plików konfiguracji.</para></block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Configuration.SectionInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
    <related type="Article" href="https://msdn.microsoft.com/library/5696e8b2-d489-4220-aef2-f2e0ca9099b4">Omówienie interfejsu API konfiguracji ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationSection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationSection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Configuration.ConfigurationSection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby użyć <xref:System.Configuration.ConfigurationSection.%23ctor%2A> konstruktora, należy najpierw zdefiniować niestandardowy typ sekcji. Aby zapoznać się z przykładem, <xref:System.Configuration.ConfigurationSection> Zobacz Omówienie klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Configuration.ConfigurationSection.%23ctor%2A> jak używać konstruktora. W tym przykładzie przyjęto założenie, że utworzono klasę sekcji `CustomSection`niestandardowej o nazwie. Przykład takiej klasy można znaleźć w <xref:System.Configuration.ConfigurationSection> temacie Omówienie klasy.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationSection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeserializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual void DeserializeSection (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void DeserializeSection(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.DeserializeSection(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub DeserializeSection (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void DeserializeSection(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member DeserializeSection : System.Xml.XmlReader -&gt; unit&#xA;override this.DeserializeSection : System.Xml.XmlReader -&gt; unit" Usage="configurationSection.DeserializeSection reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> Obiekt, który odczytuje z pliku konfiguracyjnego.</param>
        <summary>Odczytuje dane XML z pliku konfiguracyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deserializacja odwołuje się do odczytywania danych XML z pliku konfiguracyjnego, jego przekształcenia w dane w czasie rzeczywistym oraz jego magazynu w obiekcie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="reader" />nie znaleziono żadnych elementów w pliku konfiguracji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeObject">
      <MemberSignature Language="C#" Value="protected internal virtual object GetRuntimeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object GetRuntimeObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.GetRuntimeObject" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetRuntimeObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ GetRuntimeObject();" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeObject : unit -&gt; obj&#xA;override this.GetRuntimeObject : unit -&gt; obj" Usage="configurationSection.GetRuntimeObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt niestandardowy, gdy jest zastępowany w klasie pochodnej.</summary>
        <returns>Obiekt reprezentujący sekcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy metoda jest wywoływana w czasie wykonywania, system konfiguracji najpierw tworzy odpowiednie wystąpienie <xref:System.Configuration.ConfigurationSection> klasy, a następnie zwraca obiekt uzyskany z <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> metody. <xref:System.Configuration.Configuration.GetSection%2A>  
  
 Domyślnie <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> po prostu zwraca obiekt, który <xref:System.Configuration.ConfigurationSection> reprezentuje element, z którego jest wywoływana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> jak używać metody.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#4)]
 [!code-vb[System.Configuration.ConfigurationSection#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Można zastąpić <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> metodę w celu zwrócenia niestandardowego typu w czasie wykonywania.  
  
Na przykład aby ograniczyć modyfikacje czasu wykonywania w <see cref="T:System.Configuration.ConfigurationSection" /> klasie, można przesłonić <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> i zwrócić typ niestandardowy, który wymusza ograniczenia dotyczące tego, które ustawienia mogą być modyfikowane (jeśli istnieją).  
  
Jeśli obiekt środowiska uruchomieniowego jest tylko wewnętrzny, zwracany obiekt nie może być używany poza zestawem, który go definiuje. Jednym ze sposobów tworzenia obiektu, który pochodzi z <see cref="T:System.Configuration.ConfigurationSection" /> i można uzyskać dostęp tylko przez kod w zestawie w czasie wykonywania, jest utworzenie wewnętrznego obiektu środowiska uruchomieniowego, który ma metodę <see cref="T:System.Configuration.ConfigurationSection" /> zwracającą implementację.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberSignature Language="F#" Value="override this.IsModified : unit -&gt; bool" Usage="configurationSection.IsModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten element konfiguracji został zmodyfikowany od czasu ostatniego zapisania lub załadowania w przypadku zaimplementowania w klasie pochodnej.</summary>
        <returns><see langword="true" />Jeśli element został zmodyfikowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberSignature Language="F#" Value="override this.ResetModified : unit -&gt; unit" Usage="configurationSection.ResetModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje wartość <see cref="M:System.Configuration.ConfigurationElement.IsModified" /> metody do <see langword="false" /> po zaimplementowaniu w klasie pochodnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionInformation">
      <MemberSignature Language="C#" Value="public System.Configuration.SectionInformation SectionInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SectionInformation SectionInformation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionInformation As SectionInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::SectionInformation ^ SectionInformation { System::Configuration::SectionInformation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SectionInformation : System.Configuration.SectionInformation" Usage="System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SectionInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który zawiera informacje, które nie są dostosowywane i funkcje <see cref="T:System.Configuration.ConfigurationSection" /> obiektu. <see cref="T:System.Configuration.SectionInformation" /></summary>
        <value>Zawierający informacje, <see cref="T:System.Configuration.ConfigurationSection" /> któreniesądostosowywane<see cref="T:System.Configuration.SectionInformation" /> i funkcje programu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Configuration.ConfigurationSection.SectionInformation%2A> jak używać właściwości.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationSection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SectionInformation" />
      </Docs>
    </Member>
    <Member MemberName="SerializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual string SerializeSection (System.Configuration.ConfigurationElement parentElement, string name, System.Configuration.ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string SerializeSection(class System.Configuration.ConfigurationElement parentElement, string name, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.SerializeSection(System.Configuration.ConfigurationElement,System.String,System.Configuration.ConfigurationSaveMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SerializeSection (parentElement As ConfigurationElement, name As String, saveMode As ConfigurationSaveMode) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ SerializeSection(System::Configuration::ConfigurationElement ^ parentElement, System::String ^ name, System::Configuration::ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="F#" Value="abstract member SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string&#xA;override this.SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string" Usage="configurationSection.SerializeSection (parentElement, name, saveMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" />
      </Parameters>
      <Docs>
        <param name="parentElement"><see cref="T:System.Configuration.ConfigurationElement" /> Wystąpienie, które ma być używane jako element nadrzędny podczas wykonywania anulowania scalania.</param>
        <param name="name">Nazwa sekcji do utworzenia.</param>
        <param name="saveMode">Wystąpienie <see cref="T:System.Configuration.ConfigurationSaveMode" /> , które ma być używane podczas zapisywania w ciągu.</param>
        <summary>Tworzy ciąg XML zawierający Niescalony widok <see cref="T:System.Configuration.ConfigurationSection" /> obiektu jako pojedynczą sekcję do zapisu w pliku.</summary>
        <returns>Ciąg XML zawierający Niescalony widok <see cref="T:System.Configuration.ConfigurationSection" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializacja odnosi się do transformacji danych w czasie rzeczywistym, zawartych w obiekcie, do formatu XML i jego magazynu w pliku konfiguracji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeElementInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeElementInTargetVersion (System.Configuration.ConfigurationElement element, string elementName, System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeElementInTargetVersion(class System.Configuration.ConfigurationElement element, string elementName, class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeElementInTargetVersion(System.Configuration.ConfigurationElement,System.String,System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeElementInTargetVersion (element As ConfigurationElement, elementName As String, targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeElementInTargetVersion(System::Configuration::ConfigurationElement ^ element, System::String ^ elementName, System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeElementInTargetVersion (element, elementName, targetFramework)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="elementName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Configuration.ConfigurationElement" /> Obiekt, który jest kandydatem do serializacji.</param>
        <param name="elementName">Nazwa <see cref="T:System.Configuration.ConfigurationElement" /> obiektu w pliku XML.</param>
        <param name="targetFramework">Docelowa wersja [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu.</param>
        <summary>Wskazuje, czy określony element powinien być serializowany, gdy hierarchia obiektu konfiguracji jest serializowana dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]docelowej.</summary>
        <returns><see langword="true" />Jeśli powinna być serializowana; w przeciwnym <see langword="false" />razie,. <paramref name="element" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda sekcja konfiguracji utworzona dla [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i nowszych wersji musi jawnie przesłonić tę metodę i zwrócić `true`, ale tylko wtedy, gdy określony element jest prawidłowy dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Istniejące sekcje konfiguracji, które zostały utworzone dla wcześniejszych wersji programu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] , nie muszą być zmieniane.  
  
 Typ podstawowy zawiera domyślną implementację tej metody, która zawsze zwraca wartość `true`. Jeśli zaimplementowano sekcję konfiguracyjną i nie zastąpisz tej metody, domyślnie wszystkie elementy konfiguracji, które znajdują się w sekcji konfiguracji, zostaną zserializowane dla wszystkich wersji platformy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework określania elementów docelowych dla projektów sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePropertyInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializePropertyInTargetVersion (System.Configuration.ConfigurationProperty property, string propertyName, System.Runtime.Versioning.FrameworkName targetFramework, System.Configuration.ConfigurationElement parentConfigurationElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializePropertyInTargetVersion(class System.Configuration.ConfigurationProperty property, string propertyName, class System.Runtime.Versioning.FrameworkName targetFramework, class System.Configuration.ConfigurationElement parentConfigurationElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializePropertyInTargetVersion(System.Configuration.ConfigurationProperty,System.String,System.Runtime.Versioning.FrameworkName,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializePropertyInTargetVersion (property As ConfigurationProperty, propertyName As String, targetFramework As FrameworkName, parentConfigurationElement As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializePropertyInTargetVersion(System::Configuration::ConfigurationProperty ^ property, System::String ^ propertyName, System::Runtime::Versioning::FrameworkName ^ targetFramework, System::Configuration::ConfigurationElement ^ parentConfigurationElement);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool&#xA;override this.ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool" Usage="configurationSection.ShouldSerializePropertyInTargetVersion (property, propertyName, targetFramework, parentConfigurationElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Configuration.ConfigurationProperty" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="propertyName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="parentConfigurationElement" Type="System.Configuration.ConfigurationElement" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="property"><see cref="T:System.Configuration.ConfigurationProperty" /> Obiekt, który jest kandydatem do serializacji.</param>
        <param name="propertyName">Nazwa <see cref="T:System.Configuration.ConfigurationProperty" /> obiektu w pliku XML.</param>
        <param name="targetFramework">Docelowa wersja [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu.</param>
        <param name="parentConfigurationElement">Element nadrzędny właściwości.</param>
        <summary>Wskazuje, czy określona właściwość powinna być serializowana, gdy hierarchia obiektu konfiguracji jest serializowana dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]docelowej.</summary>
        <returns><see langword="true" />Jeśli powinna być serializowana; w przeciwnym <see langword="false" />razie,. <paramref name="property" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda sekcja konfiguracji utworzona dla [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i nowszych wersji musi jawnie przesłonić tę metodę i zwrócić `true`, ale tylko wtedy, gdy określona właściwość jest prawidłowa dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Istniejące sekcje konfiguracji, które zostały utworzone dla wcześniejszych wersji programu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] , nie muszą być zmieniane.  
  
 Typ podstawowy zawiera domyślną implementację tej metody, która zawsze zwraca wartość `true`. Jeśli zaimplementowano sekcję konfiguracyjną i nie zastąpisz tej metody, domyślnie wszystkie właściwości konfiguracji, które znajdują się w sekcji konfiguracji, zostaną zserializowane dla wszystkich wersji platformy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework określania elementów docelowych dla projektów sieci Web</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSectionInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeSectionInTargetVersion (System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeSectionInTargetVersion(class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeSectionInTargetVersion(System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeSectionInTargetVersion (targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeSectionInTargetVersion(System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeSectionInTargetVersion targetFramework" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="targetFramework">Docelowa wersja [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu.</param>
        <summary>Wskazuje, czy bieżące <see cref="T:System.Configuration.ConfigurationSection" /> wystąpienie powinno być serializowane, gdy Hierarchia obiektów konfiguracji jest serializowana dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]docelowej.</summary>
        <returns><see langword="true" />Jeśli bieżąca sekcja powinna być serializowana; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda sekcja konfiguracji utworzona dla [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i nowszych wersji musi jawnie przesłonić tę metodę i zwrócić `true`, ale tylko wtedy, gdy sekcja konfiguracji jest prawidłowa dla określonej wersji [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu. Istniejące sekcje konfiguracji, które zostały utworzone dla wcześniejszych wersji programu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] , nie muszą być zmieniane.  
  
 Typ podstawowy zawiera domyślną implementację tej metody, która zawsze zwraca wartość `true`. Jeśli zaimplementowano sekcję konfiguracyjną i nie zastąpisz tej metody, domyślnie sekcja konfiguracji zostanie zserializowana dla wszystkich wersji platformy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework określania elementów docelowych dla projektów sieci Web</related>
      </Docs>
    </Member>
  </Members>
</Type>

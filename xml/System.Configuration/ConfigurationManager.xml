<Type Name="ConfigurationManager" FullName="System.Configuration.ConfigurationManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="498b12805830f568d86400b697fb352f4e53056e" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55424047" /></Metadata><TypeSignature Language="C#" Value="public static class ConfigurationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ConfigurationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfigurationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationManager abstract sealed" />
  <TypeSignature Language="F#" Value="type ConfigurationManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp do plików konfiguracji dla aplikacji klienckich. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ConfigurationManager> Klasy umożliwia dostęp do komputera, aplikacji i informacje o konfiguracji użytkownika. Ta klasa zastępuje <xref:System.Configuration.ConfigurationSettings> klasy, która jest przestarzała. W przypadku aplikacji sieci web, użyj <xref:System.Web.Configuration.WebConfigurationManager> klasy.  
  
 Aby użyć <xref:System.Configuration.ConfigurationManager> klasy, Twój profil musi odwoływać `System.Configuration` zestawu. Domyślnie niektóre szablony projektu, takie jak aplikacja Konsolowa nie odwołuj się do tego zestawu, ręcznie musi odwoływać.  
  
> [!NOTE]
>  Nazwę i lokalizację pliku konfiguracji aplikacji są zależne od hosta aplikacji. Aby uzyskać więcej informacji, zobacz [NIB: Pliki konfiguracyjne aplikacji](https://msdn.microsoft.com/library/0d05b1b8-b18b-43d8-bb3c-526ff0c44fe0).  
  
 Można użyć wbudowanego <xref:System.Configuration> typów lub pochodzić od nich w celu obsługi informacji o konfiguracji. Korzystając z tych typów, można pracować bezpośrednio z informacji o konfiguracji i można rozszerzyć pliki konfiguracji w celu uwzględnienia niestandardowych informacji.  
  
 <xref:System.Configuration.ConfigurationManager> Klasa zawiera elementy członkowskie, które umożliwiają wykonywanie następujących zadań:  
  
-   Przeczytaj sekcję pliku konfiguracji. Aby uzyskać dostęp do informacji o konfiguracji, należy wywołać <xref:System.Configuration.ConfigurationManager.GetSection%2A> metody. Aby uzyskać niektóre sekcje, takie jak `appSettings` i `connectionStrings`, użyj <xref:System.Configuration.ConfigurationManager.AppSettings%2A> i <xref:System.Configuration.ConfigurationManager.ConnectionStrings%2A> klasy. Te elementy Członkowskie wykonania operacji tylko do odczytu, używać jednego wystąpienia pamięci podręcznej konfiguracji i są wielowątkowymi pamiętać.  
  
-   Odczytu i zapisu plików konfiguracyjnych jako całości. Aplikacja może odczytywać i zapisać ustawienia konfiguracji na dowolnym poziomie dla siebie lub innych aplikacji lub komputerach, lokalnie lub zdalnie. Użyj jednej z metod dostarczonych przez <xref:System.Configuration.ConfigurationManager> klasy można otworzyć pliku konfiguracji, takich jak SampleApp.exe.config. Te metody zwracają <xref:System.Configuration.Configuration> obiektu, który z kolei udostępnia metody i właściwości można użyć do pracy z plikami konfiguracji skojarzone. Metody wykonywania odczytu lub operacji zapisu i tworzyć dane konfiguracji, ilekroć dany plik jest zapisywany.  
  
-   Obsługuje zadania konfiguracji. Następujące typy są używane do obsługi różnych zadań konfiguracji:  
  
    -   <xref:System.Configuration.SectionInformation>  
  
    -   <xref:System.Configuration.PropertyInformation>  
  
    -   <xref:System.Configuration.PropertyInformationCollection>  
  
    -   <xref:System.Configuration.ElementInformation>  
  
    -   <xref:System.Configuration.ContextInformation>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroup>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroupCollection>  
  
     Oprócz pracy z istniejących informacji o konfiguracji, można tworzyć i pracować z elementami konfiguracji niestandardowej, rozszerzając typów wbudowanych konfiguracji, takich jak <xref:System.Configuration.ConfigurationElement>, <xref:System.Configuration.ConfigurationElementCollection>, <xref:System.Configuration.ConfigurationProperty>, i <xref:System.Configuration.ConfigurationSection> klasy. Na przykład sposobu rozszerzania typu, wbudowana Konfiguracja programowo zobacz <xref:System.Configuration.ConfigurationSection>. Na przykład jak rozszerzyć typ wbudowana konfiguracja, który używa modelu opartych na atrybutach zobacz <xref:System.Configuration.ConfigurationElement>.  
  
   
  
## Examples  
 Pierwszy przykład pokazuje prostej aplikacji konsolowej odczytuje ustawienia aplikacji, który dodaje nowe ustawienie i aktualizuje istniejące ustawienie.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 Poprzedni przykład założono, że projekt zawiera plik App.config, jak pokazano poniżej.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 Poniższy przykład pokazuje, jak odczytywać dane z bazy danych za pomocą parametrów połączenia.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 Poprzedni przykład założono, że projekt zawiera pliku App.config, jak pokazano poniżej.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Configuration.Configuration" /> Klasa umożliwia dostęp programowy do edycji plików konfiguracyjnych. Możesz użyć jednej z metod otwartego dostarczonych przez <see cref="T:System.Configuration.ConfigurationManager" />. Te metody zwracają <see cref="T:System.Configuration.Configuration" /> obiektu, który z kolei udostępnia wymaganych metod i właściwości w celu obsługi podstawowych plików konfiguracji. Możesz uzyskać dostęp do tych plików do odczytu lub zapisu.  
  
Do odczytywania plików konfiguracji, użyj <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> lub <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> można odczytać informacji o konfiguracji. Użytkownik lub proces, który odczytuje musi mieć następujące uprawnienia: 
-Uprawnienie do odczytu w pliku konfiguracji na bieżącym poziomie konfiguracji w hierarchii.  
  
— Uprawnienia do odczytu wszystkich nadrzędnego plików konfiguracyjnych.  
  
Jeśli aplikacja wymaga dostęp tylko do odczytu do jego własnej konfiguracji, firma Microsoft zaleca używanie <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> metody. Ta metoda zapewnia dostęp do wartości konfiguracji pamięci podręcznej dla bieżącej aplikacji, która ma lepszą wydajność niż <see cref="T:System.Configuration.Configuration" /> klasy.  
  
Aby zapisać pliki konfiguracji, użyj jednej z <see cref="Overload:System.Configuration.Configuration.Save" /> metody. Użytkownik lub proces, który zapisuje musi mieć następujące uprawnienia: 
-Zapisać uprawnienia w pliku konfiguracji i katalogu na bieżącym poziomie konfiguracji w hierarchii.  
  
-Uprawnień do odczytu do wszystkich plików konfiguracji.</para></block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
    <related type="Article" href="~/docs/framework/configure-apps/index.md">Pliki konfiguracji</related>
  </Docs>
  <Members>
    <Member MemberName="AppSettings">
      <MemberSignature Language="C#" Value="public static System.Collections.Specialized.NameValueCollection AppSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Specialized.NameValueCollection AppSettings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.AppSettings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AppSettings As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Specialized::NameValueCollection ^ AppSettings { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppSettings : System.Collections.Specialized.NameValueCollection" Usage="System.Configuration.ConfigurationManager.AppSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Configuration.AppSettingsSection" /> danych dla bieżącej aplikacji domyślnej konfiguracji.</summary>
        <value>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiekt, który zawiera zawartość <see cref="T:System.Configuration.AppSettingsSection" /> obiektu dla bieżącej aplikacji domyślnej konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Configuration.AppSettingsSection> obiekt zawiera zawartość pliku konfiguracji `appSettings` sekcji.  
  
   
  
## Examples  
 Pierwszy przykład pokazuje prostej aplikacji konsolowej odczytuje ustawienia aplikacji, który dodaje nowe ustawienie i aktualizuje istniejące ustawienie.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 Poprzedni przykład założono, że projekt zawiera plik App.config, jak pokazano poniżej.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można pobrać <see cref="T:System.Collections.Specialized.NameValueCollection" /> obiektu przy użyciu danych ustawień aplikacji.</exception>
        <altmember cref="T:System.Configuration.AppSettingsSection" />
        <altmember cref="T:System.Collections.Specialized.NameValueCollection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionStrings">
      <MemberSignature Language="C#" Value="public static System.Configuration.ConnectionStringSettingsCollection ConnectionStrings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Configuration.ConnectionStringSettingsCollection ConnectionStrings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ConnectionStrings As ConnectionStringSettingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Configuration::ConnectionStringSettingsCollection ^ ConnectionStrings { System::Configuration::ConnectionStringSettingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionStrings : System.Configuration.ConnectionStringSettingsCollection" Usage="System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConnectionStringSettingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Configuration.ConnectionStringsSection" /> danych dla bieżącej aplikacji domyślnej konfiguracji.</summary>
        <value>A <see cref="T:System.Configuration.ConnectionStringSettingsCollection" /> obiekt, który zawiera zawartość <see cref="T:System.Configuration.ConnectionStringsSection" /> obiektu dla bieżącej aplikacji domyślnej konfiguracji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Configuration.ConnectionStringsSection> obiekt zawiera zawartość pliku konfiguracji `connectionStrings` sekcji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odczytywać dane z bazy danych za pomocą parametrów połączenia.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 Poprzedni przykład założono, że projekt zawiera pliku App.config, jak pokazano poniżej.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można pobrać <see cref="T:System.Configuration.ConnectionStringSettingsCollection" /> obiektu.</exception>
        <altmember cref="T:System.Configuration.ConnectionStringsSection" />
        <altmember cref="T:System.Configuration.ConnectionStringSettingsCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public static object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member GetSection : string -&gt; obj" Usage="System.Configuration.ConfigurationManager.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Ścieżka do sekcji konfiguracji i nazwa. Nazwy węzłów są oddzielone od ukośnika, na przykład "system.net/mailSettings/smtp".</param>
        <summary>Pobiera sekcję konfiguracji określony dla bieżącej aplikacji domyślnej konfiguracji.</summary>
        <returns>Określony <see cref="T:System.Configuration.ConfigurationSection" /> obiektu lub <see langword="null" /> Jeśli sekcja nie istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla aplikacji klienckich ta metoda umożliwia pobranie pliku konfiguracji, uzyskaną przez scalanie pliku konfiguracji aplikacji, plik konfiguracyjny użytkownika lokalnego i mobilnego pliku konfiguracji.  
  
 <xref:System.Configuration.ConfigurationManager.GetSection%2A> Metoda uzyskuje dostęp do informacji o nie może zmieniać konfiguracji czasu wykonywania. Aby zmienić konfigurację, należy użyć <xref:System.Configuration.Configuration.GetSection%2A> metody w pliku konfiguracji, którą można uzyskać przy użyciu jednej z poniższych metod Otwórz:  
  
-   <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Configuration.ConfigurationManager.GetSection%2A> metody. Przykład jest częścią większego przykładu, który jest udostępniany dla <xref:System.Configuration.ConfigurationManager> klasy.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <block subset="none" type="overrides"><para>Należy rzutować wartości zwróconej na typ oczekiwany konfiguracji. Aby uniknąć możliwych rzutowania wyjątki, należy użyć operacji rzutowania warunkowego takiego jak <see langword="as" /> operatora w języku C# lub funkcji w języku Visual Basic.</para></block>
        <altmember cref="T:System.Configuration.ConfigurationSection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik konfiguracji określonego klienta jako <see cref="T:System.Configuration.Configuration" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration userLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="userLevel"><see cref="T:System.Configuration.ConfigurationUserLevel" /> Otwieranym konfiguracji.</param>
        <summary>Otwiera plik konfiguracyjny dla bieżącej aplikacji jako <see cref="T:System.Configuration.Configuration" /> obiektu.</summary>
        <returns>Element <see cref="T:System.Configuration.Configuration" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje klienckie Użyj konfigurację globalną, która ma zastosowanie do wszystkich użytkowników, oddzielne konfiguracje, które są stosowane do poszczególnych użytkowników i konfiguracje, które są stosowane do użytkowników mobilnych. `userLevel` Parametr określa lokalizację pliku konfiguracji, które są otwarte, wskazując, czy zawiera on żaden poziom użytkownika (plik konfiguracji znajduje się w tym samym katalogu co aplikacja) lub ma poziom na użytkownika (plik konfiguracji znajduje się w Ustawienia ścieżka aplikacji z poziomem użytkownika).  
  
 Określ, która Konfiguracja do pobrania przez przekazanie jedną z następujących wartości `userLevel`:  
  
-   Aby uzyskać <xref:System.Configuration.Configuration> obiekt, który ma zastosowanie do wszystkich użytkowników, ustawić `userLevel` do <xref:System.Configuration.ConfigurationUserLevel.None>.  
  
-   Aby uzyskać lokalnej <xref:System.Configuration.Configuration> obiekt, który ma zastosowanie do bieżącego użytkownika, ustaw `userLevel` do <xref:System.Configuration.ConfigurationUserLevel.PerUserRoamingAndLocal>.  
  
-   Aby uzyskać mobilnego <xref:System.Configuration.Configuration> obiekt, który ma zastosowanie do bieżącego użytkownika, ustaw `userLevel` do <xref:System.Configuration.ConfigurationUserLevel.PerUserRoaming>.  
  
    > [!NOTE]
    >  Aby uzyskać <xref:System.Configuration.Configuration> obiektu dla zasobu, kod musi mieć uprawnienia do odczytu dla wszystkich plików konfiguracji, po których dziedziczy ustawienia. Aby zaktualizować plik konfiguracji, Twój kod dodatkowo musi mieć uprawnienia do zapisu dla pliku konfiguracji i katalog, w której istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A> metody.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#5)]
 [!code-vb[System.Configuration.ConfigurationManager#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (string exePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(string exePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (exePath As String) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::String ^ exePath);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : string -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration exePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exePath">Ścieżka pliku wykonywalnego (exe).</param>
        <summary>Otwiera plik konfiguracji określonego klienta jako <see cref="T:System.Configuration.Configuration" /> obiektu.</summary>
        <returns>Element <see cref="T:System.Configuration.Configuration" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje klienckie Użyj konfigurację globalną, która ma zastosowanie do wszystkich użytkowników, oddzielne konfiguracje, które są stosowane do poszczególnych użytkowników i konfiguracje, które są stosowane do użytkowników mobilnych. `userLevel` Wartość określa lokalizację pliku konfiguracji jest otwarty. Oznacza to, czy ma ona żaden poziom użytkownika (plik konfiguracji znajduje się w tym samym katalogu co aplikacja) lub ma poziom na użytkownika (plik konfiguracji znajduje się w ścieżce Ustawienia aplikacji określana przez typ poziomu użytkownika).  
  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%28System.Configuration.ExeConfigurationFileMap%2CSystem.Configuration.ConfigurationUserLevel%2CSystem.Boolean%29> przeciążenia z `preLoad` parametr `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A> metody.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#6)]
 [!code-vb[System.Configuration.ConfigurationManager#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMachineConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMachineConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMachineConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMachineConfiguration () As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMachineConfiguration();" />
      <MemberSignature Language="F#" Value="static member OpenMachineConfiguration : unit -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMachineConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Otwiera plik konfiguracji na bieżącym komputerze jako <see cref="T:System.Configuration.Configuration" /> obiektu.</summary>
        <returns>Element <see cref="T:System.Configuration.Configuration" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia konfiguracji maszyny dotyczą całego komputera i wszystkie aplikacje, które znajdują się na ich temat, chyba że zastąpione dla aplikacji lokalnych. Ustawienia konfiguracji maszyny są odczytywane z pliku Machine.config aktualnie uruchomionej wersji .NET Framework. Plik Machine.config znajduje się w podkatalogu następujące:  
  
 *%windir%* \Microsoft.NET\Framework\\*version*\config  
  
> [!NOTE]
>  Aby uzyskać <xref:System.Configuration.Configuration> obiektu dla zasobu, kod musi mieć uprawnienia do odczytu dla wszystkich plików konfiguracji, po których dziedziczy ustawienia. Aby zaktualizować plik konfiguracji, Twój kod dodatkowo musi mieć uprawnienia do zapisu dla pliku konfiguracji i katalog, w której istnieje. Nie jest możliwe uzyskanie dostępu do pliku Machine.config w przypadku innych wersji systemu .NET Framework, które może być zainstalowane na komputerze.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A> metodę, aby uzyskać wszystkie sekcje, które są zawarte w pliku konfiguracji.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenMappedExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik konfiguracji określonego klienta jako <see cref="T:System.Configuration.Configuration" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="fileMap"><see cref="T:System.Configuration.ExeConfigurationFileMap" /> Obiektu, który odwołuje się do pliku konfiguracji zamiast domyślny plik konfiguracji aplikacji.</param>
        <param name="userLevel"><see cref="T:System.Configuration.ConfigurationUserLevel" /> Obiektu, dla którego jest otwierane konfiguracji.</param>
        <summary>Otwiera plik konfiguracji określonego klienta jako <see cref="T:System.Configuration.Configuration" /> obiekt, który korzysta z poziomu określonego pliku mapowania i użytkownika.</summary>
        <returns>Obiekt konfiguracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ConfigurationUserLevel> Obiektu określa lokalizację pliku konfiguracji jest otwarty. Oznacza to, czy plik ma żaden poziom użytkownika (plik konfiguracji znajduje się w tym samym katalogu co aplikacja) lub ma poziom na użytkownika (plik konfiguracji znajduje się w ścieżce Ustawienia aplikacji określone przez `userLevel`).  
  
> [!NOTE]
>  Aby uzyskać <xref:System.Configuration.Configuration> obiektu dla zasobu, kod musi mieć uprawnienia do odczytu dla wszystkich plików konfiguracji, po których dziedziczy ustawienia. Aby zaktualizować plik konfiguracji, Twój kod dodatkowo musi mieć uprawnienia do zapisu dla pliku konfiguracji i katalog, w której istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> metodę, aby uzyskać wszystkie sekcje, które są zawarte w pliku konfiguracyjnym.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#9)]
 [!code-vb[System.Configuration.ConfigurationManager#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel, bool preLoad) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel, preLoad As Boolean) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel * bool -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel, preLoad)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preLoad" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileMap"><see cref="T:System.Configuration.ExeConfigurationFileMap" /> Obiektu, który odwołuje się do pliku konfiguracji zamiast domyślny plik konfiguracji aplikacji.</param>
        <param name="userLevel"><see cref="T:System.Configuration.ConfigurationUserLevel" /> Obiektu, dla którego jest otwierane konfiguracji.</param>
        <param name="preLoad"><see langword="true" /> do wstępnego wszystkich grup sekcji i sekcji; w przeciwnym razie <see langword="false" />.</param>
        <summary>Otwiera plik konfiguracji określonego klienta jako <see cref="T:System.Configuration.Configuration" /> obiektu, który używa określonego pliku mapowania, na poziomie użytkownika i wstępnego ładowania opcji.</summary>
        <returns>Obiekt konfiguracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ConfigurationUserLevel> Obiektu określa lokalizację pliku konfiguracji, który jest otwierany. Oznacza to, czy plik ma żaden poziom użytkownika (plik konfiguracji znajduje się w tym samym katalogu co aplikacja) lub ma poziom na użytkownika (plik konfiguracji znajduje się w ścieżce Ustawienia aplikacji określone przez `userLevel`).  
  
> [!NOTE]
>  Aby uzyskać <xref:System.Configuration.Configuration> obiektu dla zasobu, kod musi mieć uprawnienia do odczytu dla wszystkich plików konfiguracji, po których dziedziczy ustawienia. Aby zaktualizować plik konfiguracji, Twój kod dodatkowo musi mieć uprawnienia do zapisu dla pliku konfiguracji i katalog, w której istnieje.  
  
 Dla przykładu kodu zobacz <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenMappedMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedMachineConfiguration (System.Configuration.ConfigurationFileMap fileMap);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedMachineConfiguration(class System.Configuration.ConfigurationFileMap fileMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration(System.Configuration.ConfigurationFileMap)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedMachineConfiguration (fileMap As ConfigurationFileMap) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedMachineConfiguration(System::Configuration::ConfigurationFileMap ^ fileMap);" />
      <MemberSignature Language="F#" Value="static member OpenMappedMachineConfiguration : System.Configuration.ConfigurationFileMap -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration fileMap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ConfigurationFileMap" />
      </Parameters>
      <Docs>
        <param name="fileMap"><see cref="T:System.Configuration.ExeConfigurationFileMap" /> Obiektu, który odwołuje się do pliku konfiguracji zamiast domyślny plik konfiguracji aplikacji.</param>
        <summary>Otwiera plik konfiguracji komputera jako <see cref="T:System.Configuration.Configuration" /> obiektu, który używa określonego pliku mapowania.</summary>
        <returns>Element <see cref="T:System.Configuration.Configuration" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienia konfiguracji maszyny dotyczą całego komputera i wszystkie aplikacje, które znajdują się na ich temat, chyba że zastąpione dla aplikacji lokalnych. Ustawienia konfiguracji maszyny są odczytywane z pliku Machine.config aktualnie uruchomionej wersji .NET Framework. Plik Machine.config znajduje się w podkatalogu następujące:  
  
 *%windir%* \Microsoft.NET\Framework\\*version*\config  
  
> [!NOTE]
>  Aby uzyskać <xref:System.Configuration.Configuration> obiektu dla zasobu, kod musi mieć uprawnienia do odczytu dla wszystkich plików konfiguracji, po których dziedziczy ustawienia. Aby zaktualizować plik konfiguracji, Twój kod dodatkowo musi mieć uprawnienia do zapisu dla pliku konfiguracji i katalog, w której istnieje. Nie jest możliwe uzyskanie dostępu do pliku Machine.config w przypadku innych wersji systemu .NET Framework, które może być zainstalowane na komputerze.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration%2A> metodę, aby uzyskać wszystkie sekcje w pliku konfiguracji.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Nie można załadować pliku konfiguracji.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
        <altmember cref="T:System.Configuration.ConfigurationFileMap" />
      </Docs>
    </Member>
    <Member MemberName="RefreshSection">
      <MemberSignature Language="C#" Value="public static void RefreshSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RefreshSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.RefreshSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RefreshSection (sectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RefreshSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member RefreshSection : string -&gt; unit" Usage="System.Configuration.ConfigurationManager.RefreshSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Nazwa sekcji konfiguracji lub nazwa sekcji i ścieżki konfiguracji sekcji, aby odświeżyć.</param>
        <summary>Odświeża nazwanej sekcji, dzięki czemu przy następnym uruchomieniu wartość jest pobierana będzie ponownie odczytywana z dysku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda unieważnia zawartość pamięci podręcznej dla sekcji konfiguracyjnej określony bez wywierania wpływu na inne sekcje.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Configuration.ConfigurationManager.RefreshSection%2A> metodę, aby odświeżyć sekcji konfiguracji ustawień aplikacji.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
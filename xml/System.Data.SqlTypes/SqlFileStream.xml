<Type Name="SqlFileStream" FullName="System.Data.SqlTypes.SqlFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c2bc99b8bb259ca56602c73c9c6c541064fabece" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37671457" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlFileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlFileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlTypes.SqlFileStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlFileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlFileStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type SqlFileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia dane programu SQL Server są przechowywane przy użyciu atrybut FILESTREAM kolumny jako sekwencja bajtów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlTypes.SqlFileStream> Klasa jest używana do pracy z `varbinary(max)` — dane przechowywane z atrybutem FILESTREAM w bazie danych programu SQL Server 2008. Należy zainstalować .NET Framework 3.5 z dodatkiem SP1 (lub nowszym) do użycia <xref:System.Data.SqlTypes.SqlFileStream> do pracy z danymi FILESTREAM.  
  
 Określanie FILESTREAM atrybutu na `varbinary(max)` kolumny powoduje, że program SQL Server do przechowywania danych w lokalnego systemu plików NTFS zamiast w pliku bazy danych. Instrukcje języka Transact-SQL zapewniają możliwości manipulacji danych na serwerze i interfejsów systemu plików Win32 zapewniają przesyłania strumieniowego dostęp do danych.  
  
> [!NOTE]
>  Poszczególne pliki przechowywane w kolumnie FILESTREAM nie można otworzyć bezpośrednio z systemu plików NTFS. Przesyłanie strumieniowe danych FILESTREAM działa tylko w kontekście transakcji programu SQL Server.  
  
 <xref:System.Data.SqlTypes.SqlFileStream> Klasa pochodzi od <xref:System.IO.Stream> klasy, która reprezentuje klasą abstrakcyjną sekwencji bajtów z określonego źródła dowolne dane, takie jak plik lub bloku pamięci. Może odczytywać FILESTREAM za transfer danych ze strumienia do struktury danych, takich jak tablica bajtów. Możesz zapisywać FILESTREAM przez przeniesienie danych ze strukturą danych w strumieniu. Może także starać się w usłudze stream, co pozwala na zapytania i modyfikację danych w bieżącej pozycji w strumieniu.  
  
 Dokumentacja koncepcyjna i przykłady kodu, zobacz [danych FILESTREAM](~/docs/framework/data/adonet/sql/filestream-data.md).  
  
 Dokumentacja dotyczące instalowania i konfigurowania danych FILESTREAM w programie SQL Server, zobacz [projektowanie i implementowanie magazynowania FILESTREAM](http://go.microsoft.com/fwlink/?LinkId=121499) w dokumentacji programu SQL Server 2008 — książki Online.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli wymieniono uprawnienia zabezpieczenia dostępu kodu, które musi zawierać wszystkie obiekty wywołujące w stosie, aby użyć `SqlFileStream` konstruktorów.  
  
|Dostęp do plików|Uprawnienie|  
|-----------------|----------------|  
|Odczyt|<xref:System.Security.Permissions.FileIOPermissionAccess.Read>|  
|Write|<xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
|Odczytu i zapisu|<xref:System.Security.Permissions.FileIOPermissionAccess.Read> i <xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
  
 Aby uzyskać więcej informacji o urzędach certyfikacji, zobacz [zabezpieczenia dostępu kodu i ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Logiczne ścieżkę do pliku. Ścieżki mogą być pobierane za pomocą funkcji Pathname języka Transact-SQL na podstawie podstawowej kolumny FILESTREAM w tabeli.</param>
        <param name="transactionContext">Kontekst transakcji dla <see langword="SqlFileStream" /> obiektu. Aplikacje, powinna zwrócić tablica bajtów zwrócona przez wywołanie metody funkcji GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Tryb dostępu do użycia podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileAccess" /> wartości wyliczenia są <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, i <see cref="F:System.IO.FileAccess.ReadWrite" />.  Korzystając z <see langword="FileAccess.Read" />, <see langword="SqlFileStream" /> obiekt może służyć do odczytu wszystkich istniejących danych.  Korzystając z <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> wskazuje plik zero bajtów. Istniejące dane zostaną zastąpione, gdy obiekt jest zamknięty, a transakcja została zatwierdzona.  Korzystając z <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> wskazuje plik, który zawiera wszystkie istniejące dane. Dojście jest umieszczony na początku pliku. Możesz użyć jednej z <see langword="System.IO" /><see langword="Seek" /> metody w celu jego uchwyt położenia w pliku Aby zapisać lub Dołącz nowe dane.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wyjątek jest generowany, transakcji otwartych powinien wycofana. W przeciwnym razie może wystąpić utrata danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest odwołaniem o wartości null lub <paramref name="transactionContext" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
 <paramref name="path" /> rozpoczyna się od "\\\\.\\", na przykład"\\\\. \PHYSICALDRIVE0".  Uchwyt zwracany przez wywołanie NTCreateFile nie jest typu FILE_TYPE_DISK.  
  
 <paramref name="options" /> zawiera nieobsługiwaną wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony <paramref name="path" /> jest nieprawidłowy, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dostęp do żądanego nie jest dozwolona przez system operacyjny dla określonej ścieżki. Dzieje się tak, gdy dostęp do zapisu lub odczytu i zapisu jest określona, a plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile kończy się niepowodzeniem z kodem błędu równa ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access, System.IO.FileOptions options, long allocationSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access, valuetype System.IO.FileOptions options, int64 allocationSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess, options As FileOptions, allocationSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access, System::IO::FileOptions options, long allocationSize);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess * System.IO.FileOptions * int64 -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access, options, allocationSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="allocationSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Logiczne ścieżkę do pliku. Ścieżki mogą być pobierane za pomocą funkcji Pathname języka Transact-SQL na podstawie podstawowej kolumny FILESTREAM w tabeli.</param>
        <param name="transactionContext">Kontekst transakcji dla <see langword="SqlFileStream" /> obiektu. Jeśli ustawiona na wartość null, transakcji niejawnej stosowanych w odniesieniu do <see langword="SqlFileStream" /> obiektu. Aplikacje, powinna zwrócić tablica bajtów zwrócona przez wywołanie metody funkcji GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Tryb dostępu do użycia podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileAccess" /> wartości wyliczenia są <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, i <see cref="F:System.IO.FileAccess.ReadWrite" />.  Korzystając z <see langword="FileAccess.Read" />, <see langword="SqlFileStream" /> obiekt może służyć do odczytu wszystkich istniejących danych.  Korzystając z <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> wskazuje plik zero bajtów. Istniejące dane zostaną zastąpione, gdy obiekt jest zamknięty, a transakcja została zatwierdzona.  Korzystając z <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> wskazuje plik, który zawiera wszystkie istniejące dane. Dojście jest umieszczony na początku pliku. Możesz użyć jednej z <see langword="System.IO" /><see langword="Seek" /> metody w celu jego uchwyt położenia w pliku Aby zapisać lub Dołącz nowe dane.</param>
        <param name="options">Określa opcje do użycia podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileOptions" /> wartości są <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" />, i <see cref="F:System.IO.FileOptions.RandomAccess" />.</param>
        <param name="allocationSize">Rozmiar alokacji do użycia podczas tworzenia pliku. Jeśli ustawiono wartość 0, wartością domyślną jest używany.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wyjątek jest generowany, transakcji otwartych powinien wycofana. W przeciwnym razie może wystąpić utrata danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest odwołaniem o wartości null lub <paramref name="transactionContext" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> jest pustym ciągiem (""), zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
 <paramref name="path" /> rozpoczyna się od "\\\\.\\", na przykład"\\\\. \PHYSICALDRIVE0".  Uchwyt zwracany przez wywołanie NTCreateFile nie jest typu FILE_TYPE_DISK.  
  
 <paramref name="options" /> zawiera nieobsługiwaną wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony <paramref name="path" /> jest nieprawidłowy, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dostęp do żądanego nie jest dozwolona przez system operacyjny dla określonej ścieżki. Dzieje się tak, gdy dostęp do zapisu lub odczytu i zapisu jest określona, a plik lub katalog jest ustawiony na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile kończy się niepowodzeniem z kodem błędu równa ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie w bajtach w <c>buforu</c> od którego należy rozpocząć pisanie dane odczytane ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana, gdy odczytu zostało zakończone.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to asynchroniczne żądanie odczytu od innych żądań</param>
        <summary>Rozpoczyna operację odczytu asynchronicznego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący odczyt asynchroniczny, co może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje Odczyt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Odczytywanie danych nie jest obsługiwana w strumieniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do zapisywania danych z.</param>
        <param name="offset">Przesunięcie w bajtach w <c>buforu</c> z której ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, wywoływana po zakończeniu zapisu.</param>
        <param name="state">Obiekt dostarczony przez użytkownika, który odróżnia to żądanie określonego asynchroniczny zapis od innych żądań.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący asynchronicznego zapisu, co może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zapisywanie danych nie jest obsługiwana w strumieniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje Odczyt.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje Odczyt; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje wyszukiwanie.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje wyszukiwanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień może limit czasu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień może limitu czasu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapis.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje pisanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sqlFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sqlFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego, aby zakończyć.</param>
        <summary>Czeka, aż oczekujące odczyt asynchroniczny zakończyć.</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, między zero (0) i liczbę bajtów, której szukasz. Strumienie zwracają wartość zero (0) tylko na końcu strumienia, w przeciwnym razie należy zablokować do czasu udostępnienia co najmniej jednego bajtu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.IAsyncResult" /> Obiekt nie pochodzi od odpowiadających im <see langword="BeginRead" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sqlFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do zaległe asynchroniczne żądanie operacji We/Wy.</param>
        <summary>Kończy operację asynchronicznego zapisu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.IAsyncResult" /> Obiekt nie pochodzi od odpowiadających im <see langword="BeginWrite" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SqlFileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SqlFileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="sqlFileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zasoby są zwalniane, a inne operacje oczyszczania są wykonywane, gdy moduł odśmiecania pamięci odzyskuje <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sqlFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie bufory tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w odpowiednie urządzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, długość bieżącej strumienia w bajtach.</summary>
        <value>
          <see cref="T:System.Int64" /> Wskazujący długość bieżącego strumienia, w bajtach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę logiczną <see cref="T:System.Data.SqlTypes.SqlFileStream" /> przekazany do konstruktora.</summary>
        <value>Wartość ciągu wskazujące nazwę <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie w obrębie bieżącego strumienia.</summary>
        <value>Bieżąca pozycja w ciągu <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sqlFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Po powrocie z tej metody buforu zawiera określonej tablicy bajtów przy użyciu wartości przesunięcia lub (przesunięcie + liczba — 1) zastąpione przez Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Zerze przesunięcie w buforze, od którego należy zacząć, zapisując dane odczytu z bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytu z bieżącego strumienia.</param>
        <summary>Odczytuje sekwencji bajtów bieżącego strumienia i przesuwa do przodu pozycję w strumieniu przez liczbę odczytanych bajtów.</summary>
        <returns>Całkowita liczba bajtów odczytanych w buforze. Może to być mniejsza niż żądana liczba bajtów Jeśli czy liczby bajtów nie są obecnie dostępne lub zero (0), jeśli został osiągnięty koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="sqlFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajtów ze strumienia i przesuwa do przodu pozycję w strumieniu przez jeden bajt albo zwraca wartość -1, jeśli komputer znajduje się na końcu strumienia.</summary>
        <returns>Bajtów bez znaku rzutować <see cref="T:System.Int32" />, lub wartość -1, jeśli komputer znajduje się na końcu strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje Odczyt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość w milisekundach, które określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość, w milisekundach, który określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sqlFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie bajtów, względem <c>pochodzenia</c> parametru</param>
        <param name="origin">Wartości typu <see cref="T:System.IO.SeekOrigin" /> wskazujące punkt odniesienia używany do uzyskania nowego położenia</param>
        <summary>Ustawia położenie w obrębie bieżącego strumienia.</summary>
        <returns>Nowa pozycja w ciągu bieżącego strumienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sqlFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wymagana długość bieżącego strumienia, w bajtach.</param>
        <summary>Ustawia długość bieżącego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje Odczyt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionContext">
      <MemberSignature Language="C#" Value="public byte[] TransactionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] TransactionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionContext As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ TransactionContext { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionContext : byte[]" Usage="System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst transakcji dla tego <see cref="T:System.Data.SqlTypes.SqlFileStream" /> obiektu.</summary>
        <value>
          <paramref name="transactionContext" /> Tablicy, który został przekazany do konstruktora dla tego <see cref="T:System.Data.SqlTypes.SqlFileStream" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sqlFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Ta metoda kopiuje <c>liczba</c> bajtów z <c>buforu</c> do bieżącego strumienia.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> od którego należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Liczba bajtów do zapisania bieżącego strumienia.</param>
        <summary>Zapisuje sekwencję bajtów w strumieniu bieżącego i bieżącą pozycję w tym strumieniu jest przesuwany o liczba zapisanych bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje zapisywania danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="sqlFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisu do strumienia.</param>
        <summary>Zapisuje bajt bieżącą pozycję w strumieniu i przesuwa do przodu pozycję w strumieniu przez jednego bajtu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje zapisywania danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość w milisekundach, które określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość, w milisekundach, który określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
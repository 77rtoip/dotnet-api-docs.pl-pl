<Type Name="SqlFileStream" FullName="System.Data.SqlTypes.SqlFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0516599dd46f28677cc07a02600fa694df7bf95a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30446604" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlFileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlFileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlTypes.SqlFileStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlFileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlFileStream sealed : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Przedstawia przechowywanych mających atrybut FILESTREAM kolumny jako sekwencję bajtów danych programu SQL Server.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.SqlTypes.SqlFileStream> Klasa jest używana do pracy z `varbinary(max)` dane przechowywane przez atrybut FILESTREAM w bazie danych programu SQL Server 2008. .NET Framework 3.5 z dodatkiem SP1 należy zainstalować (lub nowsza) do użycia <xref:System.Data.SqlTypes.SqlFileStream> do pracy z danymi FILESTREAM.  
  
 Określanie FILESTREAM atrybutu `varbinary(max)` kolumny powoduje, że serwer SQL do przechowywania danych w lokalnego systemu plików NTFS zamiast w pliku bazy danych. Instrukcji języka Transact-SQL zapewniają możliwości manipulacji danych w ramach serwera, i interfejsy systemu Win32 pliku zapewnia przesyłania strumieniowego dostępu do danych.  
  
> [!NOTE]
>  Nie można otworzyć poszczególnych plików przechowywanych w kolumnie FILESTREAM bezpośrednio z systemu plików NTFS. Przesyłanie strumieniowe danych FILESTREAM działa tylko w kontekście transakcji programu SQL Server.  
  
 <xref:System.Data.SqlTypes.SqlFileStream> Jest pochodną klasy <xref:System.IO.Stream> klasy, która reprezentuje abstrakcję sekwencję bajtów z określonego źródła dowolne dane, takie jak plik lub bloku pamięci. Można odczytywać strumień pliku przez przeniesienie danych ze strumienia do struktury danych, takich jak tablicę bajtów. Możesz zapisywać do FILESTREAM przez przeniesienie danych ze strukturą danych w strumieniu. Możesz również można wyszukiwać w strumieniu, co pozwala na zapytania i modyfikować danych w bieżącym położeniu w strumieniu.  
  
 Dokumentacja koncepcyjna i przykłady kodu, zobacz [danych FILESTREAM](~/docs/framework/data/adonet/sql/filestream-data.md).  
  
 Dokumentacja i konfigurowania danych FILESTREAM w programie SQL Server, zobacz [projektowanie i implementowanie magazynowania FILESTREAM](http://go.microsoft.com/fwlink/?LinkId=121499) w dokumentacji SQL Server 2008 — książki Online.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono uprawnienia zabezpieczeń (CAS) dostępu kodu, które wszystkim zainteresowanym w stosie musi być konieczne użycie `SqlFileStream` konstruktorów.  
  
|Dostęp do plików|Uprawnienie|  
|-----------------|----------------|  
|Odczyt|<xref:System.Security.Permissions.FileIOPermissionAccess.Read>|  
|Write|<xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
|ReadWrite|<xref:System.Security.Permissions.FileIOPermissionAccess.Read> I <xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
  
 Aby uzyskać więcej informacji o urzędach certyfikacji, zobacz [zabezpieczenia dostępu kodu i ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka logiczna do pliku. Ścieżka może zostać pobrany za pomocą funkcji Pathname języka Transact-SQL w kolumnie FILESTREAM podstawowych w tabeli.</param>
        <param name="transactionContext">Kontekst transakcji dla <see langword="SqlFileStream" /> obiektu. Aplikacje powinny zwracać tablica bajtów zwrócona przez wywołanie metody funkcji GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Tryb dostępu do używania podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileAccess" /> wartości wyliczenia są <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, i <see cref="F:System.IO.FileAccess.ReadWrite" />.  
  
 Korzystając z <see langword="FileAccess.Read" />, <see langword="SqlFileStream" /> obiekt może służyć do odczytu wszystkich istniejących danych.  
  
 Korzystając z <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> wskazuje plik zero bajtów. Istniejące dane zostaną zastąpione, gdy obiekt jest zamknięty, a transakcja została przekazana.  
  
 Korzystając z <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> wskazuje plik, którego wszystkie istniejące dane w nim. Dojście znajduje się na początku pliku. Można użyć jednej z <see langword="System.IO" /><see langword="Seek" /> metody przeniesienia pozycji dojście w pliku do zapisu lub dołączenie nowych danych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wyjątek transakcji otwartych powinien cofnięta. W przeciwnym razie może wystąpić utrata danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> to odwołanie o wartości null, lub <paramref name="transactionContext" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
 <paramref name="path" /> rozpoczyna się od ciągu "\\\\.\\", na przykład"\\\\. \PHYSICALDRIVE0".  
  
 Zwracane przez wywołanie NTCreateFile dojście nie jest typu FILE_TYPE_DISK.  
  
 <paramref name="options" /> zawiera nieobsługiwaną wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony <paramref name="path" /> jest nieprawidłowy, takie jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany dostęp nie jest dozwolona przez system operacyjny dla określonej ścieżki. Dzieje się tak, gdy dostęp do zapisu lub odczytu i zapisu jest określona, a plik lub katalog jest ustawiona na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile kończy się niepowodzeniem z kodem błędu ustawioną ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access, System.IO.FileOptions options, long allocationSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access, valuetype System.IO.FileOptions options, int64 allocationSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess, options As FileOptions, allocationSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access, System::IO::FileOptions options, long allocationSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="allocationSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka logiczna do pliku. Ścieżka może zostać pobrany za pomocą funkcji Pathname języka Transact-SQL w kolumnie FILESTREAM podstawowych w tabeli.</param>
        <param name="transactionContext">Kontekst transakcji dla <see langword="SqlFileStream" /> obiektu. Gdy ustawiona na wartość null, transakcji niejawnej będzie służyć do <see langword="SqlFileStream" /> obiektu. Aplikacje powinny zwracać tablica bajtów zwrócona przez wywołanie metody funkcji GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">Tryb dostępu do używania podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileAccess" /> wartości wyliczenia są <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, i <see cref="F:System.IO.FileAccess.ReadWrite" />.  
  
 Korzystając z <see langword="FileAccess.Read" />, <see langword="SqlFileStream" /> obiekt może służyć do odczytu wszystkich istniejących danych.  
  
 Korzystając z <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> wskazuje plik zero bajtów. Istniejące dane zostaną zastąpione, gdy obiekt jest zamknięty, a transakcja została przekazana.  
  
 Korzystając z <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> wskazuje plik, którego wszystkie istniejące dane w nim. Dojście znajduje się na początku pliku. Można użyć jednej z <see langword="System.IO" /><see langword="Seek" /> metody przeniesienia pozycji dojście w pliku do zapisu lub dołączenie nowych danych.</param>
        <param name="options">Określa opcje do używania podczas otwierania pliku. Obsługiwane <see cref="T:System.IO.FileOptions" /> wartości są <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" />, i <see cref="F:System.IO.FileOptions.RandomAccess" />.</param>
        <param name="allocationSize">Rozmiar alokacji, które będą używane podczas tworzenia pliku. Jeśli używane jest ustawiona na 0, wartością domyślną.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.SqlTypes.SqlFileStream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wyjątek transakcji otwartych powinien cofnięta. W przeciwnym razie może wystąpić utrata danych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> to odwołanie o wartości null, lub <paramref name="transactionContext" /> ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> to ciąg pusty (""), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.  
  
 <paramref name="path" /> rozpoczyna się od ciągu "\\\\.\\", na przykład"\\\\. \PHYSICALDRIVE0".  
  
 Zwracane przez wywołanie NTCreateFile dojście nie jest typu FILE_TYPE_DISK.  
  
 <paramref name="options" /> zawiera nieobsługiwaną wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony <paramref name="path" /> jest nieprawidłowy, takie jak w mapowany dysk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Żądany dostęp nie jest dozwolona przez system operacyjny dla określonej ścieżki. Dzieje się tak, gdy dostęp do zapisu lub odczytu i zapisu jest określona, a plik lub katalog jest ustawiona na dostęp tylko do odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile kończy się niepowodzeniem z kodem błędu ustawioną ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> jaką rozpocząć pisanie dane odczytane ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu odczytu.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań</param>
        <summary>Rozpoczyna operację asynchroniczną odczytu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący asynchroniczny odczyt, który może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Odczytywanie danych nie jest obsługiwany w strumieniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisywania danych z.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> z której ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący zapis asynchroniczny, który może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Zapisywanie danych nie jest obsługiwany w strumieniu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje Odczyt; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji wyszukiwania.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje operacji wyszukiwania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień może upłynął limit czasu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień może upłynął limit czasu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący strumień obsługuje zapis; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchroniczne, aby zakończyć.</param>
        <summary>Czeka na oczekujące odczyt asynchroniczny zakończyć.</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, między (0) i liczba bajtów, żądana. Strumienie zwrócił zero (0) tylko na końcu strumienia, w przeciwnym razie należy zablokować, dopóki nie będzie dostępne co najmniej jednego bajtu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.IAsyncResult" /> Obiekt nie pochodzi z odpowiedniej <see langword="BeginRead" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy operację asynchronicznego zapisu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.IAsyncResult" /> Obiekt nie pochodzi z odpowiedniej <see langword="BeginWrite" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SqlFileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SqlFileStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, długość w bajtach bieżący strumień.</summary>
        <value>
          <see cref="T:System.Int64" /> Wskazującym długość w bajtach bieżący strumień.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę logiczną <see cref="T:System.Data.SqlTypes.SqlFileStream" /> przekazany do konstruktora.</summary>
        <value>Wartość ciągu wskazujące nazwę <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pozycję w ramach bieżącego strumienia.</summary>
        <value>Bieżąca pozycja w <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Po powrocie z tej metody bufor zawiera określonej tablicy bajtów z wartości przesunięcia i (przesunięcie + liczba - 1) zastępuje Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Odczytać zerze przesunięcie w buforze, od którego ma zostać rozpoczęta, przechowywanie danych z bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów, które mają być odczytane z bieżącego strumienia.</param>
        <summary>Odczytuje sekwencję bajtów ze strumienia bieżącego i zmienia pozycję w strumieniu przez liczbę bajtów odczytanych.</summary>
        <returns>Całkowita liczba bajtów odczytanych w buforze. Może to być mniejsza niż żądana liczba bajtów Jeśli wiele bajtów nie są obecnie dostępne, czy zero (0), jeśli został osiągnięty koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajtów ze strumienia i zmienia pozycję w strumieniu przez jednego bajtu lub zwraca wartość -1, jeśli na koniec strumienia.</summary>
        <returns>Rzutować bajtu bez znaku <see cref="T:System.Int32" />, lub wartość -1, jeśli na koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, w milisekundach, które określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość, w milisekundach, który określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie bajtów, względem <c>pochodzenia</c> parametru</param>
        <param name="origin">Wartości typu <see cref="T:System.IO.SeekOrigin" /> wskazujący punkt odniesienia używany do uzyskania nowego położenia</param>
        <summary>Ustawia położenie w obrębie bieżącego strumienia.</summary>
        <returns>Nowa pozycja w ramach bieżącego strumienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wymagana długość w bajtach bieżący strumień.</param>
        <summary>Ustawia długość bieżącego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje odczytu danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionContext">
      <MemberSignature Language="C#" Value="public byte[] TransactionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] TransactionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionContext As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ TransactionContext { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst transakcji dla tego <see cref="T:System.Data.SqlTypes.SqlFileStream" /> obiektu.</summary>
        <value>
          <paramref name="transactionContext" /> Tablicy, który został przekazany do konstruktora dla tego <see cref="T:System.Data.SqlTypes.SqlFileStream" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Ta metoda umożliwia skopiowanie <c>liczba</c> bajtów z <c>buforu</c> do bieżącego strumienia.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> jaką należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Liczba bajtów do zapisania bieżącego strumienia.</param>
        <summary>Zapisuje sekwencję bajtów do bieżącego strumienia i przechodzi przez liczba zapisanych bajtów bieżącą pozycję w tym strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje zapisywania danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisania w strumieniu.</param>
        <summary>Zapisuje bieżącą pozycję w strumieniu bajt i zmienia pozycję w strumieniu przez jednego bajtu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt nie obsługuje zapisywania danych.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, w milisekundach, które określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość, w milisekundach, który określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
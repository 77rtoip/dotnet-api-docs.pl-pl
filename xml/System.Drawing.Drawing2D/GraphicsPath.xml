<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata><Meta Name="ms.openlocfilehash" Value="09ff9fdc49146379087c70b61a84e3348f410789" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69249727" /></Metadata><TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="F#" Value="type GraphicsPath = class&#xA;    inherit MarshalByRefObject&#xA;    interface ICloneable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje serię połączonych linii i krzywych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje używają ścieżek do rysowania konturów kształtów, wypełnienia wnętrza kształtów i tworzenia regionów przycinających. Silnik grafiki zachowuje współrzędne kształtów geometrycznych w ścieżce na świecie współrzędnych.  
  
 Ścieżka może składać się z dowolnej liczby cyfr (ścieżki podrzędne). Każda z nich składa się z sekwencji połączonych linii i krzywych lub pierwotnego kształtu geometrycznego. Punkt początkowy rysunku to pierwszy punkt w sekwencji połączonych linii i krzywych. Punkt końcowy jest ostatnim punktem w sekwencji. Początkowe i końcowe punkty podstawowego kształtu geometrycznego są definiowane przez specyfikację pierwotną.  
  
 Rysunek, który składa się z sekwencji połączonych linii i krzywych (których punkty początkowe i końcowe mogą być pokrywane) jest otwartym rysunkiem, chyba że zostanie jawnie zamknięty. Rysunek można jawnie zamknąć przy użyciu <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> metody, która zamknie bieżącą figurę, łącząc wiersz od punktu końcowego z punktem początkowym. Ilustracja, która składa się z elementu podstawowego kształtu geometrycznego, jest figurą zamkniętą.  
  
 W celach wypełniania i przycinania (na przykład jeśli ścieżka jest renderowana przy <xref:System.Drawing.Graphics.FillPath%2A>użyciu) wszystkie otwarte figury są zamykane przez dodanie linii od pierwszego punktu na rysunku do ostatniego punktu.  
  
 Nowy rysunek jest niejawnie uruchamiany, gdy ścieżka zostanie utworzona lub gdy rysunek zostanie zamknięty. Nowy rysunek jest jawnie tworzony, <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> gdy wywoływana jest metoda.  
  
 Gdy element podstawowy kształtu geometrycznego zostanie dodany do ścieżki, dodaje rysunek zawierający kształt geometryczny, a także niejawnie uruchamia nowy rysunek. W związku z tym w ścieżce jest zawsze obecny rysunek. Gdy linie i krzywe są dodawane do ścieżki, niejawna linia jest dodawana w razie potrzeby w celu połączenia punktu końcowego bieżącego rysunku z punktem początkowym nowych linii i krzywych w celu utworzenia sekwencji połączonych linii i krzywych.  
  
 Rysunek ma kierunek, który opisuje sposób, w jaki segmenty linii i krzywych są śledzone między punktem początkowym a punktem końcowym. Kierunek jest definiowany w kolejności, w jakiej linie i krzywe są dodawane do rysunku lub jest zdefiniowany przez element podstawowy kształtu geometrycznego. Kierunek jest używany podczas określania wewnętrznych ścieżek dla wycinków i wypełnienia.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f16ec921-56cf-46d1-9741-d7316ad06b23">Konstruowanie i rysowanie ścieżek</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy <see cref="T:System.Drawing.Drawing2D.FillMode" /> z wyliczeniem <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> z wartością <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath fillMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">Wyliczenie określające sposób wypełnienia wnętrza tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu. <see cref="T:System.Drawing.Drawing2D.FillMode" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczeniem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, która definiuje współrzędne punktów, które składają się na to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementów wyliczenia, która określa typ każdego odpowiadającego punktu <paramref name="pts" /> w tablicy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonymi <see cref="T:System.Drawing.Drawing2D.PathPointType" /> tablicami i <see cref="T:System.Drawing.Point" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która definiuje współrzędne punktów, które składają się na to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementów wyliczenia, która określa typ każdego odpowiadającego punktu <paramref name="pts" /> w tablicy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicy z określonymi <see cref="T:System.Drawing.Drawing2D.PathPointType" /> tablicami i <see cref="T:System.Drawing.PointF" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, która definiuje współrzędne punktów, które składają się na to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementów wyliczenia, która określa typ każdego odpowiadającego punktu <paramref name="pts" /> w tablicy.</param>
        <param name="fillMode">Wyliczenie określające, w jaki sposób są wypełniane Wewnętrzne kształty <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w tym elemencie. <see cref="T:System.Drawing.Drawing2D.FillMode" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy <see cref="T:System.Drawing.Point" /> z określonymi <see cref="T:System.Drawing.Drawing2D.PathPointType" /> tablicami i z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementem wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która definiuje współrzędne punktów, które składają się na to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementów wyliczenia, która określa typ każdego odpowiadającego punktu <paramref name="pts" /> w tablicy.</param>
        <param name="fillMode">Wyliczenie określające, w jaki sposób są wypełniane Wewnętrzne kształty <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w tym elemencie. <see cref="T:System.Drawing.Drawing2D.FillMode" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicy <see cref="T:System.Drawing.PointF" /> z określonymi <see cref="T:System.Drawing.Drawing2D.PathPointType" /> tablicami i z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementem wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza Łuk eliptyczny do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje prostokątne granice wielokropka, z którego jest pobierany łuk.</param>
        <param name="startAngle">Kąt początkowy łuku (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem łuku.</param>
        <summary>Dołącza Łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, do początku łuku zostanie dodany wiersz służący do łączenia punktu końcowego poprzedniego segmentu.  
  
 Łuk jest śledzony wzdłuż obwodu elipsy, która jest powiązana z określonym prostokątem. Punkt początkowy łuku jest określany przez zmierzenie w prawo od osi x elipsy (o kącie o wartości 0 stopni) przez liczbę stopni w kącie początkowym. Punkt końcowy jest analogiczny do pomiaru w prawo od punktu początkowego przez liczbę stopni w kącie odchylenia. Jeśli kąt odchylenia jest większy niż 360 stopni lub mniejszy niż-360 stopni, łuk jest wyczyszczony przez dokładnie 360 stopni lub-360 stopni.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt, od którego jest zdefiniowany łuk.  
  
-   Tworzy ścieżkę `myPath`.  
  
-   Definiuje 180-stopniowy Łuk eliptyczny, który jest wyczyszczony od 0 stopni do 180 stopni i dołącza go do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" /> Reprezentuje prostokątne granice wielokropka, z którego jest pobierany łuk.</param>
        <param name="startAngle">Kąt początkowy łuku (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem łuku.</param>
        <summary>Dołącza Łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, do początku łuku zostanie dodany wiersz służący do łączenia punktu końcowego poprzedniego segmentu.  
  
 Łuk jest śledzony wzdłuż obwodu elipsy, która jest powiązana z określonym prostokątem. Punkt początkowy łuku jest określany przez zmierzenie w prawo od osi x elipsy (o kącie o wartości 0 stopni) przez liczbę stopni w kącie początkowym. Punkt końcowy jest analogiczny do pomiaru w prawo od punktu początkowego przez liczbę stopni w kącie odchylenia. Jeśli kąt odchylenia jest większy niż 360 stopni lub mniejszy niż-360 stopni, łuk jest wyczyszczony przez dokładnie 360 stopni lub-360 stopni.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokątnego obszaru, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokątnego obszaru, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="width">Szerokość prostokątnego regionu, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="height">Wysokość prostokątnego regionu, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="startAngle">Kąt początkowy łuku (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem łuku.</param>
        <summary>Dołącza Łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, do początku łuku zostanie dodany wiersz służący do łączenia punktu końcowego poprzedniego segmentu.  
  
 Łuk jest śledzony wzdłuż obwodu elipsy, która jest powiązana z określonym prostokątem. Punkt początkowy łuku jest określany przez zmierzenie w prawo od osi x elipsy (o kącie o wartości 0 stopni) przez liczbę stopni w kącie początkowym. Punkt końcowy jest analogiczny do pomiaru w prawo od punktu początkowego przez liczbę stopni w kącie odchylenia. Jeśli kąt odchylenia jest większy niż 360 stopni lub mniejszy niż-360 stopni, łuk jest wyczyszczony przez dokładnie 360 stopni lub-360 stopni.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokątnego obszaru, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokątnego obszaru, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="width">Szerokość prostokątnego regionu, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="height">Wysokość prostokątnego regionu, który definiuje elipsę, z której jest rysowany łuk.</param>
        <param name="startAngle">Kąt początkowy łuku (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem łuku.</param>
        <summary>Dołącza Łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, do początku łuku zostanie dodany wiersz służący do łączenia punktu końcowego poprzedniego segmentu.  
  
 Łuk jest śledzony wzdłuż obwodu elipsy, która jest powiązana z określonym prostokątem. Punkt początkowy łuku jest określany przez zmierzenie w prawo od osi x elipsy (o kącie o wartości 0 stopni) przez liczbę stopni w kącie początkowym. Punkt końcowy jest analogiczny do pomiaru w prawo od punktu początkowego przez liczbę stopni w kącie odchylenia. Jeśli kąt odchylenia jest większy niż 360 stopni lub mniejszy niż-360 stopni, łuk jest wyczyszczony przez dokładnie 360 stopni lub-360 stopni.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje krzywą Beziera sześcienną do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt początkowy krzywej.</param>
        <param name="pt2"><see cref="T:System.Drawing.Point" /> Reprezentujący pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3"><see cref="T:System.Drawing.Point" /> Reprezentuje drugi punkt kontroli dla krzywej.</param>
        <param name="pt4"><see cref="T:System.Drawing.Point" /> Reprezentuje punkt końcowy krzywej.</param>
        <summary>Dodaje krzywą Beziera sześcienną do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywa sześcienna jest tworzona od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych.  
  
 Jeśli na rysunku znajduje się poprzedni segment linii lub krzywej, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym krzywej sześciennej.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt początkowy krzywej.</param>
        <param name="pt2"><see cref="T:System.Drawing.PointF" /> Reprezentujący pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3"><see cref="T:System.Drawing.PointF" /> Reprezentuje drugi punkt kontroli dla krzywej.</param>
        <param name="pt4"><see cref="T:System.Drawing.PointF" /> Reprezentuje punkt końcowy krzywej.</param>
        <summary>Dodaje krzywą Beziera sześcienną do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywa sześcienna jest tworzona od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych.  
  
 Jeśli na rysunku znajduje się poprzedni segment linii lub krzywej, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym krzywej sześciennej.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : int * int * int * int * int * int * int * int -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszego punktu kontroli dla krzywej.</param>
        <param name="y2">Współrzędna y pierwszego punktu kontroli dla krzywej.</param>
        <param name="x3">Współrzędna x drugiego punktu kontroli dla krzywej.</param>
        <param name="y3">Współrzędna y drugiego punktu kontroli dla krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje krzywą Beziera sześcienną do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywa sześcienna jest tworzona od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych.  
  
 Jeśli na rysunku znajduje się poprzedni segment linii lub krzywej, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym krzywej sześciennej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje krzywą Beziera sześcienną zdefiniowaną przez punkty (50, 50), (70, 0), (100, 120) i (150, 50) do ścieżki.  
  
-   Zamyka krzywą.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : single * single * single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszego punktu kontroli dla krzywej.</param>
        <param name="y2">Współrzędna y pierwszego punktu kontroli dla krzywej.</param>
        <param name="x3">Współrzędna x drugiego punktu kontroli dla krzywej.</param>
        <param name="y3">Współrzędna y drugiego punktu kontroli dla krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje krzywą Beziera sześcienną do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywa sześcienna jest tworzona od pierwszego punktu do czwartego punktu przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych.  
  
 Jeśli na rysunku znajduje się poprzedni segment linii lub krzywej, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym krzywej sześciennej.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje sekwencję połączonych krzywych Beziera sześciennych do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje punkty, które definiują krzywe.</param>
        <summary>Dodaje sekwencję połączonych krzywych Beziera sześciennych do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punktów kontrolnych połączonej krzywej. Pierwsza krzywa jest tworzona od pierwszego punktu do czwartego punktu w `points` tablicy przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych. Oprócz punktu końcowego poprzedniej krzywej każda kolejna krzywa w sekwencji wymaga dokładnie trzech kolejnych punktów: następne dwa punkty w sekwencji są punktami kontrolnymi, a trzeci jest punktem końcowym dla dodanej krzywej.  
  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, linia jest dodawana do połączenia punktu końcowego poprzedniego segmentu z punktem początkowym pierwszej krzywej sześciennej w sekwencji.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę siedmiu punktów (reprezentującą dwie połączone krzywe Beziera).  
  
-   Tworzy ścieżkę i dodaje serię punktów krzywej Beziera do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje punkty, które definiują krzywe.</param>
        <summary>Dodaje sekwencję połączonych krzywych Beziera sześciennych do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punktów kontrolnych połączonej krzywej. Pierwsza krzywa jest tworzona od pierwszego punktu do czwartego punktu w `points` tablicy przy użyciu drugiego i trzeciego punktu jako punktów kontrolnych. Oprócz punktu końcowego poprzedniej krzywej każda kolejna krzywa w sekwencji wymaga dokładnie trzech kolejnych punktów: następne dwa punkty w sekwencji są punktami kontrolnymi, a trzeci jest punktem końcowym dla dodanej krzywej.  
  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, linia jest dodawana do połączenia punktu końcowego poprzedniego segmentu z punktem początkowym pierwszej krzywej sześciennej w sekwencji.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje zamkniętą krzywą do tej ścieżki. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <summary>Dodaje zamkniętą krzywą do tej ścieżki. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatni punkt w `points` tablicy nie są tym samym punktem, krzywa jest zamknięta przez połączenie tych dwóch punktów. Nie można ustawić wartości napięcia dla tej metody, a wartością domyślną jest wartość odpowiadająca 0,5.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <summary>Dodaje zamkniętą krzywą do tej ścieżki. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatni punkt w `points` tablicy nie są tym samym punktem, krzywa jest zamknięta przez połączenie tych dwóch punktów. Nie można ustawić wartości napięcia dla tej metody, a wartością domyślną jest wartość odpowiadająca 0,5.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="tension">Wartość z zakresu od 0 do 1, która określa wielkość krzywizny między punktami, a od 0 to najmniejsza krzywa (ostry róg) i 1 to gładka krzywa.</param>
        <summary>Dodaje zamkniętą krzywą do tej ścieżki. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatni punkt w `points` tablicy nie są tym samym punktem, krzywa jest zamknięta przez połączenie tych dwóch punktów.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę sześciu punktów (reprezentującą krzywą kardynalną).  
  
-   Tworzy ścieżkę i dodaje krzywe zamkniętej krzywej łamanej do ścieżki (zamknięte od punktu końcowego do punktu początkowego).  
  
-   Rysuje ścieżkę do ekranu.  
  
 Zwróć uwagę, że używane jest napięcie 0,5.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="tension">Wartość z zakresu od 0 do 1, która określa wielkość krzywizny między punktami, a od 0 to najmniejsza krzywa (ostry róg) i 1 to gładka krzywa.</param>
        <summary>Dodaje zamkniętą krzywą do tej ścieżki. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatni punkt w `points` tablicy nie są tym samym punktem, krzywa jest zamknięta przez połączenie tych dwóch punktów.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku. Krzywa krzywej łamanej kardynalnej jest używana, ponieważ krzywa jest przenoszona przez poszczególne punkty w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="tension">Wartość określająca ilość rozgięcia krzywej między punktami kontrolnymi. Wartości większe niż 1 dają nieprzewidywalne wyniki.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="tension">Wartość określająca ilość rozgięcia krzywej między punktami kontrolnymi. Wartości większe niż 1 dają nieprzewidywalne wyniki.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="offset">Indeks elementu w <paramref name="points" /> tablicy, który jest używany jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Wartość określająca ilość rozgięcia krzywej między punktami kontrolnymi. Wartości większe niż 1 dają nieprzewidywalne wyniki.</param>
        <param name="tension">Wartość określająca ilość rozgięcia krzywej między punktami kontrolnymi. Wartości większe niż 1 dają nieprzewidywalne wyniki.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
 Krzywa zaczyna się od punktu w tablicy określonej przez `offset` parametr i zawiera liczbę punktów (segmentów) określonych przez. `numberOfSegments`  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę czterech punktów (reprezentującą krzywą kardynalną).  
  
-   Tworzy ścieżkę i używa tablicy punktów, dodaje krzywą do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 Należy zauważyć, że podczas gdy tablica zawiera cztery punkty, istnieje tylko trzy segmenty, czyli liczba określona w trzecim argumencie wywołania <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która reprezentuje Punkty definiujące krzywą.</param>
        <param name="offset">Indeks elementu w <paramref name="points" /> tablicy, który jest używany jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Liczba segmentów używanych do rysowania krzywej. Segment może być uważany za linię łączącą dwa punkty.</param>
        <param name="tension">Wartość określająca ilość rozgięcia krzywej między punktami kontrolnymi. Wartości większe niż 1 dają nieprzewidywalne wyniki.</param>
        <summary>Dodaje krzywą krzywej łamanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
 Krzywa zaczyna się od punktu w tablicy określonej przez `offset`i zawiera liczbę punktów (segmentów) określonych przez. `numberOfSegments`  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje wielokropek do bieżącej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje prostokąt ograniczający, który definiuje elipsę.</param>
        <summary>Dodaje wielokropek do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
 Tworzy prostokąt ograniczający, który definiuje wielokropek.  
  
 Tworzy ścieżkę i dodaje elipsę do ścieżki.  
  
 Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" /> Reprezentuje prostokąt ograniczający, który definiuje elipsę.</param>
        <summary>Dodaje wielokropek do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : int * int * int * int -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokąta granicznego, który definiuje elipsę.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokąta granicznego, który definiuje elipsę.</param>
        <param name="width">Szerokość prostokąta obwiedni, który definiuje elipsę.</param>
        <param name="height">Wysokość prostokąta ograniczenia, który definiuje elipsę.</param>
        <summary>Dodaje wielokropek do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : single * single * single * single -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokąta granicznego, który definiuje elipsę.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokąta granicznego, który definiuje elipsę.</param>
        <param name="width">Szerokość prostokąta obwiedni, który definiuje elipsę.</param>
        <param name="height">Wysokość prostokąta ograniczenia, który definiuje elipsę.</param>
        <summary>Dodaje wielokropek do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />segment linii.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt początkowy wiersza.</param>
        <param name="pt2"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt końcowy wiersza.</param>
        <summary>Dołącza do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />segment linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje segment linii zdefiniowany w określonych punktach na końcu tego <xref:System.Drawing.Drawing2D.GraphicsPath>elementu. Jeśli istnieją poprzednie linie lub krzywe w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany w celu połączenia ostatniego punktu w ścieżce z pierwszym punktem w nowym segmencie wiersza.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt początkowy wiersza.</param>
        <param name="pt2"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt końcowy wiersza.</param>
        <summary>Dołącza do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />segment linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje segment linii zdefiniowany w określonych punktach na końcu tego <xref:System.Drawing.Drawing2D.GraphicsPath>elementu. Jeśli istnieją poprzednie linie lub krzywe w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany w celu połączenia ostatniego punktu w ścieżce z pierwszym punktem w nowym segmencie wiersza.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : int * int * int * int -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego wiersza.</param>
        <param name="y1">Współrzędna y punktu początkowego wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego wiersza.</param>
        <param name="y2">Współrzędna y punktu końcowego wiersza.</param>
        <summary>Dołącza segment linii do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje segment linii zdefiniowany przez określone punkty do końca bieżącego rysunku. Jeśli istnieją poprzednie linie lub krzywe w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany w celu połączenia ostatniego punktu w ścieżce z pierwszym punktem w nowym segmencie wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod tworzy ścieżkę, dodaje trzy wiersze, które tworzą trójkąt, a następnie rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : single * single * single * single -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego wiersza.</param>
        <param name="y1">Współrzędna y punktu początkowego wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego wiersza.</param>
        <param name="y2">Współrzędna y punktu końcowego wiersza.</param>
        <summary>Dołącza do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />segment linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje segment linii zdefiniowany w określonych punktach na końcu tego <xref:System.Drawing.Drawing2D.GraphicsPath>elementu. Jeśli istnieją poprzednie linie lub krzywe w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany w celu połączenia ostatniego punktu w ścieżce z pierwszym punktem w nowym segmencie wiersza.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza serię połączonych segmentów linii do końca tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur reprezentujących punkty, które definiują segmenty do dodania.</param>
        <summary>Dołącza serię połączonych segmentów linii do końca tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwa określają pierwszy wiersz. Każdy dodatkowy punkt określa punkt końcowy segmentu linii, którego punkt początkowy jest punktem końcowym poprzedniego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę czterech punktów, które opisują trójkąt.  
  
-   Tworzy ścieżkę i dodaje tablicę wierszy.  
  
-   Rysuje ścieżkę do ekranu.  
  
 Zauważ, że każdy wiersz po pierwszym punkcie używa poprzedniego punktu jako punktu początkowego i nowego punktu jako punktu końcowego.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur reprezentujących punkty, które definiują segmenty do dodania.</param>
        <summary>Dołącza serię połączonych segmentów linii do końca tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli na rysunku znajdują się poprzednie linie lub krzywe, zostanie dodany wiersz w celu połączenia punktu końcowego poprzedniego segmentu z punktem początkowym wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwa określają pierwszy wiersz. Każdy dodatkowy punkt określa punkt końcowy segmentu linii, którego punkt początkowy jest punktem końcowym poprzedniego wiersza.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberSignature Language="F#" Value="member this.AddPath : System.Drawing.Drawing2D.GraphicsPath * bool -&gt; unit" Usage="graphicsPath.AddPath (addingPath, connect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do dodania.</param>
        <param name="connect">Wartość logiczna określająca, czy pierwszy rysunek w dodanej ścieżce jest częścią ostatniego rysunku w tej ścieżce. Wartość <see langword="true" /> określa, że (jeśli to możliwe) pierwszy rysunek w dodanej ścieżce jest częścią ostatniego rysunku w tej ścieżce. Wartość <see langword="false" /> określa, że pierwszy rysunek w dodanej ścieżce jest oddzielony od ostatniego rysunku w tej ścieżce.</param>
        <summary>Dołącza określony <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy dwie ścieżki po prawej stronie, a drugi Trójkąt w górę.  
  
-   Dodaje drugą ścieżkę do pierwszej.  
  
-   Rysuje wynikową ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje kontur kształtu koła do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddPie (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje prostokąt ograniczający, który definiuje elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy części koła (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem sekcji koła (w stopniach), od <paramref name="startAngle" />.</param>
        <summary>Dodaje kontur kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła jest definiowany przez częściowy kontur wielokropka i dwa linie promieniowe przecinające punkty końcowe częściowego konspektu. Częściowe konspekt zaczyna się od `startAngle` (mierzone w prawo od osi x) i kończą się o `startAngle`  + . `sweepAngle`  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokąta, który definiuje elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokąta granicznego, który definiuje elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="width">Szerokość prostokąta ograniczenia definiująca elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="height">Wysokość prostokąta ograniczenia definiująca elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy części koła (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem sekcji koła (w stopniach), od <paramref name="startAngle" />.</param>
        <summary>Dodaje kontur kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła jest definiowany przez częściowy kontur wielokropka i dwa linie promieniowe przecinające punkty końcowe częściowego konspektu. Częściowe konspekt zaczyna się od `startAngle` (mierzone w prawo od osi x) i kończą się o `startAngle`  + . `sweepAngle`  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod tworzy ścieżkę grafiki, dodaje kształt koła, a następnie rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu prostokąta, który definiuje elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokąta granicznego, który definiuje elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="width">Szerokość prostokąta ograniczenia definiująca elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="height">Wysokość prostokąta ograniczenia definiująca elipsę, z której jest rysowany wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy części koła (w stopniach od prawej do osi x).</param>
        <param name="sweepAngle">Kąt między <paramref name="startAngle" /> i końcem sekcji koła (w stopniach), od <paramref name="startAngle" />.</param>
        <summary>Dodaje kontur kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła jest definiowany przez częściowy kontur wielokropka i dwa linie promieniowe przecinające punkty końcowe częściowego konspektu. Częściowe konspekt zaczyna się od `startAngle` (mierzone w prawo od osi x) i kończą się o `startAngle`  + . `sweepAngle`  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje wielokąt do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które definiują wielokąt do dodania.</param>
        <summary>Dodaje wielokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy określają wierzchołki wielokąta. Jeśli pierwszy punkt w tablicy nie jest taki sam jak ostatni punkt, te dwa punkty są połączone, aby zamknąć wielokąt.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę punktów, które definiują wielokąt.  
  
-   Tworzy ścieżkę i dodaje wielokąt do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują wielokąt do dodania.</param>
        <summary>Dodaje wielokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy określają wierzchołki wielokąta. Jeśli pierwszy punkt w tablicy nie jest taki sam jak ostatni punkt, te dwa punkty są połączone, aby zamknąć wielokąt.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> , Który reprezentuje prostokąt do dodania.</param>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy prostokąt i dodaje prostokąt do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" /> , Który reprezentuje prostokąt do dodania.</param>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje serię prostokątów do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.Rectangle[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.Rectangle" /> struktur, która reprezentuje prostokąty do dodania.</param>
        <summary>Dodaje serię prostokątów do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy tablicę prostokątów i dodaje prostokąty do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.RectangleF[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.RectangleF" /> struktur, która reprezentuje prostokąty do dodania.</param>
        <summary>Dodaje serię prostokątów do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Point * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Do dodania.</param>
        <param name="family"><see cref="T:System.Drawing.FontFamily" /> Reprezentuje nazwę czcionki, z którą jest rysowany test.</param>
        <param name="style"><see cref="T:System.Drawing.FontStyle" /> Wyliczenie, które reprezentuje informacje o stylu tekstu (pogrubiony, kursywa itd.). Ta wartość musi być rzutowana jako liczba całkowita (Zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość kwadratowego pola, które wiąże się z znakiem.</param>
        <param name="origin"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt, w którym zaczyna się tekst.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , która określa informacje o formatowaniu tekstu, takie jak odstępy między wierszami i wyrównanie.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Ustawia ciąg i argumenty czcionki.  
  
-   Dodaje ciąg do ścieżki.  
  
-   Rysuje ciąg na ekranie.  
  
 Istnieją dwie ważne rzeczy, które należy wyróżnić. Najpierw Zwróć uwagę, że `fontStyle` argument jest rzutowany jako liczbę całkowitą. Ta metoda wymaga, aby co <xref:System.Drawing.FontStyle> najmniej dwa elementy członkowskie mogły być połączone w celu utworzenia żądanego stylu czcionki <xref:System.Drawing.FontStyle.Italic> (w tym przypadku i <xref:System.Drawing.FontStyle.Underline>). <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> Następnie należy zauważyć, że <xref:System.Drawing.Graphics.FillPath%2A> Metoda jest używana zamiast <xref:System.Drawing.Graphics.DrawPath%2A> metody. Jeśli <xref:System.Drawing.Graphics.FillPath%2A> jest używany, pełny tekst jest renderowany, natomiast jeśli <xref:System.Drawing.Graphics.DrawPath%2A> jest używany, tekst będzie stylem konturu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Do dodania.</param>
        <param name="family"><see cref="T:System.Drawing.FontFamily" /> Reprezentuje nazwę czcionki, z którą jest rysowany test.</param>
        <param name="style"><see cref="T:System.Drawing.FontStyle" /> Wyliczenie, które reprezentuje informacje o stylu tekstu (pogrubiony, kursywa itd.). Ta wartość musi być rzutowana jako liczba całkowita (Zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość kwadratowego pola, które wiąże się z znakiem.</param>
        <param name="origin"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt, w którym zaczyna się tekst.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , która określa informacje o formatowaniu tekstu, takie jak odstępy między wierszami i wyrównanie.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Rectangle * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Do dodania.</param>
        <param name="family"><see cref="T:System.Drawing.FontFamily" /> Reprezentuje nazwę czcionki, z którą jest rysowany test.</param>
        <param name="style"><see cref="T:System.Drawing.FontStyle" /> Wyliczenie, które reprezentuje informacje o stylu tekstu (pogrubiony, kursywa itd.). Ta wartość musi być rzutowana jako liczba całkowita (Zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość kwadratowego pola, które wiąże się z znakiem.</param>
        <param name="layoutRect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje prostokąt, który jest powiązany z tekstem.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , która określa informacje o formatowaniu tekstu, takie jak odstępy między wierszami i wyrównanie.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Do dodania.</param>
        <param name="family"><see cref="T:System.Drawing.FontFamily" /> Reprezentuje nazwę czcionki, z którą jest rysowany test.</param>
        <param name="style"><see cref="T:System.Drawing.FontStyle" /> Wyliczenie, które reprezentuje informacje o stylu tekstu (pogrubiony, kursywa itd.). Ta wartość musi być rzutowana jako liczba całkowita (Zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość kwadratowego pola, które wiąże się z znakiem.</param>
        <param name="layoutRect"><see cref="T:System.Drawing.RectangleF" /> Reprezentuje prostokąt, który jest powiązany z tekstem.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , która określa informacje o formatowaniu tekstu, takie jak odstępy między wierszami i wyrównanie.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberSignature Language="F#" Value="member this.ClearMarkers : unit -&gt; unit" Usage="graphicsPath.ClearMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie znaczniki z tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> , aby utworzyć znacznik w bieżącej lokalizacji <xref:System.Drawing.Drawing2D.GraphicsPath>w. Użyj metody <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> , aby wykonać iterację istniejących znaczników w ścieżce.  
  
 Znaczniki są używane do oddzielania grup ścieżek. Co najmniej jedna ścieżka podrzędna może być zawarta między dwoma znacznikami.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka obiektów do ścieżki.  
  
-   Dodaje znaczniki do ścieżki.  
  
-   Czyści wszystkie znaczniki ze ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="graphicsPath.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy dokładną kopię tej ścieżki.</summary>
        <returns><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Ta metoda tworzy, Rzutowanie jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka cyfr do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
-   Klonuje kopię tej ścieżki.  
  
-   Rysuje nową ścieżkę do ekranu.  
  
 Należy zauważyć, że wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> metody musi być rzutowane <xref:System.Drawing.Drawing2D.GraphicsPath>jako.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberSignature Language="F#" Value="member this.CloseAllFigures : unit -&gt; unit" Usage="graphicsPath.CloseAllFigures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie otwarte figury w tej ścieżce i uruchamia nowy rysunek. Każdy otwarty rysunek jest zamykany przez połączenie linii z punktu końcowego do punktu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka otwartych figur do ścieżki.  
  
-   Zamyka wszystkie cyfry w ścieżce.  
  
-   Rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberSignature Language="F#" Value="member this.CloseFigure : unit -&gt; unit" Usage="graphicsPath.CloseFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżącą figurę i uruchamia nowy rysunek. Jeśli bieżący rysunek zawiera sekwencję połączonych linii i krzywych, Metoda zamyka pętlę, łącząc linię z punktu końcowego z punktem początkowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod tworzy Trójkąt, tworząc nową ścieżkę, rozpoczynając od rysunku, dodając dwa przecinające się linie do rysunku, a następnie zamykając rysunek w celu utworzenia trójkąta. Ścieżka jest następnie rysowana na ekranie.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphicsPath.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez ten <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> zezwala na przydzielenie zasobów używanych <xref:System.Drawing.Drawing2D.GraphicsPath> przez ten program do innych celów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberSignature Language="F#" Value="member this.FillMode : System.Drawing.Drawing2D.FillMode with get, set" Usage="System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Drawing.Drawing2D.FillMode" /> Wyliczenie określające sposób wypełnienia wnętrza kształtów w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elemencie.</summary>
        <value>Wyliczenie określające, w jaki sposób są wypełniane Wewnętrzne kształty <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w tym elemencie. <see cref="T:System.Drawing.Drawing2D.FillMode" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphicsPath.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektowi podjęcie próby zwolnienia zasobów i wykonywanie innych operacji czyszczenia przed odinstalowaniem ich przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje każdą krzywą w tej ścieżce na sekwencję segmentów połączonej linii.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberSignature Language="F#" Value="member this.Flatten : unit -&gt; unit" Usage="graphicsPath.Flatten " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje każdą krzywą w tej ścieżce na sekwencję segmentów połączonej linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Flatten matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , przez który należy przekształcić <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> ten element przed spłaszczeniem.</param>
        <summary>Stosuje określone przekształcenie, a następnie konwertuje każdą krzywą <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w ten sposób na sekwencję połączonych segmentów linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Flatten (matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , przez który należy przekształcić <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> ten element przed spłaszczeniem.</param>
        <param name="flatness">Określa maksymalny dozwolony błąd między krzywą i jego spłaszczoną harmonizacją. Wartość domyślna to 0,25. Zmniejszenie wartości zryczałtowanej spowoduje zwiększenie liczby segmentów linii w przybliżeniu.</param>
        <summary>Konwertuje każdą krzywą w <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> ten sposób na sekwencję segmentów połączonej linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę graficzną i tablicę translacji.  
  
-   Dodaje krzywą do ścieżki przy użyciu czterech punktów.  
  
-   Rysuje ścieżkę (krzywą) na ekranie przy użyciu czarnego pióra.  
  
-   Przesuwa krzywą w dół o 10 pikseli i spłaszcza ją.  
  
-   Rysuje krzywą na ekranie przy użyciu czerwonego pióra.  
  
 Zwróć uwagę, że Czerwona krzywa zawiera spłaszczone linie łączące punkty.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca prostokąt, który jest powiązany z <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />tym elementem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberSignature Language="F#" Value="member this.GetBounds : unit -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca prostokąt, który jest powiązany z <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />tym elementem.</summary>
        <returns>Reprezentuje prostokąt, który jest powiązany z tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elementem. <see cref="T:System.Drawing.RectangleF" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwracanego prostokąta ograniczającego ma wpływ na typ zakończenia, Szerokość pióra i próg ścięcia pióra. w związku z tym tworzy "luźne dopasowanie" do powiązanej ścieżki. Przybliżona formuła to: początkowy prostokąt ograniczający jest niepłaski według szerokości pióra, a wynik jest mnożony przez próg ścięcia, a dodatkowy margines umożliwiający zakończenie.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę grafiki.  
  
-   Dodaje do niego wielokropek (okrąg) i rysuje go na ekranie.  
  
-   Pobiera prostokąt obwiedni dla okręgu z wywołaniem <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> i rysuje prostokąt do ekranu.  
  
-   Tworzy drugą ścieżkę grafiki.  
  
-   Dodaje okrąg i poszerza ścieżkę do szerokości 10.  
  
-   Rysuje ścieżkę do ekranu.  
  
-   Pobiera prostokąt związany z drugim okręgiem.  
  
-   Rysuje prostokąt ograniczający do ekranu.  
  
-   Wyświetla rozmiar prostokąta w oknie dialogowym.  
  
 Zwróć uwagę, że prostokąt ograniczający po prawej stronie jest większy (w celu uwzględnienia dodatkowej szerokości linii).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Określa <see cref="T:System.Drawing.Drawing2D.Matrix" /> transformację, która ma zostać zastosowana do tej ścieżki przed obliczeniem prostokąta ograniczenia. Ta ścieżka nie jest trwale przekształcana; transformacja jest używana tylko podczas przetwarzania ograniczenia prostokąta.</param>
        <summary>Zwraca prostokąt, który jest powiązany z <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tą ścieżką, gdy ta ścieżka jest przekształcana <see cref="T:System.Drawing.Drawing2D.Matrix" />przez określony.</summary>
        <returns>Reprezentuje prostokąt, który jest powiązany z tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elementem. <see cref="T:System.Drawing.RectangleF" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwracanego prostokąta ograniczającego ma wpływ na typ zakończenia, Szerokość pióra i próg ścięcia pióra. w związku z tym tworzy "luźne dopasowanie" do powiązanej ścieżki. Przybliżona formuła to: początkowy prostokąt ograniczający jest niepłaski według szerokości pióra, a wynik jest mnożony przez próg ścięcia, a dodatkowy margines umożliwiający zakończenie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix * System.Drawing.Pen -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds (matrix, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">Określa <see cref="T:System.Drawing.Drawing2D.Matrix" /> transformację, która ma zostać zastosowana do tej ścieżki przed obliczeniem prostokąta ograniczenia. Ta ścieżka nie jest trwale przekształcana; transformacja jest używana tylko podczas przetwarzania ograniczenia prostokąta.</param>
        <param name="pen">, <see cref="T:System.Drawing.Pen" /> Z którym ma nastąpić <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />Rysowanie.</param>
        <summary>Zwraca prostokąt, który jest powiązany z <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tym, gdy bieżąca ścieżka jest przekształcana przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" /> i rysowany przy użyciu określonego <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Reprezentuje prostokąt, który jest powiązany z tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elementem. <see cref="T:System.Drawing.RectangleF" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwracanego prostokąta ograniczającego ma wpływ na typ zakończenia, Szerokość pióra i próg ścięcia pióra. w związku z tym tworzy "luźne dopasowanie" do powiązanej ścieżki. Przybliżona formuła to: początkowy prostokąt ograniczający jest niepłaski według szerokości pióra, a wynik jest mnożony przez próg ścięcia, a dodatkowy margines umożliwiający zakończenie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberSignature Language="F#" Value="member this.GetLastPoint : unit -&gt; System.Drawing.PointF" Usage="graphicsPath.GetLastPoint " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ostatni punkt w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> tablicy tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elementu.</summary>
        <returns>Reprezentuje ostatni punkt w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie. <see cref="T:System.Drawing.PointF" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod tworzy ścieżkę, dodaje linię do ścieżki, a następnie pobiera ostatni punkt w ścieżce.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu podczas rysowania z określonym. <see cref="T:System.Drawing.Pen" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.Point" /> Określa lokalizację do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu podczas rysowania z określonym. <see cref="T:System.Drawing.Pen" /></summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, <see langword="false" />gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.PointF" /> Określa lokalizację do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu podczas rysowania z określonym. <see cref="T:System.Drawing.Pen" /></summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, <see langword="false" />gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt"><see cref="T:System.Drawing.Point" /> Określa lokalizację do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" /> i używaniem <see cref="T:System.Drawing.Graphics" />określonego.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie. Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt"><see cref="T:System.Drawing.PointF" /> Określa lokalizację do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" /> i używaniem <see cref="T:System.Drawing.Graphics" />określonego.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> wartość, jeśli określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu jako rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie. Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu podczas rysowania z określonym. <see cref="T:System.Drawing.Pen" /></summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, <see langword="false" />gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu podczas rysowania z określonym. <see cref="T:System.Drawing.Pen" /></summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, <see langword="false" />gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" /> i używaniem <see cref="T:System.Drawing.Graphics" />określonego.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w konturze tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie. Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje prostokąt do ścieżki.  
  
-   Tworzy panoramiczne pióro i poszerza ścieżkę za pomocą tego pióra (aby przykład był wyraźniejszy),  
  
-   Testuje punkt (100, 50), aby zobaczyć, czy należy do jednej z krawędzi prostokąta przez wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 Wynik jest wyświetlany w oknie komunikatu (w tym przypadku true). Innymi słowy, krawędź jest renderowana nad tym punktem.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> Do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu, gdy jest rysowany z określonym <see cref="T:System.Drawing.Pen" /> i używaniem <see cref="T:System.Drawing.Graphics" />określonego.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> wartość, jeśli określony punkt jest zawarty w (w obszarze) kontur tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> elementu jako rysowany z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konspekt danej ścieżki jest renderowany jako widoczny w określonym punkcie. Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji parametru jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt"><see cref="T:System.Drawing.Point" /> Reprezentujący punkt do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji parametru jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt"><see cref="T:System.Drawing.PointF" /> Reprezentujący punkt do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym elemencie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji parametru jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsę do ścieżki.  
  
-   Testuje, czy określony punkt jest zawarty w ścieżce.  
  
-   Wyświetla wynik w oknie dialogowym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do przetestowania.</param>
        <param name="y">Współrzędna y punktu do przetestowania.</param>
        <param name="graphics"><see cref="T:System.Drawing.Graphics" /> Dla którego ma zostać przetestowana widoczność.</param>
        <summary>Wskazuje, czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> miejscu w widocznym regionie przycinania określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> czy określony punkt jest zawarty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />elemencie; w przeciwnym <see langword="false" />razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu do przetestowania są określone we współrzędnych świata. Macierz `graphics` transformacji parametru jest tymczasowo stosowana przed badaniem widoczności.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathData : System.Drawing.Drawing2D.PathData" Usage="System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt <see cref="T:System.Drawing.Drawing2D.PathData" /> , który hermetyzuje tablice punktów (<paramref name="points" />) i <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />typów (<paramref name="types" />).</summary>
        <value>Obiekt <see cref="T:System.Drawing.Drawing2D.PathData" /> , który hermetyzuje tablice dla obu tych punktów i typów <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathPoints : System.Drawing.PointF[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkty w ścieżce.</summary>
        <value>Tablica <see cref="T:System.Drawing.PointF" /> obiektów, która reprezentuje ścieżkę.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathTypes : byte[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy odpowiednich punktów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> tablicy.</summary>
        <value>Tablica bajtów, która określa typy odpowiednich punktów w ścieżce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica bajtów zwracana przez <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> Właściwość określa typy punktów i flagi dla punktów danych w ścieżce. Dla każdego punktu bity od 0 do 2 wskazują typ punktu, a bity od 3 do 7 przechowują zestaw flag, które określają atrybuty punktu. W poniższej tabeli przedstawiono możliwe wartości i ich znaczenie.  
  
|Wartość|Znaczenie|  
|-----------|-------------|  
|0|Wskazuje, że punkt jest początkiem rysunku.|  
|1|Wskazuje, że punkt jest jednym z dwóch punktów końcowych wiersza.|  
|3|Wskazuje, że punkt jest punktem końcowym lub punktem kontrolnym wielobezieraowej krzywej łamanej.|  
|0x7|Maskuje wszystkie bity z wyjątkiem trzech bitów o niskiej kolejności, które wskazują typ punktu.|  
|0x20|Określa, że punkt jest znacznikiem.|  
|0x80|Określa, że punkt jest ostatnim punktem w zamkniętej ścieżce podrzędnej (rysunek).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PointCount : int" Usage="System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy lub.</summary>
        <value>Liczba całkowita, która określa liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy lub.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="graphicsPath.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opróżnia tablice <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> iustawia<see cref="T:System.Drawing.Drawing2D.FillMode" /> do .<see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" /> <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje do niego kilka elementów podstawowych.  
  
-   Rysuje tablicę punktów ścieżki do ekranu.  
  
-   Resetuje ścieżkę do pustego stanu.  
  
-   Ponownie uzyskuje tablicę punktów (jeśli istnieje).  
  
-   Rysuje tablicę na ekranie.  
  
 Zauważ, że nie znaleziono żadnych tablic po wywołaniu resetowania.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="graphicsPath.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność punktów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> tablicy. <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje kilka elementów podstawowych do ścieżki.  
  
-   Rysuje tablicę punktów ścieżki do ekranu.  
  
-   Rysuje tablicę odwróconych punktów na ekranie.  
  
 Zwróć uwagę, że druga lista punktów jest w odwrotnej kolejności od pierwszej.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberSignature Language="F#" Value="member this.SetMarkers : unit -&gt; unit" Usage="graphicsPath.SetMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia znacznik na tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy znacznik na ścieżce, który może służyć do oddzielania sekcji ścieżki. Następnie można użyć <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> metod do iteracji znaczników w ścieżce.  
  
 Znaczniki są używane do oddzielania grup ścieżek. Co najmniej jedna ścieżka podrzędna może być zawarta między dwoma znacznikami w ścieżce.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod tworzy ścieżkę i dodaje kilka elementów podstawowych do ścieżki oddzielonej znakami i rysuje ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberSignature Language="F#" Value="member this.StartFigure : unit -&gt; unit" Usage="graphicsPath.StartFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia nowy rysunek bez zamykania bieżącego rysunku. Wszystkie kolejne punkty dodane do ścieżki są dodawane do tego nowego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest to konieczne, użytkownik musi pozostawić oryginalne punkty. Oryginalne punkty są konwertowane na punkty kontrolne Beziera sześcienne wewnętrznie, dlatego nie istnieje mechanizm zwracania oryginalnych punktów.  
  
 Ta metoda uruchamia nową ścieżkę podrzędną w ścieżce. Ścieżki podrzędne umożliwiają rozdzielenie ścieżki na sekcje i użycie <xref:System.Drawing.Drawing2D.GraphicsPathIterator> klasy do iteracji w ścieżkach.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje dwa zestawy ilustracji. Pierwszy zestaw cyfr łączy cztery elementy pierwotne w dwie cyfry. Drugi zestaw cyfr łączy te same cztery elementy pierwotne (z tą różnicą, że są przesunięte na oś y) na trzy cyfry.  
  
-   Rysuje wszystkie cyfry na ekranie.  
  
 Zwróć uwagę na różnice w wyglądzie między dwoma zestawami cyfr.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Transform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Reprezentujący transformację, która ma zostać zastosowana. <see cref="T:System.Drawing.Drawing2D.Matrix" /></param>
        <summary>Stosuje macierz transformacji do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja może skalować, przełożyć, obrócić lub pochylić <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsę do ścieżki.  
  
-   Rysuje ścieżkę do ekranu.  
  
-   Tworzy macierz transformacji, aby przetłumaczyć jednostki ścieżki 100 w kierunku osi x.  
  
-   Rysuje przekształconą ścieżkę do ekranu.  
  
 Zauważ, że oryginalna elipsa jest rysowana w kolorze czarnym, a przekształcony wielokropek jest rysowany w kolorze czerwonym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stosuje transformację osnowy, zdefiniowaną przez prostokąt i równoległobok do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok, do którego prostokąt zdefiniowany przez <paramref name="srcRect" /> jest przekształcony. Tablica może zawierać trzy lub cztery elementy. Jeśli tablica zawiera trzy elementy, prawy dolny róg równoległobok jest implikowany przez pierwsze trzy punkty.</param>
        <param name="srcRect">Reprezentuje prostokąt, który jest przekształcony w równoległobok zdefiniowany przez <paramref name="destPoints" />. <see cref="T:System.Drawing.RectangleF" /></param>
        <summary>Stosuje transformację osnowy, zdefiniowaną przez prostokąt i równoległobok do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok, do którego prostokąt zdefiniowany przez <paramref name="srcRect" /> jest przekształcony. Tablica może zawierać trzy lub cztery elementy. Jeśli tablica zawiera trzy elementy, prawy dolny róg równoległobok jest implikowany przez pierwsze trzy punkty.</param>
        <param name="srcRect">Reprezentuje prostokąt, który jest przekształcony w równoległobok zdefiniowany przez <paramref name="destPoints" />. <see cref="T:System.Drawing.RectangleF" /></param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , która określa przekształcenie geometryczne, które ma zostać zastosowane do ścieżki.</param>
        <summary>Stosuje transformację osnowy, zdefiniowaną przez prostokąt i równoległobok do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, która definiuje równoległobok, do którego prostokąt zdefiniowany przez <paramref name="srcRect" /> jest przekształcony. Tablica może zawierać trzy lub cztery elementy. Jeśli tablica zawiera trzy elementy, prawy dolny róg równoległobok jest implikowany przez pierwsze trzy punkty.</param>
        <param name="srcRect">Reprezentuje prostokąt, który jest przekształcony w równoległobok zdefiniowany przez <paramref name="destPoints" />. <see cref="T:System.Drawing.RectangleF" /></param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , która określa przekształcenie geometryczne, które ma zostać zastosowane do ścieżki.</param>
        <param name="warpMode"><see cref="T:System.Drawing.Drawing2D.WarpMode" /> Wyliczenie, które określa, czy ta operacja zniekształcania używa trybu perspektywicznego czy dwuliniowego.</param>
        <summary>Stosuje transformację osnowy, zdefiniowaną przez prostokąt i równoległobok do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode * single -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok, do którego prostokąt zdefiniowany przez <paramref name="srcRect" /> jest przekształcony. Tablica może zawierać trzy lub cztery elementy. Jeśli tablica zawiera trzy elementy, prawy dolny róg równoległobok jest implikowany przez pierwsze trzy punkty.</param>
        <param name="srcRect">Reprezentuje prostokąt, który jest przekształcony w równoległobok zdefiniowany przez <paramref name="destPoints" />. <see cref="T:System.Drawing.RectangleF" /></param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , która określa przekształcenie geometryczne, które ma zostać zastosowane do ścieżki.</param>
        <param name="warpMode"><see cref="T:System.Drawing.Drawing2D.WarpMode" /> Wyliczenie, które określa, czy ta operacja zniekształcania używa trybu perspektywicznego czy dwuliniowego.</param>
        <param name="flatness">Wartość od 0 do 1 określająca sposób płaskiej ścieżki. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> metody.</param>
        <summary>Stosuje transformację osnowy, zdefiniowaną przez prostokąt i równoległobok do tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje prostokąt do ścieżki.  
  
-   Rysuje ten prostokąt na czarnym ekranie.  
  
-   Osnowuje ścieżkę z wypaczeniem perspektywy.  
  
-   Rysuje wygięty prostokąt (ścieżkę) na czerwono.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje tę ścieżkę o krzywych otaczających obszar wypełniony, gdy ta ścieżka jest rysowana przez określone pióro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen -&gt; unit" Usage="graphicsPath.Widen pen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> Określa szerokość między oryginalnym konturem ścieżki i nowym konspektem tworzonym przez tę metodę.</param>
        <summary>Dodaje dodatkowy konspekt do ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>zakresie, z odległością między istniejącymi wierszami i nowym konturem równym szerokości <xref:System.Drawing.Pen> <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>użytej w wywołaniu. Jeśli chcesz wypełnić miejsce między wierszami, musisz użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast <xref:System.Drawing.Graphics.DrawPath%2A>tego.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Widen (pen, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> Określa szerokość między oryginalnym konturem ścieżki i nowym konspektem tworzonym przez tę metodę.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , która określa przekształcenie do zastosowania do ścieżki przed rozszerzaniem.</param>
        <summary>Dodaje dodatkowy konspekt do <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>zakresie, z odległością między istniejącymi wierszami i nowym konturem równym szerokości <xref:System.Drawing.Pen> <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>użytej w wywołaniu. Jeśli chcesz wypełnić miejsce między wierszami, musisz użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast <xref:System.Drawing.Graphics.DrawPath%2A>tego.  
  
   
  
## Examples  
 Aby zapoznać się z przykładem, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Widen (pen, matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> Określa szerokość między oryginalnym konturem ścieżki i nowym konspektem tworzonym przez tę metodę.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , która określa przekształcenie do zastosowania do ścieżki przed rozszerzaniem.</param>
        <param name="flatness">Wartość, która określa płaskość dla krzywych.</param>
        <summary>Zastępuje ten <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> element przy użyciu krzywych otaczających obszar wypełniony, gdy ta ścieżka jest rysowana przez określone pióro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>zakresie, z odległością między istniejącymi wierszami i nowym konturem równym szerokości <xref:System.Drawing.Pen> <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>użytej w wywołaniu. Jeśli chcesz wypełnić miejsce między wierszami, musisz użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast <xref:System.Drawing.Graphics.DrawPath%2A>tego.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e` <xref:System.Windows.Forms.Form.OnPaint%2A> obiektu zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje dwie wielokropek do ścieżki.  
  
-   Rysuje ścieżkę czarną.  
  
-   Rozszerza ścieżkę.  
  
-   Rysuje ścieżkę w kolorze czerwonym.  
  
 Należy zauważyć, że drugie renderowanie <xref:System.Drawing.Graphics.FillPath%2A> używa <xref:System.Drawing.Graphics.DrawPath%2A>zamiast, a tym samym wyrenderowany rysunek ma wypełnienie konspektu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

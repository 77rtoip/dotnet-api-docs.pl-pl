<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="010b867d0c50e186006fea90cdbc67fefd8cfd61" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30452739" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje szereg połączonych linii i krzywych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje użyć ścieżek narysować obramowanie kształtów wypełnienia wnętrza kształty i utworzyć regiony wycinka. Aparat grafiki zachowuje współrzędne geometrycznych kształtów w ścieżce w przestrzeni współrzędnych świata.  
  
 Ścieżka może się składać z dowolną liczbę wartości (podrzędne). Każdy rysunek albo składa się z sekwencji połączonych linii i krzywych lub kształtu geometrycznego pierwotnych. Punkt początkowy rysunku jest połączonych linii i krzywych pierwszego punktu w sekwencji. Punkt końcowy jest ostatniego punktu w sekwencji. Punkty początkowy i końcowy kształtu geometrycznego pierwotne są definiowane przez specyfikację pierwotnych.  
  
 Rysunek, która składa się z sekwencji połączone linie i krzywych (których punkty początkowy i końcowy może być pokrywających) jest otwartego rysunku, chyba że jawnie zamknięty. Ilustracja może zostać zamknięty, jawnie, przy użyciu <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> metodę, która powoduje zamknięcie bieżącego rysunek łącząc wiersz z punktu końcowego do punktu początkowego. Rysunek, składający się z właściwością pierwotną kształtu geometrycznego jest figurę zamkniętą.  
  
 W celu wypełnienia i wycinka (na przykład, jeśli ścieżka jest renderowany przy użyciu <xref:System.Drawing.Graphics.FillPath%2A>), wszystkie otwarte rysunki są zamknięte przez dodanie wiersza z pierwszym punktem rysunek do ostatniego punktu.  
  
 Rysunek nowych niejawnie została uruchomiona po utworzeniu ścieżki lub gdy rysunek jest zamknięty. Rysunek nowe jawnie jest tworzony podczas <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> metoda jest wywoływana.  
  
 Gdy kształtu geometrycznego pierwotnych zostanie dodany do ścieżki, dodaje rysunku zawierający kształtu geometrycznego i również niejawnie uruchamia nowe rysunku. W rezultacie jest zawsze bieżący rysunek w ścieżce. Kiedy linii i krzywych są dodawane do ścieżki, linia niejawne dodaje się wymagane do połączenia punktu końcowego rysunek bieżący punkt początkowy nowej linii i krzywych do utworzenia sekwencji połączone linie i krzywych.  
  
 Ilustracja ma kierunek, który opisuje, jak segmenty linii i krzywych są śledzone między punkt początkowy i punkt końcowy. Kierunek jest zdefiniowany w kolejności linii i krzywych są dodawane do rysunku lub jest definiowana za pomocą kształtu geometrycznego pierwotnych. Kierunek jest używany podczas określania wnętrza ścieżki przycinania i wypełnienia.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> wartość <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> Wyliczenia, która określa jak wewnętrzne tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> jest wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, które definiuje współrzędne punktów tworzących to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pts</c> tablicy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.Point" /> tablic.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiuje współrzędne punktów tworzących to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pts</c> tablicy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.PointF" /> tablic.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, które definiuje współrzędne punktów tworzących to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pts</c> tablicy.</param>
        <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia, która określa sposób wnętrza kształtów w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.Point" /> tablicami i z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementu wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiuje współrzędne punktów tworzących to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pts</c> tablicy.</param>
        <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia, która określa sposób wnętrza kształtów w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.PointF" /> tablicami i z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementu wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza łuku do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokątne granice elipsy, z którego jest pobierany łuk.</param>
        <param name="startAngle">Kąt początkowy łuk mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuk.</param>
        <summary>Dołącza łuku do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z początku łuk.  
  
 Łuk śledzonego wzdłuż obwodowej elipsy ograniczone przez określony prostokąta. Punkt początkowy łuku jest określana przez zmierzenie wskazówek zegara osi x elipsy (na 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc wskazówek zegara między punktem przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt, w którym zdefiniowano łuk.  
  
-   Tworzy ścieżkę `myPath`.  
  
-   Definiuje 180 stopni łuku wachlarzy od 0 stopni do 180 stopni i dołącza go do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokątne granice elipsy, z którego jest pobierany łuk.</param>
        <param name="startAngle">Kąt początkowy łuk mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuk.</param>
        <summary>Dołącza łuku do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z początku łuk.  
  
 Łuk śledzonego wzdłuż obwodowej elipsy ograniczone przez określony prostokąta. Punkt początkowy łuku jest określana przez zmierzenie wskazówek zegara osi x elipsy (na 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc wskazówek zegara między punktem przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="width">Szerokość prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="height">Wysokość prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="startAngle">Kąt początkowy łuk mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuk.</param>
        <summary>Dołącza łuku do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z początku łuk.  
  
 Łuk śledzonego wzdłuż obwodowej elipsy ograniczone przez określony prostokąta. Punkt początkowy łuku jest określana przez zmierzenie wskazówek zegara osi x elipsy (na 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc wskazówek zegara między punktem przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="width">Szerokość prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="height">Wysokość prostokątny obszar, który definiuje wielokropka, z którego łuku.</param>
        <param name="startAngle">Kąt początkowy łuk mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuk.</param>
        <summary>Dołącza łuku do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z początku łuk.  
  
 Łuk śledzonego wzdłuż obwodowej elipsy ograniczone przez określony prostokąta. Punkt początkowy łuku jest określana przez zmierzenie wskazówek zegara osi x elipsy (na 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc wskazówek zegara między punktem przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje sześcienny krzywej Beziera do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt początkowy krzywej.</param>
        <param name="pt2">A <see cref="T:System.Drawing.Point" /> reprezentujący pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3">A <see cref="T:System.Drawing.Point" /> reprezentujący drugi punkt kontrolny krzywej.</param>
        <param name="pt4">A <see cref="T:System.Drawing.Point" /> reprezentujący krzywej punktu końcowego.</param>
        <summary>Dodaje sześcienny krzywej Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzony z pierwszego punktu punkt czwarty przy użyciu punktów drugiego i trzeciego jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniego wiersza lub segmentu na ilustracji, wiersz jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt początkowy krzywej.</param>
        <param name="pt2">A <see cref="T:System.Drawing.PointF" /> reprezentujący pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3">A <see cref="T:System.Drawing.PointF" /> reprezentujący drugi punkt kontrolny krzywej.</param>
        <param name="pt4">A <see cref="T:System.Drawing.PointF" /> reprezentujący krzywej punktu końcowego.</param>
        <summary>Dodaje sześcienny krzywej Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzony z pierwszego punktu punkt czwarty przy użyciu punktów drugiego i trzeciego jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniego wiersza lub segmentu na ilustracji, wiersz jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszy punkt kontrolny krzywej.</param>
        <param name="y2">Współrzędna y pierwszy punkt kontrolny krzywej.</param>
        <param name="x3">Współrzędna x drugi punkt kontrolny krzywej.</param>
        <param name="y3">Współrzędna y drugi punkt kontrolny krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje sześcienny krzywej Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzony z pierwszego punktu punkt czwarty przy użyciu punktów drugiego i trzeciego jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniego wiersza lub segmentu na ilustracji, wiersz jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje sześcienny krzywej Beziera, zdefiniowany przez punkty (50, 50), (70, 0), (100, 120) i (150, 50) do ścieżki.  
  
-   Zamyka krzywej.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszy punkt kontrolny krzywej.</param>
        <param name="y2">Współrzędna y pierwszy punkt kontrolny krzywej.</param>
        <param name="x3">Współrzędna x drugi punkt kontrolny krzywej.</param>
        <param name="y3">Współrzędna y drugi punkt kontrolny krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje sześcienny krzywej Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzony z pierwszego punktu punkt czwarty przy użyciu punktów drugiego i trzeciego jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniego wiersza lub segmentu na ilustracji, wiersz jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje sekwencję połączonych sześcienny krzywych Beziera do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywych.</param>
        <summary>Dodaje sekwencję połączonych sześcienny krzywych Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punkty kontrolne krzywych połączonych. Pierwszy krzywej jest tworzony z pierwszego punktu czwarty punktu w `points` tablicy przy użyciu punktów drugiego i trzeciego jako punkty kontrolne. Oprócz punktu końcowego krzywej poprzedniej, każda kolejne krzywej w sekwencji musi dokładnie trzy więcej punktów: następne dwa punkty w sekwencji są punkty kontrolne, a trzeci jest punkt końcowy dla krzywej dodany.  
  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym pierwszego krzywą trzeciego stopnia w sekwencji.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę siedem punktów (dwie krzywe Beziera połączenia reprezentującą).  
  
-   Tworzy ścieżkę i dodaje serii punktów krzywej Beziera na ścieżkę.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywych.</param>
        <summary>Dodaje sekwencję połączonych sześcienny krzywych Beziera do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punkty kontrolne krzywych połączonych. Pierwszy krzywej jest tworzony z pierwszego punktu czwarty punktu w `points` tablicy przy użyciu punktów drugiego i trzeciego jako punkty kontrolne. Oprócz punktu końcowego krzywej poprzedniej, każda kolejne krzywej w sekwencji musi dokładnie trzy więcej punktów: następne dwa punkty w sekwencji są punkty kontrolne, a trzeci jest punkt końcowy dla krzywej dodany.  
  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do punktu końcowego poprzedniego segmentu nawiązać połączenia z punktem początkowym pierwszego krzywą trzeciego stopnia w sekwencji.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty. Wartość naprężenia nie można ustawić dla tej metody oraz wartości domyślnych do wartości odpowiednikiem 0,5.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty. Wartość naprężenia nie można ustawić dla tej metody oraz wartości domyślnych do wartości odpowiednikiem 0,5.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="tension">Wartość z zakresu od od 0 do 1, który określa, że krzywej załamania między punktami z 0 jest najmniejsza krzywej (róg najlepszą jakość obrazu), a 1 daje płynne krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę sześciu punktów (reprezentujący kardynalnej krzywej składanej).  
  
-   Tworzy ścieżkę i dodaje krzywych zamkniętej krzywej kardynalnej do ścieżki (zamknięte z punktu końcowego do punktu początkowego).  
  
-   Pobiera ścieżkę do ekranu.  
  
 Zwróć uwagę, że napięcie 0,5 jest używana.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="tension">Wartość z zakresu od od 0 do 1, który określa, że krzywej załamania między punktami z 0 jest najmniejsza krzywej (róg najlepszą jakość obrazu), a 1 daje płynne krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów. Jeśli pierwszy punkt i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje krzywej składanej do bieżącego rysunku. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku. Krzywej kardynalnej krzywej składanej jest stosowana, ponieważ krzywej przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania między punktami kontrolnymi. Wartości większe od 1 zwrócić nieoczekiwane wyniki.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania między punktami kontrolnymi. Wartości większe od 1 zwrócić nieoczekiwane wyniki.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="offset">Indeks elementu w <c>punktów</c> tablicy, który jest używany jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Wartość, która określa, że krzywej załamania między punktami kontrolnymi. Wartości większe od 1 zwrócić nieoczekiwane wyniki.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania między punktami kontrolnymi. Wartości większe od 1 zwrócić nieoczekiwane wyniki.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
 Krzywej zaczyna się od punktu w tablicy określona przez `offset` parametru i zawiera liczbę punktów (segmenty) określonych przez `numberOfSegments`.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę cztery punkty (reprezentujący kardynalnej krzywej składanej).  
  
-   Tworzy ścieżkę i przy użyciu tablica punktów, dodaje krzywej do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 Zwróć uwagę, gdy tablica zawiera cztery punkty, czy tylko trzy segmenty, który jest liczba określona w trzeci argument wywołania <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punktów, które definiują krzywej.</param>
        <param name="offset">Indeks elementu w <c>punktów</c> tablicy, który jest używany jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Liczba segmentów, używany do rysowania krzywej. Segment można traktować jako linia łącząca dwa punkty.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania między punktami kontrolnymi. Wartości większe od 1 zwrócić nieoczekiwane wyniki.</param>
        <summary>Dodaje krzywej składanej do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
 Krzywej zaczyna się od punktu w tablicy określona przez `offset`i zawiera liczbę punktów (segmenty) określonych przez `numberOfSegments`.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje elipsy do bieżącej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokątem, który definiuje wielokropka.</param>
        <summary>Dodaje elipsy do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
 Tworzy prostokątem, który definiuje wielokropka.  
  
 Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
 Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokątem, który definiuje wielokropka.</param>
        <summary>Dodaje elipsy do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątem, który definiuje wielokropka.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokątem, który definiuje wielokropka.</param>
        <param name="width">Szerokość prostokątem, który definiuje wielokropka.</param>
        <param name="height">Wysokość prostokątem, który definiuje wielokropka.</param>
        <summary>Dodaje elipsy do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątem, który definiuje wielokropka.</param>
        <param name="y">Współrzędna y lewym górnym rogu prostokątem, który definiuje wielokropka.</param>
        <param name="width">Szerokość prostokątem, który definiuje wielokropka.</param>
        <param name="height">Wysokość prostokątem, który definiuje wielokropka.</param>
        <summary>Dodaje elipsy do bieżącej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ten segment linii <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.Point" /> reprezentujący początek wiersza.</param>
        <param name="pt2">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt końcowy linii.</param>
        <summary>Dołącza ten segment linii <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje linia wynika z podanych punktów na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzednich linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany do ostatniego punktu w ścieżce nawiązać połączenia z pierwszego punktu w nowy segment linii.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.PointF" /> reprezentujący początek wiersza.</param>
        <param name="pt2">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt końcowy linii.</param>
        <summary>Dołącza ten segment linii <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje linia wynika z podanych punktów na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzednich linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany do ostatniego punktu w ścieżce nawiązać połączenia z pierwszego punktu w nowy segment linii.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu wyjścia wiersza.</param>
        <param name="y1">Współrzędna y punktu wyjścia wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego linii.</param>
        <param name="y2">Współrzędna y punktu końcowego linii.</param>
        <summary>Dołącza rysunek bieżący segment linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje wynika z podanych punktów na końcu rysunek bieżący segment linii. W przypadku poprzednich linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany do ostatniego punktu w ścieżce nawiązać połączenia z pierwszego punktu w nowy segment linii.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod tworzy ścieżki, dodaje trzy wiersze, które tworzą trójkąt i następnie rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu wyjścia wiersza.</param>
        <param name="y1">Współrzędna y punktu wyjścia wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego linii.</param>
        <param name="y2">Współrzędna y punktu końcowego linii.</param>
        <summary>Dołącza ten segment linii <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje linia wynika z podanych punktów na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzednich linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, segment linii jest rysowany do ostatniego punktu w ścieżce nawiązać połączenia z pierwszego punktu w nowy segment linii.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje definiujące segmenty linii, aby dodać punkty.</param>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do połączenia punktu końcowego poprzedniego segmentu punkt początkowy wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwie Określ pierwszego wiersza. Każdy dodatkowy punkt określa punkt końcowy segmentu wiersza, którego punkt początkowy jest punkt końcowy poprzedniego wiersza.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę cztery punkty, które opisują trójkąt.  
  
-   Tworzy ścieżkę i dodaje tablicy wierszy.  
  
-   Pobiera ścieżkę do ekranu.  
  
 Należy zwrócić uwagę na to, że każdy wiersz po pierwszym punktem użyto poprzedniego punktu jako punkt początkowy i punkt nowe jako punkt końcowy.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje definiujące segmenty linii, aby dodać punkty.</param>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli poprzednie linii i krzywych na ilustracji, wiersz zostanie dodany do połączenia punktu końcowego poprzedniego segmentu punkt początkowy wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwie Określ pierwszego wiersza. Każdy dodatkowy punkt określa punkt końcowy segmentu wiersza, którego punkt początkowy jest punkt końcowy poprzedniego wiersza.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do dodania.</param>
        <param name="connect">Wartość logiczna określająca, czy pierwszy rysunek w ścieżce dodany jest częścią ostatni rysunek w tej ścieżce. Wartość <see langword="true" /> określa (Jeśli to możliwe) pierwszy rysunek w ścieżce dodany jest częścią ostatni rysunek w tej ścieżce. Wartość <see langword="false" /> Określa, że pierwszy rysunek w ścieżce dodany jest oddzielony od ostatni rysunek w tej ścieżce.</param>
        <summary>Dołącza określony <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy dwie ścieżki jeden trójkąt po prawej stronie zapasowe i inne trójkąt po stronie up-down.  
  
-   Dodaje drugi ścieżkę jako pierwszy.  
  
-   Rysuje wynikowe ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje konturu kształtu koła do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowego mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowego mierzony w stopni w prawo z <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła określa częściowe konturu elipsy i dwa wiersze promieniowego przecinających punktów końcowych z częściowa konspektu. Częściowe konspektu zaczyna się od `startAngle` (mierzonego wskazówek zegara osi x) i kończy się na `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="width">Szerokość prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="height">Wysokość prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowego mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowego mierzony w stopni w prawo z <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła określa częściowe konturu elipsy i dwa wiersze promieniowego przecinających punktów końcowych z częściowa konspektu. Częściowe konspektu zaczyna się od `startAngle` (mierzonego wskazówek zegara osi x) i kończy się na `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod tworzy ścieżki grafiki, dodaje kształtu koła i następnie rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x górnego lewego rogu prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="y">Współrzędna y górnego lewego rogu prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="width">Szerokość prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="height">Wysokość prostokątem, który definiuje wielokropka, z którego ma zostać narysowana koło.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowego mierzony w stopni w prawo z osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowego mierzony w stopni w prawo z <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu koła do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt koła określa częściowe konturu elipsy i dwa wiersze promieniowego przecinających punktów końcowych z częściowa konspektu. Częściowe konspektu zaczyna się od `startAngle` (mierzonego wskazówek zegara osi x) i kończy się na `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktury definiujących wielokąta do dodania.</param>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy Określ wierzchołki wielokąta. Pierwszy punkt w tablicy nie jest taka sama jak ostatniego punktu, są połączone zamknąć wielokąt te dwa punkty.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę punktów, który definiuje wielokąta.  
  
-   Tworzy ścieżkę i dodaje wielokąta do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktury definiujących wielokąta do dodania.</param>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy Określ wierzchołki wielokąta. Pierwszy punkt w tablicy nie jest taka sama jak ostatniego punktu, są połączone zamknąć wielokąt te dwa punkty.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokąta do dodania.</param>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy prostokąt i dodaje prostokąta do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąta do dodania.</param>
        <summary>Dodaje prostokąt do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje szereg prostokąty do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.Rectangle" /> struktur, które reprezentuje prostokątach, aby dodać.</param>
        <summary>Dodaje szereg prostokąty do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy tablicę prostokąty i dodaje prostokątów do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.RectangleF" /> struktur, które reprezentuje prostokątach, aby dodać.</param>
        <summary>Dodaje szereg prostokąty do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, z którym zostanie narysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie reprezentujące informacje styl tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowane jako liczba całkowita (Zobacz przykład kodu w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em zakresem znak.</param>
        <param name="origin">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt, w którym tekst rozpoczyna się.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , który określa formatowania informacje, takie jak wiersz odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Określa argumenty ciągu i czcionki.  
  
-   Dodaje ciąg do ścieżki.  
  
-   Rysuje ciąg do ekranu.  
  
 Istnieją dwa ważnych rzeczy, aby podkreślić. Najpierw należy zauważyć, że `fontStyle` argument jest rzutowany jako liczba całkowita. <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> Metoda wymaga to, tak że dwóch lub więcej <xref:System.Drawing.FontStyle> utworzyć styl czcionki żądaną można łączyć elementów członkowskich (w tym przypadku <xref:System.Drawing.FontStyle.Italic> i <xref:System.Drawing.FontStyle.Underline>). Po drugie, zwróć uwagę, że <xref:System.Drawing.Graphics.FillPath%2A> metoda jest używana zamiast <xref:System.Drawing.Graphics.DrawPath%2A> metody. Jeśli <xref:System.Drawing.Graphics.FillPath%2A> jest używana, pełny tekst jest renderowany, natomiast jeśli <xref:System.Drawing.Graphics.DrawPath%2A> jest używana, tekst będzie styl konturu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, z którym zostanie narysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie reprezentujące informacje styl tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowane jako liczba całkowita (Zobacz przykład kodu w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em zakresem znak.</param>
        <param name="origin">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt, w którym tekst rozpoczyna się.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , który określa formatowania informacje, takie jak wiersz odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, z którym zostanie narysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie reprezentujące informacje styl tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowane jako liczba całkowita (Zobacz przykład kodu w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em zakresem znak.</param>
        <param name="layoutRect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokąt zakresem tekstu.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , który określa formatowania informacje, takie jak wiersz odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, z którym zostanie narysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie reprezentujące informacje styl tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowane jako liczba całkowita (Zobacz przykład kodu w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em zakresem znak.</param>
        <param name="layoutRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt zakresem tekstu.</param>
        <param name="format">A <see cref="T:System.Drawing.StringFormat" /> , który określa formatowania informacje, takie jak wiersz odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie znaczniki z tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> metodę w celu utworzenia znacznik w bieżącej lokalizacji w <xref:System.Drawing.Drawing2D.GraphicsPath>. Użyj <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> metody do iterowania po istniejących znaczników w ścieżce.  
  
 Znaczniki są używane do oddzielnych grup podrzędne. Co najmniej jeden podrzędne mogą być zawarte między znacznikami dwa.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje obiekty do ścieżki.  
  
-   Dodaje znaczniki do ścieżki.  
  
-   Czyści wszystkie znaczniki ze ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy dokładną kopię tej ścieżki.</summary>
        <returns>
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Ta metoda tworzy, rzutowany jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka dane do ścieżki.  
  
-   Pobiera ścieżkę do ekranu.  
  
-   Klonów kopię tej ścieżki.  
  
-   Rysuje nową ścieżkę do ekranu.  
  
 Zwróć uwagę, że wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> metoda musi być rzutowane jako <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie otwarte rysunki w tej ścieżce i uruchamia nowe rysunku. Zamyka każdego figurę otwartą łącząc wiersz z punktu końcowego punktu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka otwartych figur do ścieżki.  
  
-   Zamyka wszystkie dane w ścieżce.  
  
-   Pobiera ścieżkę do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący rysunek i uruchamia nowe rysunku. Jeśli bieżący rysunek zawiera sekwencję połączonych linii i krzywych, metoda zamyka pętli łącząc wiersz z punktu końcowego do punktu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod tworzy trójkąt Tworzenie nowej ścieżki, uruchamiając rysunku, dodawanie dwóch przecinających się linii na figurę i zamknięcie rysunek do utworzenia trójkąt. Ścieżka jest następnie rysowane na ekranie.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> umożliwia zasoby używane przez to <xref:System.Drawing.Drawing2D.GraphicsPath> odbiorczego do innych celów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia, która określa sposób wnętrza kształtów w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</summary>
        <value>A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia, która określa sposób wnętrza kształtów w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu, próby zwolnienia zasobów i wykonywać inne operacje oczyszczania, przed jego jest odzyskana przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje sekwencję segmenty linii połączonej każdego krzywej w tej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje sekwencję segmenty linii połączonej każdego krzywej w tej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> za pomocą której do przekształcenia to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> przed spłaszczanie.</param>
        <summary>Stosuje transformację określony, a następnie konwertuje każdego krzywej w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> do sekwencji segmenty linii połączonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> za pomocą której do przekształcenia to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> przed spłaszczanie.</param>
        <param name="flatness">Określa maksymalny błąd dozwolonych między krzywej i jego spłaszczoną zbliżenia. Wartość 0,25 jest wartość domyślna. Zmniejszenie był zwiększy liczbę segmentów w zbliżenia.</param>
        <summary>Konwertuje każdego krzywej w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> do sekwencji segmenty linii połączonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę grafiki i macierzy tłumaczenia.  
  
-   Dodaje krzywej do ścieżki cztery punkty.  
  
-   Rysuje ścieżki (krzywa) na ekranie, za pomocą czarnego pióra.  
  
-   Przenosi krzywej dół 10 pikseli i spłaszcza go.  
  
-   Rysuje krzywą na ekranie za pomocą pióra czerwony.  
  
 Zwróć uwagę, że red krzywej ma spłaszczone linie łączące punkty.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt ograniczający jest zależne od typu zakończenia, szerokość i pióra limit ostre i w związku z tym tworzy "utracić dopasowania" do ograniczonego ścieżki. Formuła przybliżonej: początkowej prostokątem jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skosów, skos może, a także niektóre dodatkowe margines, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę grafiki.  
  
-   Dodaje do niej elipsy (okrąg) i go rysuje do ekranu.  
  
-   Pobiera prostokąt ograniczający dla koło z wywołania <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> i rysuje prostokąt na ekranie.  
  
-   Tworzy drugi ścieżki grafiki.  
  
-   Dodaje koło i rozszerzenie ścieżki do szerokości 10.  
  
-   Pobiera ścieżkę do ekranu.  
  
-   Pobiera prostokąt ograniczający dla koła.  
  
-   Rysuje prostokąt ograniczający do ekranu.  
  
-   Wyświetla rozmiar prostokąt w oknie dialogowym.  
  
 Zwróć uwagę, że prostokątem po prawej stronie jest większy (do konta w celu dodatkowego szerokość wiersza).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> , Który określa transformację stosowaną do tej ścieżki przed obliczeniem prostokątem. Ta ścieżka nie jest trwale przekształcony; Transformacja jest używana tylko podczas obliczania prostokątem.</param>
        <summary>Zwraca prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Jeśli ta ścieżka jest przekształcana przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt ograniczający jest zależne od typu zakończenia, szerokość i pióra limit ostre i w związku z tym tworzy "utracić dopasowania" do ograniczonego ścieżki. Formuła przybliżonej: początkowej prostokątem jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skosów, skos może, a także niektóre dodatkowe margines, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> , Który określa transformację stosowaną do tej ścieżki przed obliczeniem prostokątem. Ta ścieżka nie jest trwale przekształcony; Transformacja jest używana tylko podczas obliczania prostokątem.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> z którym ma zostać narysowany <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Zwraca prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas bieżącej ścieżki jest przekształcana przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" /> oraz z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt zakresem to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt ograniczający jest zależne od typu zakończenia, szerokość i pióra limit ostre i w związku z tym tworzy "utracić dopasowania" do ograniczonego ścieżki. Formuła przybliżonej: początkowej prostokątem jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skosów, skos może, a także niektóre dodatkowe margines, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ostatniego punktu w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> to tablica <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>A <see cref="T:System.Drawing.PointF" /> reprezentujący ostatniego punktu w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod tworzy ścieżki, dodaje linię do ścieżki i następnie pobiera ostatniego punktu w ścieżce.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.Point" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.PointF" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.Point" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie. Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` tymczasowo przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.PointF" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie. Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` tymczasowo przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w obrębie konspektu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie. Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` tymczasowo przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje prostokąt do ścieżki.  
  
-   Tworzy szerokości pióra i rozszerzenie ścieżki z tym pióra (Aby przykłady jaśniejszy)  
  
-   Testy punktu (100, 50) aby zobaczyć, czy leży w () z zachowaniem krawędzi prostokąta przez wywołanie metody <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 Wynik jest wyświetlany w oknie komunikatu (w tym przypadku, true). Innymi słowy krawędzi jest renderowany za pośrednictwem tego punktu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> narysować z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach (w obszarze) konturu to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy konturu danej ścieżki jest renderowany widoczne w określonym momencie. Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> , jeśli określony punkt znajduje się w ramach tego przeciwnym <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` tymczasowo przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
-   Sprawdza, czy określony punkt znajduje się w ścieżce.  
  
-   Wyświetla wyniki w oknie dialogowym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w regionie widoczne klip określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu badane są podane we współrzędnych świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Drawing.Drawing2D.PathData" /> która hermetyzuje tablice punktów (<paramref name="points" />) i typy (<paramref name="types" />) dla tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>A <see cref="T:System.Drawing.Drawing2D.PathData" /> która hermetyzuje tablice zarówno punktów i typy w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punktów w ścieżce.</summary>
        <value>Tablica <see cref="T:System.Drawing.PointF" /> obiekty reprezentujące ścieżkę.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy odpowiednimi punktami <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> tablicy.</summary>
        <value>Tablica bajtów określa typy odpowiednich punktów w ścieżce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica bajtów zwrócona przez <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> właściwość określa flagi dla punktów danych i typy punktów w ścieżce. Dla każdego punktu Usługi bits od 0 do 2 wskazują na typ punktu, a usługi bits 3 do 7 utrzymywać zestaw flag, które określają atrybuty punktu. W poniższej tabeli przedstawiono możliwe wartości i ich znaczenie.  
  
|Wartość|Znaczenie|  
|-----------|-------------|  
|0|Wskazuje, że punkt jest początek rysunku.|  
|1|Wskazuje, czy punkt znajduje się jeden z dwóch punktów końcowych wiersza.|  
|3|Wskazuje, czy punkt znajduje się punkt końcowy lub punktu kontrolnego sześcienny krzywej Beziera.|  
|0x7|Maski bitów wszystkie z wyjątkiem trzy mniej znaczące bity, wskazujące typ punktu.|  
|0x20|Określa, czy punkt znajduje się znacznik.|  
|0x80|Określa, czy punkt znajduje się ostatniego punktu w zamkniętym podrzędną (rysunek).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> lub <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy.</summary>
        <value>Liczba całkowita określająca liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> lub <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opróżnia <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> i <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> stałych i ustawia <see cref="T:System.Drawing.Drawing2D.FillMode" /> do <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka elementów podstawowych do niej.  
  
-   Rysuje tablica punktów ścieżki do ekranu.  
  
-   Resetuje ścieżki do stanu pustego.  
  
-   Ponownie uzyskuje tablica punktów (jeśli istnieje).  
  
-   Rysuje tablicy do ekranu.  
  
 Zwróć uwagę, znalezione nie tablicy następujący po wywołaniu resetowania.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność punktów <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> to tablica <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje kilka elementów podstawowych do ścieżki.  
  
-   Rysuje tablica punktów ścieżki do ekranu.  
  
-   Rysuje tablicę wycofane punktów do ekranu.  
  
 Zauważ, że druga lista punktów w odwrotnej kolejności jest od pierwszego.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia znacznik na tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy znacznik na ścieżce, który może służyć do rozdzielania części ścieżki. Następnie można użyć <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> metod do iteracji znaczników w ścieżce.  
  
 Znaczniki są używane do oddzielnych grup podrzędne. Co najmniej jeden podrzędne mogą być zawarte między znacznikami dwóch w ścieżce.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod tworzy ścieżki i dodaje kilka elementów podstawowych do ścieżki oddzielone znaczniki i rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia nowe rysunek bez zamykania bieżącej rysunku. Wszystkie kolejne punkty dodane do ścieżki są dodawane do tego nowego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi zachować oryginalny punktów, jeśli są potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie istnieje mechanizm dla zwracania oryginalnych punktów.  
  
 Ta metoda uruchamia nowe podrzędną w ścieżce. Podrzędne umożliwiają podzielić ścieżkę na sekcje i użyj <xref:System.Drawing.Drawing2D.GraphicsPathIterator> klasy do iteracji podrzędnej.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje dwa zestawy danych. Pierwszy zestaw danych łączy czterech podstawowych w dwóch liczb. Drugi zestaw danych łączy tego samego czterech podstawowych (z wyjątkiem tego, że są one przesunięcie w osi y) w trzech wyników.  
  
-   Rysuje wszystkich danych do ekranu.  
  
 Należy zauważyć różnicę wygląd między dwoma zestawami danych.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> reprezentujący przekształcenie do zastosowania.</param>
        <summary>Dotyczy to macierzy transformacji <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Transformacja można skalować, tłumaczenia, obracanie lub pochylanie <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
-   Tworzy macierzy transformacji do tłumaczenia jednostki 100 ścieżki w kierunku osi x.  
  
-   Rysuje przekształcone ścieżki do ekranu.  
  
 Zauważyć, że oryginalne elipsy jest rysowana w kolorze czarnym, a po przekształceniu elipsy jest rysowana na czerwono.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stosuje transformację warp, zdefiniowany przez prostokąt i równoległobok, aby to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcana. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, prawym dolnym rogu równoległobok technicznego przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, w którym jest on przekształcany w równoległobok zdefiniowane przez <c>destPoints</c>.</param>
        <summary>Stosuje transformację warp, zdefiniowany przez prostokąt i równoległobok, aby to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcana. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, prawym dolnym rogu równoległobok technicznego przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, w którym jest on przekształcany w równoległobok zdefiniowane przez <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <summary>Stosuje transformację warp, zdefiniowany przez prostokąt i równoległobok, aby to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiowany jest równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcana. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, prawym dolnym rogu równoległobok technicznego przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, w którym jest on przekształcany w równoległobok zdefiniowane przez <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> wyliczenie Określa, czy ta operacja warp używa perspektywy lub w trybie Dwuliniowa.</param>
        <summary>Stosuje transformację warp, zdefiniowany przez prostokąt i równoległobok, aby to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcana. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, prawym dolnym rogu równoległobok technicznego przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, w którym jest on przekształcany w równoległobok zdefiniowane przez <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> wyliczenie Określa, czy ta operacja warp używa perspektywy lub w trybie Dwuliniowa.</param>
        <param name="flatness">Wartość z zakresu od 0 do 1, który określa sposób płaskiej ścieżka jest. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> metody.</param>
        <summary>Stosuje transformację warp, zdefiniowany przez prostokąt i równoległobok, aby to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje prostokąta do ścieżki.  
  
-   Rysuje prostokąt tego ekranu w kolorze czarnym.  
  
-   Warps ścieżki z warp perspektywy.  
  
-   Rysuje prostokąt zawijać (ścieżka) ekran kolorem czerwonym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje tę ścieżkę krzywych, które należy ująć jest wypełniony, gdy ta ścieżka jest rysowany przez pióro określonego obszaru.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konturu oryginalnej ścieżce i konspekt nowe, ta metoda tworzy.</param>
        <summary>Dodaje dodatkowe konspektu do ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy obramowania wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, z odległość między wierszami istniejących i nowych konspektu równa niż szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> a nie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konturu oryginalnej ścieżce i konspekt nowe, ta metoda tworzy.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa przekształcenie do zastosowania do ścieżki przed rozszerzanie.</param>
        <summary>Dodaje dodatkowe konspektu do <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy obramowania wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, z odległość między wierszami istniejących i nowych konspektu równa niż szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> a nie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Na przykład zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">A <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konturu oryginalnej ścieżce i konspekt nowe, ta metoda tworzy.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa przekształcenie do zastosowania do ścieżki przed rozszerzanie.</param>
        <param name="flatness">Wartość, która określa płaskość dla krzywych.</param>
        <summary>Zastępuje to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> z krzywych, które należy ująć jest wypełniony, gdy ta ścieżka jest rysowany przez pióro określonego obszaru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy obramowania wokół oryginalnych wierszy w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, z odległość między wierszami istniejących i nowych konspektu równa niż szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> a nie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod jest przeznaczony do użytku z formularzy systemu Windows i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiekt zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje dwie elipsy do ścieżki.  
  
-   Rysuje ścieżki w kolorze czarnym.  
  
-   Rozszerzenie ścieżki.  
  
-   Rysuje ścieżkę kolorem czerwonym.  
  
 Zwróć uwagę, używającą drugi renderowania <xref:System.Drawing.Graphics.FillPath%2A> zamiast <xref:System.Drawing.Graphics.DrawPath%2A>, i dlatego renderowanych rysunek ma konspektu wypełnione.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
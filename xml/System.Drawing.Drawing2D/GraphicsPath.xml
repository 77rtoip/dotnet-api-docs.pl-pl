<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3fd1bd79f182c0f5f7c92134dc793a8fef902216" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51934328" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="F#" Value="type GraphicsPath = class&#xA;    inherit MarshalByRefObject&#xA;    interface ICloneable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje szereg podłączonych linii i krzywych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje użyć ścieżek, aby narysować obramowanie kształtów, wypełnij wnętrza kształtów i utworzyć regionów wycinka. Aparat grafiki zachowuje współrzędne kształtów geometrycznych w ścieżce w przestrzeni współrzędnych świata.  
  
 Ścieżka może składać się z dowolną liczbę cyfr (podścieżek). Każda liczba albo składa się z sekwencji połączone linie, krzywe i element podstawowy kształt geometryczny. Punkt początkowy rysunku jest pierwszym punktem w sekwencji połączonych linii i krzywych. Punkt końcowy jest ostatniego punktu w sekwencji. Punkty początkowy i końcowy kształtu geometrycznego pierwotne są definiowane przez specyfikację pierwotnych.  
  
 Rysunek, który składa się z sekwencji połączone linie i krzywych (których punkty początkowy i końcowy może być zbieżna) jest otwartego rysunku, chyba że jawnie zamknięty. Rysunek może zostać jawnie zamknięty przy użyciu <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A> metody, która powoduje zamknięcie bieżącego rysunek łącząc linię z punktu końcowego do punktu początkowego. Rysunek, który składa się z podstawowy kształt geometryczny jest figurę zamkniętą.  
  
 Na potrzeby wypełniania i wycinka (na przykład, jeśli ścieżka jest renderowany przy użyciu <xref:System.Drawing.Graphics.FillPath%2A>), wszystkie otwarte rysunki są zamknięte przez dodanie linię z pierwszym punktem rysunku do ostatniego punktu.  
  
 Nowy rysunek niejawnie została uruchomiona po utworzeniu ścieżki, lub gdy rysunek jest zamknięty. Nowy rysunek jest jawnie tworzone, gdy <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A> metoda jest wywoływana.  
  
 Gdy element podstawowy kształt geometryczny zostanie dodany do ścieżki, dodaje rysunku zawierający kształtu geometrycznego i również niejawnie uruchamia nowy rysunek. W związku z tym jest zawsze bieżącego rysunek w ścieżce. Gdy linii i krzywych zostaną dodane do ścieżki, niejawne wiersza jest dodawany jako wymagany do połączenia z punktu końcowego rysunek bieżący punkt początkowy nowej linii i krzywych w celu utworzenia sekwencji połączone linie i krzywych.  
  
 Ilustracja ma kierunku, w którym w tym artykule opisano, jak segmenty linii i krzywych są śledzone od punktu początkowego i punktu końcowego. Kierunek jest zdefiniowana w kolejności linii i krzywych są dodawane do rysunku lub jest zdefiniowane przez kształt geometryczny pierwotnych. Kierunek jest używany podczas określania wnętrza ścieżki przycinania i wypełnienia.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f16ec921-56cf-46d1-9741-d7316ad06b23">Konstruowanie i rysowanie ścieżek</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" /> wartość <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath fillMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">
          <see cref="T:System.Drawing.Drawing2D.FillMode" /> Wyliczenie, który określa sposób, w jaki posługiwanie się nimi tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> jest wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, które określa współrzędne punktów, które tworzą to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pkt</c> tablicy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.Point" /> tablic.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które określa współrzędne punktów, które tworzą to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pkt</c> tablicy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicę z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.PointF" /> tablic.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.Point" /> struktur, które określa współrzędne punktów, które tworzą to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pkt</c> tablicy.</param>
        <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie, który określa sposób wnętrza kształty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> klasy z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.Point" /> tablic i o określonej <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementu wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które określa współrzędne punktów, które tworzą to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="types">Tablica <see cref="T:System.Drawing.Drawing2D.PathPointType" /> elementy wyliczenia, które określa typ każdego odpowiedniego punktu w <c>pkt</c> tablicy.</param>
        <param name="fillMode">A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie, który określa sposób wnętrza kształty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tablicę z określonym <see cref="T:System.Drawing.Drawing2D.PathPointType" /> i <see cref="T:System.Drawing.PointF" /> tablic i o określonej <see cref="T:System.Drawing.Drawing2D.FillMode" /> elementu wyliczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza łuk eliptyczny do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokątne granice elipsy, z którego pochodzi łuku.</param>
        <param name="startAngle">Kąt początkowy łuk w stopniach do ruchu wskazówek zegara od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuku.</param>
        <summary>Dołącza łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktem końcowym poprzedniego segmentu do stanu sprzed łuku.  
  
 Łuk jest śledzone wzdłuż obwodowej elipsy poprowadzoną określonego prostokąta. Punkt początkowy łuku jest określana przez dokonywanie pomiarów zgodnie ze wskazówkami zegara od osi x elipsy (pod kątem 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc zgodnie ze wskazówkami zegara od punktu początkowego przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk jest przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy prostokąt, w którym zdefiniowano łuku.  
  
-   Tworzy ścieżkę `myPath`.  
  
-   Definiuje łuk eliptyczny 180 stopni, który wrzucając z 0 stopni do 180 stopni i dołącza go do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokątne granice elipsy, z którego pochodzi łuku.</param>
        <param name="startAngle">Kąt początkowy łuk w stopniach do ruchu wskazówek zegara od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuku.</param>
        <summary>Dołącza łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktem końcowym poprzedniego segmentu do stanu sprzed łuku.  
  
 Łuk jest śledzone wzdłuż obwodowej elipsy poprowadzoną określonego prostokąta. Punkt początkowy łuku jest określana przez dokonywanie pomiarów zgodnie ze wskazówkami zegara od osi x elipsy (pod kątem 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc zgodnie ze wskazówkami zegara od punktu początkowego przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk jest przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x w lewym górnym rogu prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="width">Szerokość prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="height">Wysokość prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="startAngle">Kąt początkowy łuk w stopniach do ruchu wskazówek zegara od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuku.</param>
        <summary>Dołącza łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktem końcowym poprzedniego segmentu do stanu sprzed łuku.  
  
 Łuk jest śledzone wzdłuż obwodowej elipsy poprowadzoną określonego prostokąta. Punkt początkowy łuku jest określana przez dokonywanie pomiarów zgodnie ze wskazówkami zegara od osi x elipsy (pod kątem 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc zgodnie ze wskazówkami zegara od punktu początkowego przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk jest przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x w lewym górnym rogu prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="width">Szerokość prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="height">Wysokość prostokątny obszar, który definiuje elipsy, z którego łuku.</param>
        <param name="startAngle">Kąt początkowy łuk w stopniach do ruchu wskazówek zegara od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu łuku.</param>
        <summary>Dołącza łuk eliptyczny do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktem końcowym poprzedniego segmentu do stanu sprzed łuku.  
  
 Łuk jest śledzone wzdłuż obwodowej elipsy poprowadzoną określonego prostokąta. Punkt początkowy łuku jest określana przez dokonywanie pomiarów zgodnie ze wskazówkami zegara od osi x elipsy (pod kątem 0 stopni) przez liczbę stopni w Kąt początkowy. Punkt końcowy znajduje się podobnie mierząc zgodnie ze wskazówkami zegara od punktu początkowego przez liczbę stopni w kąta odchylenia. Jeśli kąta odchylenia jest większa niż 360 lub mniej niż-360 stopni, łuk jest przechwytywana przez dokładnie 360 lub-360 stopni, odpowiednio.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje krzywą Beziera trzeciego stopnia do bieżącego rysunku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.Point" /> reprezentująca punkt początkowy krzywej.</param>
        <param name="pt2">A <see cref="T:System.Drawing.Point" /> reprezentująca pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3">A <see cref="T:System.Drawing.Point" /> reprezentujący drugi punkt kontrolny krzywej.</param>
        <param name="pt4">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt końcowy krzywej.</param>
        <summary>Dodaje krzywą Beziera trzeciego stopnia do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzona z pierwszego punktu punkt czwarty przy użyciu punktów drugi i trzeci jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniej linii lub segmentu krzywej na ilustracji, wiersza jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenie z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.PointF" /> reprezentująca punkt początkowy krzywej.</param>
        <param name="pt2">A <see cref="T:System.Drawing.PointF" /> reprezentująca pierwszy punkt kontrolny krzywej.</param>
        <param name="pt3">A <see cref="T:System.Drawing.PointF" /> reprezentujący drugi punkt kontrolny krzywej.</param>
        <param name="pt4">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt końcowy krzywej.</param>
        <summary>Dodaje krzywą Beziera trzeciego stopnia do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzona z pierwszego punktu punkt czwarty przy użyciu punktów drugi i trzeci jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniej linii lub segmentu krzywej na ilustracji, wiersza jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenie z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : int * int * int * int * int * int * int * int -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszy punkt kontrolny krzywej.</param>
        <param name="y2">Współrzędna y pierwszy punkt kontrolny krzywej.</param>
        <param name="x3">Współrzędna x drugi punkt kontrolny krzywej.</param>
        <param name="y3">Współrzędna y drugi punkt kontrolny krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje krzywą Beziera trzeciego stopnia do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzona z pierwszego punktu punkt czwarty przy użyciu punktów drugi i trzeci jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniej linii lub segmentu krzywej na ilustracji, wiersza jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenie z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje określone przez punkty (50, 50), krzywą Beziera trzeciego stopnia (70, 0), (100, 120), a (150, 50) do ścieżki.  
  
-   Zamyka krzywej.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : single * single * single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego krzywej.</param>
        <param name="y1">Współrzędna y punktu początkowego krzywej.</param>
        <param name="x2">Współrzędna x pierwszy punkt kontrolny krzywej.</param>
        <param name="y2">Współrzędna y pierwszy punkt kontrolny krzywej.</param>
        <param name="x3">Współrzędna x drugi punkt kontrolny krzywej.</param>
        <param name="y3">Współrzędna y drugi punkt kontrolny krzywej.</param>
        <param name="x4">Współrzędna x punktu końcowego krzywej.</param>
        <param name="y4">Współrzędna y punktu końcowego krzywej.</param>
        <summary>Dodaje krzywą Beziera trzeciego stopnia do bieżącego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Krzywą trzeciego stopnia jest tworzona z pierwszego punktu punkt czwarty przy użyciu punktów drugi i trzeci jako punkty kontrolne.  
  
 Jeśli istnieje poprzedniej linii lub segmentu krzywej na ilustracji, wiersza jest dodawany do punktu końcowego poprzedniego segmentu nawiązać połączenie z punktem początkowym krzywą trzeciego stopnia.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje sekwencję połączonych krzywych Beziera trzeciego stopnia do bieżącej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywych.</param>
        <summary>Dodaje sekwencję połączonych krzywych Beziera trzeciego stopnia do bieżącej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punkty kontrolne krzywych połączonych. Pierwszy krzywej jest tworzony z pierwszego punktu do czwartej punktu w `points` tablicy przy użyciu punktów drugi i trzeci jako punkty kontrolne. Oprócz punkt końcowy poprzedniego krzywej każdej kolejnej krzywej w sekwencji musi dokładnie trzy większej liczby punktów: następne dwa punkty w sekwencji są punkty kontrolne, a trzeci jest punkt końcowy dla krzywej dodano.  
  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do endpoint poprzedniego segmentu nawiązać połączenie z punktu początkowego pierwszego krzywą trzeciego stopnia w sekwencji.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę siedmiu punkty (reprezentującej dwie krzywe Beziera połączone).  
  
-   Tworzy ścieżkę i dodaje serię punktów krzywej Beziera do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywych.</param>
        <summary>Dodaje sekwencję połączonych krzywych Beziera trzeciego stopnia do bieżącej wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `points` Parametr określa tablicę punktów końcowych i punkty kontrolne krzywych połączonych. Pierwszy krzywej jest tworzony z pierwszego punktu do czwartej punktu w `points` tablicy przy użyciu punktów drugi i trzeci jako punkty kontrolne. Oprócz punkt końcowy poprzedniego krzywej każdej kolejnej krzywej w sekwencji musi dokładnie trzy większej liczby punktów: następne dwa punkty w sekwencji są punkty kontrolne, a trzeci jest punkt końcowy dla krzywej dodano.  
  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do endpoint poprzedniego segmentu nawiązać połączenie z punktu początkowego pierwszego krzywą trzeciego stopnia w sekwencji.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów. Jeśli punkt pierwszego i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty. Nie można ustawić wartości napięcie tę metodę i przyjmuje domyślnie wartość odpowiednikiem 0,5.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów. Jeśli punkt pierwszego i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty. Nie można ustawić wartości napięcie tę metodę i przyjmuje domyślnie wartość odpowiednikiem 0,5.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="tension">Wartość z zakresu od od 0 do 1, który określa ilość, który krzywej załamania się między punktami z 0 jest najmniejsza krzywej (najlepszą jakość obrazu róg), a 1 daje płynne krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów. Jeśli punkt pierwszego i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę z sześciu punktów (reprezentującej kardynalna).  
  
-   Tworzy ścieżkę i dodaje krzywych zamkniętej krzywej kardynalnej do ścieżki (zamknięte z punktu końcowego na punkt początkowy).  
  
-   Rysuje ścieżki do ekranu.  
  
 Należy zauważyć, że napięcie 0,5 jest używany.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="tension">Wartość z zakresu od od 0 do 1, który określa ilość, który krzywej załamania się między punktami z 0 jest najmniejsza krzywej (najlepszą jakość obrazu róg), a 1 daje płynne krzywej.</param>
        <summary>Dodaje zamkniętej krzywej do tej ścieżki. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów. Jeśli punkt pierwszego i ostatniego punktu w `points` tablicy nie są tego samego punktu, krzywej jest zamknięty, łącząc te dwa punkty.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje krzywej składanej na figurę bieżącego. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego. Krzywa kardynalna jest stosowana, ponieważ krzywej, przechodzi przez każdego z punktów w tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania się między punktami kontrolnymi. Wartości większe od 1 powodować nieprzewidywalne rezultaty.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania się między punktami kontrolnymi. Wartości większe od 1 powodować nieprzewidywalne rezultaty.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="offset">Indeks elementu w <c>punktów</c> tablicy, która jest używana jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Wartość, która określa, że krzywej załamania się między punktami kontrolnymi. Wartości większe od 1 powodować nieprzewidywalne rezultaty.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania się między punktami kontrolnymi. Wartości większe od 1 powodować nieprzewidywalne rezultaty.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
 Krzywa rozpoczyna się od punktu w macierzy, określony przez `offset` parametru oraz liczbie punktów (segmenty), określony przez `numberOfSegments`.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę czterech punktów (reprezentującej kardynalna).  
  
-   Tworzy ścieżkę, a przy użyciu tablicy punkty, dodaje krzywej do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 Zauważ, że gdy tablica zawiera cztery punkty, są tylko dla trzech segmenty, czyli liczbie określonej w trzecim argumencie wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują krzywej.</param>
        <param name="offset">Indeks elementu w <c>punktów</c> tablicy, która jest używana jako pierwszy punkt krzywej.</param>
        <param name="numberOfSegments">Liczba segmentów, używany do rysowania krzywej. Segment można traktować jako linia łącząca dwa punkty.</param>
        <param name="tension">Wartość, która określa, że krzywej załamania się między punktami kontrolnymi. Wartości większe od 1 powodować nieprzewidywalne rezultaty.</param>
        <summary>Dodaje krzywej składanej na figurę bieżącego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
 Krzywa rozpoczyna się od punktu w macierzy, określony przez `offset`oraz liczbę punktów (segmenty), określony przez `numberOfSegments`.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje elipsę w bieżącej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokąt otaczający, który definiuje elipsy.</param>
        <summary>Dodaje elipsę w bieżącej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
 Tworzy prostokąt otaczający, który definiuje elipsę.  
  
 Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
 Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt otaczający, który definiuje elipsy.</param>
        <summary>Dodaje elipsę w bieżącej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : int * int * int * int -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x w lewym górnym rogu prostokąt otaczający, który definiuje elipsy.</param>
        <param name="y">Współrzędna y lewego górnego rogu prostokąt otaczający, który definiuje elipsy.</param>
        <param name="width">Szerokość prostokąt otaczający, który definiuje elipsy.</param>
        <param name="height">Wysokość prostokąt otaczający, który definiuje elipsy.</param>
        <summary>Dodaje elipsę w bieżącej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : single * single * single * single -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x w lewym górnym rogu prostokąt otaczający, który definiuje elipsy.</param>
        <param name="y">Współrzędna y lewym górnym rogu prostokąt otaczający, który definiuje elipsy.</param>
        <param name="width">Szerokość prostokąt otaczający, który definiuje elipsy.</param>
        <param name="height">Wysokość prostokąt otaczający, który definiuje elipsy.</param>
        <summary>Dodaje elipsę w bieżącej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ten odcinek <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.Point" /> reprezentująca punkt początkowy wiersza.</param>
        <param name="pt2">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt końcowy linii.</param>
        <summary>Dołącza ten odcinek <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta umożliwia dodanie segment linii, zdefiniowane przez określony wskazuje na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzedniego linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, linia jest rysowana do ostatniego punktu w ścieżce nawiązać połączenie z pierwszym punktem w nowej segment linii.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">A <see cref="T:System.Drawing.PointF" /> reprezentująca punkt początkowy wiersza.</param>
        <param name="pt2">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt końcowy linii.</param>
        <summary>Dołącza ten odcinek <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta umożliwia dodanie segment linii, zdefiniowane przez określony wskazuje na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzedniego linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, linia jest rysowana do ostatniego punktu w ścieżce nawiązać połączenie z pierwszym punktem w nowej segment linii.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : int * int * int * int -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego wiersza.</param>
        <param name="y1">Współrzędna y punktu początkowego wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego linii.</param>
        <param name="y2">Współrzędna y punktu końcowego linii.</param>
        <summary>Dołącza rysunek bieżący segment linii.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta umożliwia dodanie zdefiniowane przez określony wskazuje na koniec bieżącego rysunek segment linii. W przypadku poprzedniego linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, linia jest rysowana do ostatniego punktu w ścieżce nawiązać połączenie z pierwszym punktem w nowej segment linii.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod powoduje utworzenie ścieżki, dodaje trzy wiersze, które tworzą trójkąt i następnie rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : single * single * single * single -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Współrzędna x punktu początkowego wiersza.</param>
        <param name="y1">Współrzędna y punktu początkowego wiersza.</param>
        <param name="x2">Współrzędna x punktu końcowego linii.</param>
        <param name="y2">Współrzędna y punktu końcowego linii.</param>
        <summary>Dołącza ten odcinek <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta umożliwia dodanie segment linii, zdefiniowane przez określony wskazuje na końcu <xref:System.Drawing.Drawing2D.GraphicsPath>. W przypadku poprzedniego linii i krzywych w <xref:System.Drawing.Drawing2D.GraphicsPath>, linia jest rysowana do ostatniego punktu w ścieżce nawiązać połączenie z pierwszym punktem w nowej segment linii.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które reprezentuje punkty, które definiują segmentów linii do dodania.</param>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktu końcowego poprzedniego segmentu punkt początkowy wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwa określ pierwszy wiersz. Każdy dodatkowy punkt określa punkt końcowy segmentu wiersza, którego punkt początkowy jest punkt końcowy w poprzednim wierszu.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę czterech punktów, które opisują trójkąt.  
  
-   Tworzy ścieżkę i dodaje tablicy wierszy.  
  
-   Rysuje ścieżki do ekranu.  
  
 Każdy wiersz po pierwszym punktem używa poprzedniego punktu jako punkt początkowy i nowy punkt, jako punktu końcowego powiadomienia.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które reprezentuje punkty, które definiują segmentów linii do dodania.</param>
        <summary>Dołącza szereg segmenty linii połączonej na końcu <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku poprzedniego linii i krzywych na ilustracji, wiersza jest dodawany do łączenia z punktu końcowego poprzedniego segmentu punkt początkowy wiersza. `points` Parametr określa tablicę punktów końcowych. Pierwsze dwa określ pierwszy wiersz. Każdy dodatkowy punkt określa punkt końcowy segmentu wiersza, którego punkt początkowy jest punkt końcowy w poprzednim wierszu.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberSignature Language="F#" Value="member this.AddPath : System.Drawing.Drawing2D.GraphicsPath * bool -&gt; unit" Usage="graphicsPath.AddPath (addingPath, connect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Do dodania.</param>
        <param name="connect">Wartość logiczna określająca, czy pierwszy rysunek dodano ścieżki jest częścią ostatni rysunek w tej ścieżce. Wartość <see langword="true" /> określa (jeśli jest to możliwe) pierwszy rysunek dodano ścieżki jest częścią ostatni rysunek w tej ścieżce. Wartość <see langword="false" /> Określa, że pierwszy rysunek dodano ścieżki jest oddzielony od ostatni rysunek w tej ścieżce.</param>
        <summary>Dołącza określony <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy dwie ścieżki jeden trójkąt prawej stronie górę, a druga trójkąta w górę strony szczegółów.  
  
-   Dodaje ścieżkę drugiego do pierwszego.  
  
-   Rysuje wynikowe ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje konturu kształtu kołowy do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddPie (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowy trwające stopni w prawo od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowy w stopniach do ruchu wskazówek zegara od <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu kołowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt kołowy jest definiowany przez częściowe zarys elipsę i dwa wiersze promieniowego, przecinających punktów końcowych konturu częściowe. Częściowe konspektu rozpoczyna się od `startAngle` (mierzone zgodnie ze wskazówkami zegara od osi x) i kończy się `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="y">Współrzędna y lewego górnego rogu otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="width">Szerokość otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="height">Wysokość otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowy trwające stopni w prawo od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowy w stopniach do ruchu wskazówek zegara od <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu kołowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt kołowy jest definiowany przez częściowe zarys elipsę i dwa wiersze promieniowego, przecinających punktów końcowych konturu częściowe. Częściowe konspektu rozpoczyna się od `startAngle` (mierzone zgodnie ze wskazówkami zegara od osi x) i kończy się `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod powoduje utworzenie ścieżki grafiki, dodaje kształt kołowy i następnie rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lewego górnego rogu otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="y">Współrzędna y lewego górnego rogu otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="width">Szerokość otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="height">Wysokość otaczający prostokąt, który definiuje elipsy, z którego jest rysowana wykres kołowy.</param>
        <param name="startAngle">Kąt początkowy dla sekcji kołowy trwające stopni w prawo od osi x.</param>
        <param name="sweepAngle">Kąt między <c>startAngle</c> i na końcu sekcji kołowy w stopniach do ruchu wskazówek zegara od <c>startAngle</c>.</param>
        <summary>Dodaje konturu kształtu kołowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kształt kołowy jest definiowany przez częściowe zarys elipsę i dwa wiersze promieniowego, przecinających punktów końcowych konturu częściowe. Częściowe konspektu rozpoczyna się od `startAngle` (mierzone zgodnie ze wskazówkami zegara od osi x) i kończy się `startAngle`  +  `sweepAngle`.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.Point" /> struktur, które definiuje wielokąta do dodania.</param>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy Określ wierzchołki wielokąta. Jeśli pierwszy punkt w tablicy nie jest taka sama jak ostatni punkt, te dwa punkty są podłączone do zamknąć wielokąt.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy tablicę punkty, który definiuje wielokąta.  
  
-   Tworzy ścieżkę i dodaje wielokąta do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiuje wielokąta do dodania.</param>
        <summary>Dodaje wielokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty w `points` tablicy Określ wierzchołki wielokąta. Jeśli pierwszy punkt w tablicy nie jest taka sama jak ostatni punkt, te dwa punkty są podłączone do zamknąć wielokąt.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje prostokąta do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokąta do dodania.</param>
        <summary>Dodaje prostokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy prostokąt, a następnie dodaje prostokąta do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąta do dodania.</param>
        <summary>Dodaje prostokąta do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje serię prostokąty do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.Rectangle[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.Rectangle" /> struktur, które reprezentuje prostokątach, aby go dodać.</param>
        <summary>Dodaje serię prostokąty do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Tworzy tablicę prostokąty i dodaje prostokątów w ścieżce.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.RectangleF[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Tablica <see cref="T:System.Drawing.RectangleF" /> struktur, które reprezentuje prostokątach, aby go dodać.</param>
        <summary>Dodaje serię prostokąty do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Point * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, za pomocą którego jest rysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie, które reprezentuje styl informacji na temat tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowany jako liczba całkowita (zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em granic znak.</param>
        <param name="origin">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt, w którym tekst rozpoczyna się.</param>
        <param name="format">Element <see cref="T:System.Drawing.StringFormat" /> , który określa formatowanie informacje, takie jak linia odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Określa argumenty ciągu i czcionki.  
  
-   Dodaje ciąg do ścieżki.  
  
-   Rysuje ciąg do ekranu.  
  
 Istnieją dwie ważne czynności, aby podkreślić. Po pierwsze należy zauważyć, że `fontStyle` argument jest rzutowany jako liczba całkowita. <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A> Metoda tego wymaga, tak że dwóch lub więcej <xref:System.Drawing.FontStyle> elementów członkowskich może być łączone w celu utworzenia styl czcionki żądaną (w tym przypadku <xref:System.Drawing.FontStyle.Italic> i <xref:System.Drawing.FontStyle.Underline>). Po drugie, zwróć uwagę, że <xref:System.Drawing.Graphics.FillPath%2A> metoda jest używana zamiast <xref:System.Drawing.Graphics.DrawPath%2A> metody. Jeśli <xref:System.Drawing.Graphics.FillPath%2A> jest używany, renderowane pełnego tekstu, dlatego jeśli <xref:System.Drawing.Graphics.DrawPath%2A> jest używany, tekst będzie styl konturu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, za pomocą którego jest rysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie, które reprezentuje styl informacji na temat tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowany jako liczba całkowita (zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em granic znak.</param>
        <param name="origin">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt, w którym tekst rozpoczyna się.</param>
        <param name="format">Element <see cref="T:System.Drawing.StringFormat" /> , który określa formatowanie informacje, takie jak linia odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Rectangle * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, za pomocą którego jest rysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie, które reprezentuje styl informacji na temat tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowany jako liczba całkowita (zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em granic znak.</param>
        <param name="layoutRect">A <see cref="T:System.Drawing.Rectangle" /> reprezentujący prostokąt, który granic tekstu.</param>
        <param name="format">Element <see cref="T:System.Drawing.StringFormat" /> , który określa formatowanie informacje, takie jak linia odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Do dodania.</param>
        <param name="family">A <see cref="T:System.Drawing.FontFamily" /> reprezentujący nazwę czcionki, za pomocą którego jest rysowana testu.</param>
        <param name="style">A <see cref="T:System.Drawing.FontStyle" /> wyliczenie, które reprezentuje styl informacji na temat tekstu (pogrubienie, kursywa i tak dalej). Musi to być rzutowany jako liczba całkowita (zobacz przykładowy kod w dalszej części tej sekcji).</param>
        <param name="emSize">Wysokość pola kwadratowy em granic znak.</param>
        <param name="layoutRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który granic tekstu.</param>
        <param name="format">Element <see cref="T:System.Drawing.StringFormat" /> , który określa formatowanie informacje, takie jak linia odstępów i wyrównania tekstu.</param>
        <summary>Dodaje ciąg tekstowy do tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberSignature Language="F#" Value="member this.ClearMarkers : unit -&gt; unit" Usage="graphicsPath.ClearMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie znaczniki z tej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A> metodę w celu utworzenia znacznik w bieżącej lokalizacji w <xref:System.Drawing.Drawing2D.GraphicsPath>. Użyj <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> metody do iteracji przez istniejące znaczniki w ścieżce.  
  
 Znaczniki są używane do oddzielania grup ścieżek podrzędnych. Jeden lub więcej ścieżek podrzędnych mogą być zawarte między znacznikami dwa.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka obiektów do ścieżki.  
  
-   Dodaje znaczniki do ścieżki.  
  
-   Czyści wszystkie znaczniki ze ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="graphicsPath.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy dokładną kopię tej ścieżki.</summary>
        <returns>
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> Ta metoda tworzy, rzutowany jako obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka wartości do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
-   Klony kopię tej ścieżki.  
  
-   Rysuje nowej ścieżki do ekranu.  
  
 Należy zauważyć, że wywołanie <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A> metody musi być rzutowany jako <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberSignature Language="F#" Value="member this.CloseAllFigures : unit -&gt; unit" Usage="graphicsPath.CloseAllFigures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie otwarte dane w tej ścieżce i uruchamia nowy rysunek. Łącząc linię z punktu końcowego punktu początkowego na zamknięcie każdego otwartego rysunku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka otwartych figur do ścieżki.  
  
-   Zamyka wszystkie dane w ścieżce.  
  
-   Rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberSignature Language="F#" Value="member this.CloseFigure : unit -&gt; unit" Usage="graphicsPath.CloseFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący rysunek i uruchamia nowy rysunek. Jeśli bieżący rysunek zawiera sekwencję połączonych linii i krzywych, metoda zamyka pętli, łącząc linię z punktu końcowego do punktu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Ten kod tworzy trójkąt, tworząc nową ścieżkę, uruchamianie rysunku, dodając dwa wiersze przecinających się do wartości i zamknięcie rysunek w celu utworzenia trójkąt. Ścieżka jest następnie rysowane na ekranie.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphicsPath.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> umożliwia zasoby używane przez to <xref:System.Drawing.Drawing2D.GraphicsPath> zostają przeniesione do innych celów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberSignature Language="F#" Value="member this.FillMode : System.Drawing.Drawing2D.FillMode with get, set" Usage="System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie, które określa, jak wnętrza kształty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</summary>
        <value>A <see cref="T:System.Drawing.Drawing2D.FillMode" /> wyliczenie, który określa sposób wnętrza kształty w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> są wypełnione.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphicsPath.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje sekwencję segmenty linii połączonej każdej krzywej w tej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberSignature Language="F#" Value="member this.Flatten : unit -&gt; unit" Usage="graphicsPath.Flatten " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje sekwencję segmenty linii połączonej każdej krzywej w tej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Flatten matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> o którą należy przekształcić to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> przed spłaszczanie.</param>
        <summary>Stosuje przekształcenia określony, a następnie konwertuje każdy krzywej w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> sekwencję segmenty linii połączonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Flatten (matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> o którą należy przekształcić to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> przed spłaszczanie.</param>
        <param name="flatness">Określa maksymalny błąd dozwolone między krzywej i jego spłaszczonych zbliżenia. Wartość 0,25 jest domyślna. Zmniejszenie był zwiększy liczbę segmentów w zbliżenia.</param>
        <summary>Konwertuje każdy krzywej w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> sekwencję segmenty linii połączonej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę grafiki i macierzy tłumaczenia.  
  
-   Dodaje krzywej do ścieżki w cztery punkty.  
  
-   Rysuje ścieżki (krzywa) do ekranu, za pomocą czarnego pióra.  
  
-   Przenosi krzywa, szczegółów 10 pikseli i spłaszcza go.  
  
-   Rysuje krzywą na ekranie za pomocą czerwonego pióra.  
  
 Należy zauważyć, że czerwone krzywej ma spłaszczone wiersze łączenia punktów.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberSignature Language="F#" Value="member this.GetBounds : unit -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt otaczający jest zależne od typu zakończenia, szerokość i limit ukośnych pióra i w związku z tym tworzy "luźne Dopasuj" do ścieżki ograniczonego. Przybliżony formuła jest: początkowej prostokąt otaczający jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skos, a także niektórych dodatkowych marginesie, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę grafiki.  
  
-   Dodaje elipsę (okrąg) i pobiera je do ekranu.  
  
-   Pobiera prostokąt otaczający koła wywołaniem <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> i rysuje prostokąt na ekranie.  
  
-   Tworzy drugi ścieżki grafiki.  
  
-   Dodaje okrąg i rozszerza się ścieżkę do szerokości 10.  
  
-   Rysuje ścieżki do ekranu.  
  
-   Pobiera prostokąt otaczający drugi koła.  
  
-   Rysuje prostokąt otaczający do ekranu.  
  
-   Wyświetla rozmiar prostokąta w oknie dialogowym.  
  
 Zwróć uwagę, że prostokąt otaczający po prawej stronie jest większa (do konta dodatkową szerokość linii).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> , Który określa przekształcenia mają być stosowane do tej ścieżki, przed obliczeniem prostokąt otaczający. Ta ścieżka nie jest trwale przekształcane; Transformacja jest używany tylko podczas obliczania prostokąt otaczający.</param>
        <summary>Zwraca prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gdy ta ścieżka jest przekształcana przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt otaczający jest zależne od typu zakończenia, szerokość i limit ukośnych pióra i w związku z tym tworzy "luźne Dopasuj" do ścieżki ograniczonego. Przybliżony formuła jest: początkowej prostokąt otaczający jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skos, a także niektórych dodatkowych marginesie, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix * System.Drawing.Pen -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds (matrix, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">
          <see cref="T:System.Drawing.Drawing2D.Matrix" /> , Który określa przekształcenia mają być stosowane do tej ścieżki, przed obliczeniem prostokąt otaczający. Ta ścieżka nie jest trwale przekształcane; Transformacja jest używany tylko podczas obliczania prostokąt otaczający.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Za pomocą którego do rysowania <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Zwraca prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas bieżącej ścieżki jest przekształcana przez określony <see cref="T:System.Drawing.Drawing2D.Matrix" /> i pobierane z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który to granic <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar zwróconego prostokąt otaczający jest zależne od typu zakończenia, szerokość i limit ukośnych pióra i w związku z tym tworzy "luźne Dopasuj" do ścieżki ograniczonego. Przybliżony formuła jest: początkowej prostokąt otaczający jest zwiększony przez szerokość strony, a wynik jest mnożony przez limit skos, a także niektórych dodatkowych marginesie, aby umożliwić zakończenia.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberSignature Language="F#" Value="member this.GetLastPoint : unit -&gt; System.Drawing.PointF" Usage="graphicsPath.GetLastPoint " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ostatniego punktu w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> Tablica to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>A <see cref="T:System.Drawing.PointF" /> reprezentujący ostatniego punktu w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod powoduje utworzenie ścieżki, dodaje wiersz do ścieżki i następnie pobiera ostatniego punktu w ścieżce.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Element <see cref="T:System.Drawing.Point" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Element <see cref="T:System.Drawing.PointF" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Element <see cref="T:System.Drawing.Point" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie. Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Element <see cref="T:System.Drawing.PointF" /> , który określa lokalizację do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie. Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie. Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> zdarzeń. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodanie prostokąta do ścieżki.  
  
-   Tworzy szerokiego pióra i rozszerza się ścieżkę, z tym pióra (Aby przykład bardziej zrozumiały)  
  
-   Testuje punkt (100, 50) aby zobaczyć, jeśli leży w (w) jednej krawędzi prostokąta, wywołując <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>.  
  
 Wynik jest wyświetlany w oknie komunikatu (w tym przypadku, true). Innymi słowy krawędzi jest renderowany za pośrednictwem tego punktu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" /> Do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> podczas rysowania z określonym <see cref="T:System.Drawing.Pen" /> i przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ciągu (pod) konturu tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> zgodnie z określonym <see cref="T:System.Drawing.Pen" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza, czy zarys podanej ścieżce jest renderowany widoczne w określonym punkcie. Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.Point" /> reprezentujący punkt do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.PointF" /> reprezentujący punkt do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej przeciwnym <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, przy użyciu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
-   Sprawdza, czy określony punkt znajduje się w ścieżce.  
  
-   Wyświetla wyniki w oknie dialogowym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x punktu do testowania.</param>
        <param name="y">Współrzędna y punktu do testowania.</param>
        <param name="graphics">
          <see cref="T:System.Drawing.Graphics" /> Do których chcesz przetestować widoczności.</param>
        <summary>Wskazuje, czy określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> w regionie widoczne klipu określonego <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Ta metoda zwraca <see langword="true" /> Jeśli określony punkt znajduje się w ramach tej <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Współrzędne punktu testowanego są podane w współrzędne świata. Przekształcenia macierzy `graphics` parametru tymczasowo zostanie zastosowany przed testowanie pod kątem widoczności.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathData : System.Drawing.Drawing2D.PathData" Usage="System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Drawing.Drawing2D.PathData" /> która hermetyzuje tablic punkty (<paramref name="points" />) i typy (<paramref name="types" />) dla tego <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <value>A <see cref="T:System.Drawing.Drawing2D.PathData" /> która hermetyzuje tablice zarówno punktów i typy w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathPoints : System.Drawing.PointF[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkty w ścieżce.</summary>
        <value>Tablica <see cref="T:System.Drawing.PointF" /> obiekty reprezentujące ścieżkę.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathTypes : byte[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typy odpowiednich punktach w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> tablicy.</summary>
        <value>Tablica bajtów określa typy odpowiednich punktów w ścieżce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica bajtów zwróconych przez <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A> właściwość określa typy punktów i flagi dla punktów danych w ścieżce. Dla każdego punktu Usługi bits od 0 do 2 wskazać typ punktu, a usługi bits 3 do 7, przytrzymaj zestaw flag, które określają atrybuty punktu. W poniższej tabeli przedstawiono możliwe wartości i ich znaczenie.  
  
|Wartość|Znaczenie|  
|-----------|-------------|  
|0|Wskazuje, czy punkt znajduje się początku rysunku.|  
|1|Wskazuje, że punkt znajduje się jeden z dwóch punktów końcowych linii.|  
|3|Wskazuje, że punkt znajduje się punkt końcowy lub punktu kontrolnego Beziera trzeciego stopnia.|  
|0x7|Maski bitów wszystkie z wyjątkiem trzy mniej znaczące bity, które wskazuje typ punktu.|  
|0x20|Określa, czy punkt znajduje się znacznik.|  
|0x80|Określa, że punkt znajduje się ostatniego punktu w zamkniętym podrzędną (rysunek).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PointCount : int" Usage="System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> lub <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy.</summary>
        <value>Liczba całkowita określająca liczbę elementów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> lub <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablicy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="graphicsPath.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opróżnia <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> i <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" /> tablice i ustawia <see cref="T:System.Drawing.Drawing2D.FillMode" /> do <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje kilka podstawowych do niego.  
  
-   Rysuje tablica punktów ścieżki do ekranu.  
  
-   Resetuje stan pusty ścieżki.  
  
-   Tablica punktów należy uzyskuje ponownie (jeśli istnieje).  
  
-   Rysuje tablicy do ekranu.  
  
 Zwróć uwagę, czy znajdzie żadna macierz następujący po wywołaniu resetowania.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="graphicsPath.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność punktów w <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> Tablica to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę, a następnie dodaje kilka podstawowych do ścieżki.  
  
-   Rysuje tablica punktów ścieżki do ekranu.  
  
-   Rysuje tablica odwróconej punktów do ekranu.  
  
 Zauważ, że drugi listę punktów w odwrotnej kolejności z pierwszego.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberSignature Language="F#" Value="member this.SetMarkers : unit -&gt; unit" Usage="graphicsPath.SetMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia znacznik, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy znacznik w ścieżce, który może służyć do oddzielania części ścieżki. Następnie można użyć <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A> metody iteracyjne przeglądanie znaczników w ścieżce.  
  
 Znaczniki są używane do oddzielania grup ścieżek podrzędnych. Jeden lub więcej ścieżek podrzędnych mogą być zawarte między znacznikami dwa w ścieżce.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod powoduje utworzenie ścieżki i dodaje kilka podstawowych do ścieżki oddzielone znaczniki i rysuje ścieżki do ekranu.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberSignature Language="F#" Value="member this.StartFigure : unit -&gt; unit" Usage="graphicsPath.StartFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia nowy rysunek bez zamykania bieżącego rysunku. Wszystkie kolejne punkty dodane do ścieżki są dodawane do tej nowej liczby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik musi przechowywać oryginalnych punktów, jeśli są one potrzebne. Oryginalny punkty są konwertowane na sześcienny punktów kontrolnych Beziera wewnętrznie, w związku z tym nie ma mechanizmu do zwracania oryginalnych punktów.  
  
 Ta metoda rozpoczyna nowe podrzędną w ścieżce. Podrzędne umożliwiają ścieżkę należy oddzielić sekcje i użyj <xref:System.Drawing.Drawing2D.GraphicsPathIterator> klasy do iteracji podrzędnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę.  
  
-   Dodaje dwa zestawy danych. Pierwszy zestaw danych łączy czterech podstawowych w dwóch cyfr. Drugi zestaw danych łączy ten sam czterech elementów podstawowych (z tą różnicą, że są one przesunięcie w osi y) w trzech wyników.  
  
-   Rysuje wszystkich danych na ekranie.  
  
 Należy zauważyć różnicę w wyglądzie między dwoma zestawami danych.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Transform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> reprezentujący przekształcenie do zastosowania.</param>
        <summary>Dotyczy to macierzy transformacji <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przekształcenie można skalować, tłumaczenie, obracanie lub pochylić <xref:System.Drawing.Drawing2D.GraphicsPath>.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje elipsy do ścieżki.  
  
-   Rysuje ścieżki do ekranu.  
  
-   Tworzy macierzy transformacji do translacji ścieżki, 100 jednostek w kierunku osi x.  
  
-   Rysuje przekształcone ścieżki do ekranu.  
  
 Zwróć uwagę, że oryginalna elipsy jest wstawiany czarno przekształcone wielokropka jest rysowana w kolorze czerwonym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stosuje przekształcenia warp, zdefiniowanym przez prostokąt i równoległobok, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcane. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, w prawym dolnym rogu równoległobok jest implikowana przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który jest przekształcany w równoległobok definicją <c>destPoints</c>.</param>
        <summary>Stosuje przekształcenia warp, zdefiniowanym przez prostokąt i równoległobok, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcane. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, w prawym dolnym rogu równoległobok jest implikowana przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który jest przekształcany w równoległobok definicją <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> określający geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <summary>Stosuje przekształcenia warp, zdefiniowanym przez prostokąt i równoległobok, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiuje równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcane. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, w prawym dolnym rogu równoległobok jest implikowana przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który jest przekształcany w równoległobok definicją <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> określający geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> wyliczenia, która określa, czy ta operacja warp korzysta z punktu widzenia lub tryb warianty punktowego.</param>
        <summary>Stosuje przekształcenia warp, zdefiniowanym przez prostokąt i równoległobok, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode * single -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Tablica <see cref="T:System.Drawing.PointF" /> struktur, które definiują równoległobok prostokąta zdefiniowanych przez <c>srcRect</c> jest przekształcane. Tablica może zawierać trzech lub czterech elementów. Jeśli tablica zawiera trzy elementy, w prawym dolnym rogu równoległobok jest implikowana przez pierwsze trzy punkty.</param>
        <param name="srcRect">A <see cref="T:System.Drawing.RectangleF" /> reprezentujący prostokąt, który jest przekształcany w równoległobok definicją <c>destPoints</c>.</param>
        <param name="matrix">A <see cref="T:System.Drawing.Drawing2D.Matrix" /> określający geometrycznych przekształcenie do zastosowania do ścieżki.</param>
        <param name="warpMode">A <see cref="T:System.Drawing.Drawing2D.WarpMode" /> wyliczenia, która określa, czy ta operacja warp korzysta z punktu widzenia lub tryb warianty punktowego.</param>
        <param name="flatness">To wartość z zakresu od 0 do 1, który określa sposób prostego wynikowy ścieżkę. Aby uzyskać więcej informacji, zobacz <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" /> metody.</param>
        <summary>Stosuje przekształcenia warp, zdefiniowanym przez prostokąt i równoległobok, w tym <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje prostokąta do ścieżki.  
  
-   Rysuje prostokąt tego ekranu w kolorze czarnym.  
  
-   Wygięciach ścieżkę z punktu widzenia warp.  
  
-   Rysuje prostokąt zawijać (ścieżka) do ekranu w kolorze czerwonym.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ta ścieżka jest zastępowany krzywych, które należy umieścić obszar, który jest wypełniony, gdy ta ścieżka jest rysowana przez pióro określony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen -&gt; unit" Usage="graphicsPath.Widen pen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">Element <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konspekt oryginalnej ścieżki i konspektu nowych, ta metoda tworzy.</param>
        <summary>Dodaje dodatkowe konspektu do ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy, w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, za pomocą odległość między wierszami istniejących i nowych konspektu równe, szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast następnie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Widen (pen, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">Element <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konspekt oryginalnej ścieżki i konspektu nowych, ta metoda tworzy.</param>
        <param name="matrix">Element <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa przekształcenie do zastosowania do ścieżki przed rozszerzanie.</param>
        <summary>Dodaje dodatkowe konspektu do <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy, w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, za pomocą odległość między wierszami istniejących i nowych konspektu równe, szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast następnie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Aby uzyskać przykład, zobacz <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Widen (pen, matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Element <see cref="T:System.Drawing.Pen" /> , który określa szerokość między konspekt oryginalnej ścieżki i konspektu nowych, ta metoda tworzy.</param>
        <param name="matrix">Element <see cref="T:System.Drawing.Drawing2D.Matrix" /> , który określa przekształcenie do zastosowania do ścieżki przed rozszerzanie.</param>
        <param name="flatness">Wartość, która określa płaskość dla krzywych.</param>
        <summary>Zastępuje to <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> przy użyciu krzywych, które należy ująć obszar, który jest wypełniona, ta ścieżka jest rysowana przez określony pióra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kontur wokół oryginalnych wierszy, w tym <xref:System.Drawing.Drawing2D.GraphicsPath>, za pomocą odległość między wierszami istniejących i nowych konspektu równe, szerokość <xref:System.Drawing.Pen> używane w wywołaniu <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>. Jeśli chcesz wypełnić odstępy między wierszami należy użyć <xref:System.Drawing.Graphics.FillPath%2A> zamiast następnie <xref:System.Drawing.Graphics.DrawPath%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu jest przeznaczony do użytku z formularzami Windows Forms i wymaga <xref:System.Windows.Forms.PaintEventArgs> `e`, <xref:System.Windows.Forms.Form.OnPaint%2A> obiektem zdarzenia. Kod wykonuje następujące czynności:  
  
-   Tworzy ścieżkę i dodaje dwie elipsy do ścieżki.  
  
-   Rysuje ścieżkę w kolorze czarnym.  
  
-   Rozszerzenie ścieżki.  
  
-   Rysuje ścieżkę na czerwono.  
  
 Zwróć uwagę, drugi renderowanie używa <xref:System.Drawing.Graphics.FillPath%2A> zamiast <xref:System.Drawing.Graphics.DrawPath%2A>, i dlatego renderowanych rysunek konspektu wypełnione.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
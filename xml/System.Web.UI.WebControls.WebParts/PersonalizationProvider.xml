<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="43d8d7b00883883629c9828d4f9138bcfdfb0f48" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69394987" /></Metadata><TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementuje podstawowe funkcje dla dostawcy personalizacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to abstrakcyjna klasa bazowa, która definiuje wymagane funkcje dostawcy personalizacji. Dostawca personalizacji ładuje i przechowuje dane personalizacji w imieniu <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> wystąpienia.  
  
 Klasa bazowa definiuje standardowe zachowanie dla wielu metod; tylko te metody, które w odniesieniu do bazowego magazynu danych są oznaczone jako abstrakcyjne. Dzięki temu deweloper może napisać niestandardowego dostawcę w celu współdziałania z określonym magazynem danych, bez konieczności ponownego implementowania standardowych funkcji używanych przez <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> klasę.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Można utworzyć <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> i podać implementacje tylko dla metod abstrakcyjnych zdefiniowanych w tej klasie. Metody abstrakcyjne dotyczą głównie zapisywania i ładowania danych do fizycznego magazynu danych oraz do administrowania magazynem danych. Dostawca niestandardowy musi mieć możliwość manipulowania informacjami o personalizacji w sposób, który odróżnia <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> dane od <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> danych. Ponadto dostawca musi segmentować dane personalizacji według stron oraz według aplikacji.  
  
Implementacje <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> programu są ściśle powiązane z implementacjami, <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> ponieważ niektóre metody <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />dostawcy personalizacji zwracają wystąpienia klas pochodnych. Aby ułatwić rozwój dostawców niestandardowych, <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> Klasa bazowa obejmuje domyślną implementację logiki personalizacji i logiki serializacji/deserializacji, która jest używana bezpośrednio <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> przez klasę. W związku z tym tworzenie niestandardowego dostawcy wyłącznie na potrzeby pracy z innym magazynem danych wymaga tylko implementacji następujących metod abstrakcyjnych: 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />-Ta metoda musi być w stanie policzyć liczbę wierszy danych personalizacji w bazie danych dla dostarczonych parametrów zapytania.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />-Dana ścieżka i nazwa użytkownika, ta metoda ładuje dwa duże obiekty binarne (BLOB) z bazy danych: jeden obiekt BLOB dla danych udostępnionych i jeden dla danych użytkownika. W przypadku podania nazwy użytkownika i ścieżki nie jest potrzebna <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> kontrolka do uzyskiwania dostępu do informacji o stronie, które mogą podawać informacje o nazwie użytkownika/ścieżce.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />— Dana ścieżka i nazwa użytkownika to metoda usuwa odpowiedni wiersz z bazy danych. W przypadku podania nazwy użytkownika i ścieżki nie jest potrzebna <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> kontrolka do uzyskiwania dostępu do informacji o stronie, które mogą podawać informacje o nazwie użytkownika/ścieżce.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />-Podana ścieżka i nazwa użytkownika Metoda zapisuje podany obiekt BLOB do bazy danych. W przypadku podania nazwy użytkownika i ścieżki nie jest potrzebna <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> kontrolka do uzyskiwania dostępu do informacji o stronie, które mogą podawać informacje o nazwie użytkownika/ścieżce.  
  
We wszystkich tych metodach, jeśli zostanie podana tylko ścieżka, która wskazuje na to, że udostępnione dane personalizacji strony są obsługiwane. Jeśli ścieżka i nazwa użytkownika są przenoszone do metody, należy zareagować na dane personalizacji użytkownika dla strony. W przypadku <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, dane udostępnione dla określonej ścieżki powinny być zawsze ładowane i opcjonalnie należy załadować dane personalizacji użytkownika dla ścieżki, jeśli nazwa użytkownika nie <see langword="null" />jest.  
  
Wszystkie inne metody abstrakcyjne są przeznaczone do użytku tylko w aplikacjach administracyjnych i nie są używane przez infrastrukturę składniki Web Part w czasie wykonywania. Aby zapoznać się z przykładem implementacji dostawcy personalizacji, zapoznaj <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> się z klasą.</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">Kontrolki składniki Web Part ASP.NET</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Omówienie personalizacji składniki Web Part</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/784d8z92(v=vs.100)">Przewodnik: Implementowanie personalizacji składniki Web Part przy użyciu kontrolki użytkownika</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178182(v=vs.100)">Personalizacja składniki Web Part</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ jest to Konstruktor klasy abstrakcyjnej, należy zastąpić tę metodę, aby utworzyć wystąpienie klasy, która dziedziczy z tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera lub ustawia nazwę aplikacji skonfigurowanej dla dostawcy.</summary>
        <value>Aplikacja skonfigurowana dla dostawcy personalizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nazwa aplikacji nie została określona w pliku konfiguracji przy użyciu [elementu Providers do personalizacji dla składników WebPart (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) , używana jest wartość <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> właściwości.  
  
> [!CAUTION]
>  Ponieważ pojedyncze domyślne wystąpienie dostawcy personalizacji jest używane dla wszystkich żądań obsłużonych przez <xref:System.Web.HttpApplication> obiekt, można wykonywać wiele żądań jednocześnie, a każda próba <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> ustawienia wartości właściwości. Właściwość nie jest bezpieczna wątkowo dla wielu zapisów, a <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> zmiana wartości właściwości może spowodować nieoczekiwane zachowanie dla wielu użytkowników aplikacji. <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Zaleca się unikanie kodu umożliwiającego użytkownikom ustawienie właściwości, <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> chyba że jest to wymagane. <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Ustawienie właściwości może być wymagane na przykład w aplikacji administracyjnej, która zarządza danymi personalizacji dla wielu aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> obiektów reprezentujących zestaw znanych funkcji używanych przez zestaw kontrolek składniki Web Part.</summary>
        <returns><see cref="T:System.Collections.IList" /> Reprezentuje zestaw znanych możliwości używany przez zestaw kontrolek składniki Web Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie ta metoda zwraca listę zawierającą dwie możliwości: <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> i. <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> Są to domyślne możliwości, które można zdefiniować w elemencie autoryzacji w celu personalizacji elementów [WebPart (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) w [elemencie personalizacji dla elementu WebParts (ASP.NET ustawień schematu)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) sekcja konfiguracji [elementu WebParts (Schemat ustawień ASP.NET)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) . Jeśli zdecydujesz się na wdrożenie niestandardowej infrastruktury personalizacji, możesz zastąpić tę metodę i zdefiniować własny zestaw możliwości użytkownika związanych z autoryzacją.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Który zarządza informacjami o personalizacji.</param>
        <param name="loadedState">Informacje o stanie personalizacji.</param>
        <summary>Określa, czy początkowy zakres personalizacji powinien <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> być <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> lub zakresem.</summary>
        <returns>Wskazuje, czy bieżący zakres personalizacji to <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> czy <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />. <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy bieżący zakres powinien być <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> lub <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, w odniesieniu do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolki i informacji o stanie personalizacji, które zostały już wcześniej załadowane w cyklu życia personalizacji. Te informacje są używane przez <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> wystąpienie do kolejnych zadań związanych z personalizacją.  
  
 Następujące reguły są używane do określania zakresu personalizacji:  
  
-   Początkowo należy <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>przyjąć zakres.  
  
-   Jeśli aktualnie wykonywane konto użytkownika nie jest uwierzytelnione, zakres jest ustawiany na <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Jeśli aktualnie wykonywane konto użytkownika jest uwierzytelniane, dodatkowe przetwarzanie odbywa się w kolejności pierwszeństwa:  
  
    -   Jeśli strona jest w trybie ogłaszania zwrotnego, żądanie strony zawiera informacje o zakresie z poprzedniego renderowania strony. Jeśli informacje o zakresie wskazują, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> że zakres został użyty, zakres jest obliczany na <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Jeśli aktualnie wykonywana strona ma kontrolę przekazaną do niej z innej strony (na przykład w przypadku, gdy transfer kontroli zaszło z powodu <xref:System.Web.HttpServerUtility.Transfer%2A> wywołania metody; należy zauważyć, że to konkretne sprawdzenie nie występuje w przypadku ogłaszania wielostronicowego), a jeśli wcześniej wykonanie strony miało <xref:System.Web.UI.WebControls.WebParts.WebPartManager> wystąpienie, zakres jest ustawiany na wartość `Personalization.Scope` właściwości z poprzedniego <xref:System.Web.UI.WebControls.WebParts.WebPartManager> wystąpienia.  
  
    -   Jeśli poprzednie kryteria nie są spełnione, zakres szacuje wartość <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> właściwości bieżącego <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formantu.  
  
 Po wykonaniu poprzednich ocen i jeśli zakres ocenia <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres, wykonywane jest następujące przetwarzanie:  
  
-   Jeśli aktualnie wykonywane konto użytkownika ma <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> możliwość, zakres pozostaje ustawiony na. <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>  
  
-   Jeśli aktualnie wykonywane konto użytkownika nie ma <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> możliwości, zakres jest resetowany do. <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>  
  
-   Jeśli wynikiem wszystkich poprzednich ocen zakresu jest <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, ten wynik jest przechowywany jako pole ukryte na aktualnie wykonywanym stronie. Jest to mechanizm, za pomocą którego strona może odtworzyć ocenę zakresu podczas kolejnych ogłaszania zwrotnego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Strona skojarzona z <paramref name="webPartManager" /> programem <see langword="null" />ma wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie informacjami o personalizacji.</param>
        <summary>Zwraca słownik zawierający <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> wystąpienia, które reprezentują możliwości związane z personalizacją aktualnie wykonywanego konta użytkownika.</summary>
        <returns>Zawierające zero lub więcej <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> wystąpień, jeśli konto użytkownika zostanie uwierzytelnione lub <see langword="null" /> nie jest uwierzytelnione wykonywanie konta użytkownika. <see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślna implementacja tej metody zużywa informacje z [elementu autoryzacji do personalizacji elementu WebParts (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) w [elemencie personalizacji dla składników WebParts (ASP.NET ustawień schematu)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) w pliku Machine. config lub Web. config elementu składnika WebParts [(ASP.NET Settings Schema)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) , aby określić autoryzowane możliwości użytkownika.  
  
 Możliwości <xref:System.Collections.IList> w słowniku będą elementami członkowskimi obiektu zwróconego <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> przez metodę <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> , które obecnie <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> obejmują możliwości i możliwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strona skojarzona z <paramref name="webPartManager" /> programem <see langword="null" />ma wartość.  
  
—lub— 
Żądanie skojarzone ze stroną to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> Z informacjami o personalizacji, które mają być wysyłane do zapytania. Ta wartość nie może <see langword="null" />być.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> zawierające zapytanie. Ta wartość może być <see langword="null" />równa.</param>
        <param name="pageIndex">Lokalizacja, w której zostanie uruchomione zapytanie.</param>
        <param name="pageSize">Liczba rekordów do zwrócenia.</param>
        <param name="totalRecords">Całkowita liczba dostępnych rekordów.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca kolekcję zawierającą obiekty zerowe <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />lub bardziej pochodne na podstawie zakresu i określonych parametrów zapytania.</summary>
        <returns>Obiekt zawierający zero lub więcej <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />obiektów pochodnych. <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjną definicją metody administracyjnej na potrzeby wykonywania zapytań dotyczących danych personalizacji. Implementacje pochodne powinny postępować zgodnie z logiką opisaną poniżej.  
  
 `pageIndex` Zestaw zwracanych elementów jest ograniczony przez parametry i `pageSize` , gdzie `pageSize` ustawia liczbę rekordów do zwrócenia i `pageIndex` ustawia rekordy do zwrócenia. Na przykład `pageIndex` liczba 0 i a `pageSize` z 25 zwróci pierwsze 25 `pageIndex` wystąpień, a a z 1 i a `pageSize` 25 zwróci wystąpienia 26-50. Jeśli chcesz pobrać wszystkie dostępne rekordy, ustaw `pageIndex` wartość na 0 i `pageSize` na <xref:System.Int32.MaxValue>.  
  
 Obiekty pochodne są zwracane w kolejności alfabetycznej i sortowane według kombinacji wartości ich <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> właściwości, zarówno w kolejności rosnącej. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>  
  
 Ta metoda przekazuje symbole wieloznaczne zapytania do bazowego magazynu danych. Obsługa symboli wieloznacznych jest obecnie zależna od tego, jak każdy dostawca obsługuje znaki takie jak gwiazdka (*), symbol procentu (%) lub podkreślenie (_).  
  
 Zwykle w przypadku magazynów danych zgodnych z językiem SQL można wykonać wyszukiwanie przy użyciu symboli wieloznacznych w częściowej ścieżce z symbolem wieloznacznym na początku, na końcu lub w środku tekstu ciągu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> wyszukiwania we właściwości. Na przykład aby znaleźć wszystkie ścieżki, które zaczynają się\~od "/vdir" <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> , właściwość zostanie ustawiona na "\~/vdir%".  
  
 Podobnie wyszukiwanie przy użyciu symboli wieloznacznych częściowej nazwy użytkownika może mieć symbol wieloznaczny w dowolnym momencie w ciągu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> tekstowym właściwości. Na przykład, aby znaleźć wszystkie nazwy użytkowników, które zaczynają się od "Jan <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> ", parametr będzie wyglądać podobnie jak "Jan%".  
  
 Stosowane są następujące ograniczenia zapytania:  
  
-   `scope` Jeśli podano tylko, a `query` to `null` lub wszystkie właściwości `query` zwracanych `null` lub wartości domyślnych, zwracane są wszystkie rekordy pasujące do wskazanego `scope` parametru.  
  
-   Jeśli właściwość nie `null`jest, zwracane rekordy są również filtrowane na podstawie ścieżek, które pasują do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> wartości. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>  
  
-   Jeśli właściwość nie `null`jest, zwracane rekordy są również filtrowane na podstawie nazw użytkowników, które pasują do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> wartości właściwości. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>  
  
-   Jeśli właściwość nie jest równa <xref:System.DateTime.MaxValue>, zwracane rekordy są również filtrowane, aby zwracały tylko te rekordy, które są skojarzone z nieaktywnymi użytkownikami. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Porównanie zawiera rekordy, w <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> których właściwość jest mniejsza lub równa <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> właściwości.  
  
 Należy zauważyć, że ta metoda nie weryfikuje kombinacji parametrów zapytania. Na przykład kod może zażądać zestawu rekordów stanu personalizacji skojarzonych z określoną nazwą użytkownika w zakresie udostępnionym. Ponieważ nazwy użytkowników nie są skojarzone z informacjami udostępnionymi, zwrócona kolekcja będzie pusta.  
  
 Kombinacje parametrów, które mają możliwość zwrócenia niepustej kolekcji, obejmują:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>zakres w połączeniu z <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> właściwością.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>zakres w połączeniu z wartościami dla którejkolwiek lub wszystkich <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>właściwości, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>i <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> Informacje o personalizacji, które mają być wysyłane do zapytania. Ta wartość nie może <see langword="null" />być.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> zawierające zapytanie. Ta wartość może być <see langword="null" />równa.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca liczbę wierszy w źródłowym magazynie danych, które znajdują się w określonym zakresie.</summary>
        <returns>Liczba wierszy w źródłowym magazynie danych, które istnieją dla określonego <paramref name="scope" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjną definicją metody administracyjnej do pobierania liczby danych personalizacji. Implementacje pochodne powinny postępować zgodnie z logiką opisaną poniżej.  
  
 Ta metoda przekazuje symbole wieloznaczne zapytania do bazowego magazynu danych. Obsługa symboli wieloznacznych jest obecnie zależna od tego, jak każdy dostawca obsługuje znaki takie jak gwiazdka (*), symbol procentu (%) lub podkreślenie (_).  
  
 Zwykle w przypadku magazynów danych zgodnych z językiem SQL można wykonać wyszukiwanie przy użyciu symboli wieloznacznych w częściowej ścieżce z symbolem wieloznacznym na początku, na końcu lub w środku tekstu ciągu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> wyszukiwania we właściwości. Na przykład aby znaleźć wszystkie ścieżki, które zaczynają się\~od "/vdir" <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> , właściwość zostanie ustawiona na "\~/vdir%".  
  
 Podobnie wyszukiwanie przy użyciu symboli wieloznacznych częściowej nazwy użytkownika może mieć symbol wieloznaczny w dowolnym momencie w ciągu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> tekstowym właściwości. Na przykład, aby znaleźć wszystkie nazwy użytkowników, które zaczynają się od "Jan <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> ", parametr będzie wyglądać podobnie jak "Jan%".  
  
 Stosowane są następujące ograniczenia zapytania:  
  
-   Jeśli `scope` podano tylko, i `query` jest `null` lub wszystkie właściwości w `query` zwracanych `null` wartościach lub domyślnych, są zliczane wszystkie rekordy pasujące `scope` do wskazanego parametru.  
  
-   Jeśli właściwość nie `null`jest, zliczane rekordy są również filtrowane na podstawie ścieżek, które pasują do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> wartości. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>  
  
-   Jeśli właściwość nie `null`jest, zliczane rekordy są również filtrowane na podstawie nazw użytkowników, które pasują do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> wartości właściwości. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>  
  
-   Jeśli właściwość nie jest równa <xref:System.DateTime.MaxValue>, to zliczane rekordy są również filtrowane, aby zwracały tylko te rekordy, które są skojarzone z nieaktywnymi użytkownikami. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Porównanie zawiera rekordy, w <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> których właściwość jest mniejsza lub równa <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> właściwości.  
  
 Należy zauważyć, że ta metoda nie weryfikuje kombinacji parametrów zapytania. Na przykład kod może zażądać liczby rekordów stanu personalizacji skojarzonych z określoną nazwą użytkownika w zakresie udostępnionym. Ponieważ nazwy użytkowników nie są skojarzone z informacjami udostępnionymi, zwrócona liczba będzie równa zero.  
  
 Kombinacje parametrów, które mogą zwracać liczbę różną od zera, obejmują:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>zakres w połączeniu z <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> właściwością.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>zakres w połączeniu z wartościami dla którejkolwiek lub wszystkich <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>właściwości, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>i <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie danymi personalizacji.</param>
        <param name="path">Ścieżka do informacji o personalizacji, która ma być używana jako klucz pobierania.</param>
        <param name="userName">Nazwa użytkownika dla informacji personalizacji, która ma być używana jako klucz pobierania.</param>
        <param name="sharedDataBlob">Dane zwrócone dla <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> zakresu.</param>
        <param name="userDataBlob">Dane zwrócone dla <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> zakresu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ładuje pierwotne dane personalizacji z bazowego magazynu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy `webPartManager`, które pochodzą <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> z i implementują tę metodę, powinny `path`używać parametrów `username` , i jako kluczy pobierania. Bez względu na to, jak dane są przechowywane w magazynie danych (niektóre magazyny danych mogą wykonywać niektóre typy inteligentnych magazynów), dane personalizacji muszą być zwracane jako spakowany zestaw bajtów w dwóch tablicach. Zwracane dane muszą być zgodne z następującymi regułami:  
  
-   Dane dla <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu muszą zawsze być zwracane `sharedDataBlob` w parametrze.  
  
-   W zależności od wartości <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> klucza dane są zwracane w parametrze.`userDataBlob` `null` Wartość nie jest wartością `userName` parametru wskazuje, że <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> dane powinny być również pobierane.  
  
 Dostawca personalizacji, który pochodzi <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> z i implementuje tę metodę, może zoptymalizować interakcje z magazynem danych, pobierając wszystkie dane personalizacji w jednej rundie, zamiast <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> pobierać <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> i danych w dwóch Rozdziel podróże.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie danymi personalizacji.</param>
        <param name="ignoreCurrentUser"><see cref="T:System.Boolean" /> Wskazuje, czy nazwa użytkownika powinna być przenoszona do dostawcy personalizacji.</param>
        <summary>Ładuje dane pierwotne z bazowego magazynu danych i konwertuje je na <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> obiekt.</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> Zawierające dane personalizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównym punktem wejścia używanym przez <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> klasę do ładowania danych personalizacji. Implementacja domyślna ładuje pierwotne dane z bazowego magazynu danych (funkcja jest zaimplementowana w dostawcach pochodnych), a następnie konwertuje pierwotne <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> dane na wystąpienie.  
  
 Jeśli parametr ma wartość `true`, do <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> metody nie jest przenoszona żadna nazwa użytkownika. `ignoreCurrentUser` Dostawca personalizacji może wybrać interpretowanie tego stanu tak, aby tylko stan personalizacji <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> z zakresem był pobierany z bazowego magazynu danych.  
  
 Gdy metoda jest wykonywana, <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> wywołuje metodę, a istnieją trzy typy błędów deserializacji, które mogą wystąpić podczas ładowania stanu. <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> W przypadku wystąpienia tych konkretnych błędów nie jest zgłaszany żaden wyjątek i zdarzenia błędów są rejestrowane zamiast funkcji monitorowania kondycji (Aby uzyskać informacje na temat monitorowania kondycji i uzyskiwania dostępu do dzienników utworzonych przez ten program, zobacz [Omówienie monitorowania kondycji ASP.NET](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). Poniższe trzy scenariusze powodują, że zdarzenia błędów deserializacji są zapisywane w dzienniku:  
  
-   Nieudana próba deserializacji typu właściwości, który używa ciągu <xref:System.ComponentModel.TypeConverter>.  
  
-   Nieudana próba deserializacji typu właściwości, który używa serializacji binarnej.  
  
-   Próba deserializacji typu właściwości nie powiodła się, ponieważ nie można utworzyć wystąpienia typu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> Ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException">Strona skojarzona z <paramref name="webPartManager" /> programem <see langword="null" />ma wartość.  
  
—lub— 
Żądanie skojarzone ze stroną to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie danymi personalizacji.</param>
        <param name="path">Ścieżka do informacji o personalizacji, która ma być używana jako klucz magazynu danych.</param>
        <param name="userName">Nazwa użytkownika dla informacji personalizacji, która ma być używana jako klucz magazynu danych.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program usuwa pierwotne dane personalizacji z bazowego magazynu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy `webPartManager`, które pochodzą <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> z i implementują tę metodę, powinny `path`używać parametrów `userName` , i jako kluczy magazynu. Implementacje pochodne muszą modyfikować magazyn danych, tak aby dane personalizacji dostarczonych kluczy magazynu zostały skutecznie usunięte. Jest to do implementacji pochodnych, co pozwala na ich fizyczne wykonanie.  
  
 Pochodny dostawca personalizacji musi mieć możliwość rozróżnienia danych personalizacji dla poszczególnych stron. Ponadto dla danego stanu strony dostawca personalizacji musi mieć możliwość rozróżnienia <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> określania zakresu danych. Jeśli podano nieprawidłową`null` nazwę użytkownika, operacja resetowania ma zastosowanie <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> do zakresu; w przeciwnym razie operacja <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> resetowania ma zastosowanie do zakresu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie danymi personalizacji.</param>
        <summary>Resetuje dane personalizacji do bazowego magazynu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównym punktem wejścia używanym przez <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> klasę do resetowania danych personalizacji. Domyślna implementacja używa <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolki do określenia ścieżki i nazwy użytkownika, które mają zostać zresetowane. Domyślna implementacja następnie wywołuje <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPartManager" />nie jest skojarzony ze stroną.  
  
—lub— 
Strona nie jest skojarzona z w toku <see cref="T:System.Web.HttpRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> Informacje o personalizacji, które mają zostać zresetowane. Ta wartość nie może <see langword="null" />być.</param>
        <param name="paths">Ścieżki dla informacji personalizacji, które mają zostać usunięte.</param>
        <param name="usernames">Nazwy użytkowników dla informacji personalizacji, które mają zostać usunięte.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, usuwa stan personalizacji z bazowego magazynu danych na podstawie określonych parametrów.</summary>
        <returns>Liczba usuniętych wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjną definicją metody administracyjnej do usuwania danych personalizacji. Implementacje pochodne powinny postępować zgodnie z logiką opisaną poniżej.  
  
 Ta metoda nie obsługuje wyszukiwania znaków wieloznacznych. Jeśli dostawca personalizacji udostępnia dane z magazynu danych obsługującego transakcje, ta metoda powinna wykonywać operacje jako pojedynczą niepodzielną transakcję.  
  
 Dozwolone są tylko następujące kombinacje parametrów:  
  
-   Parametr jest ustawiony, a wszystkie inne parametry są ustawione na `null`. `scope` Ta kombinacja usuwa wszystkie składniki Web Part dane personalizacji skojarzone z zakresem personalizacji `scope`wskazywanym przez.  
  
-   Parametr jest ustawiony, `paths` a parametr zawiera co najmniej jedną wartość. `scope` Ta kombinacja usuwa wszystkie składniki Web Part dane personalizacji dla określonej ścieżki lub ścieżek w zakresie personalizacji wskazanym `scope`przez.  
  
-   Parametr jest ustawiony na <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, `paths` parametr jest ustawiany `usernames` i zawiera tylko jedną wartość, a parametr zawiera co najmniej jedną wartość. `scope` Ta kombinacja usuwa wszystkie dane personalizacji użytkownika składniki Web Part dla danej ścieżki skojarzonej z użytkownikiem lub użytkownikami zawartymi w `usernames`temacie.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> `paths` `null`Parametr jest ustawiony na, parametr jest ustawiony na, a `usernames` parametr zawiera co najmniej jedną wartość. `scope` Ta kombinacja usuwa wszystkie personalizacje poszczególnych użytkowników składniki Web Part danych we wszystkich ścieżkach skojarzonych z użytkownikiem lub użytkownikami zawartymi w `usernames`temacie.  
  
 Każda inna kombinacja wartości parametrów jest nieprawidłowa i zgłosi <xref:System.ArgumentException> wyjątek. W szczególnych przypadkach następujące dwie kombinacje są niedozwolone:  
  
-   Nie `usernames` można podać parametru, gdy `scope` jest ustawiony na <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Parametr nie może zawierać więcej niż jednego wpisu, `usernames` gdy parametr nie `null`jest. `paths`  
  
 Wszystkie `paths`wartościparametrówzawarte w odpowiednich tablicach muszą być zgodne z następującymi regułami walidacji. `usernames` W przypadku niepowodzenia jakichkolwiek reguł walidacji dla każdego elementu członkowskiego tablic <xref:System.ArgumentException> parametrów zostanie zgłoszony wyjątek. Reguły sprawdzania poprawności są następujące:  
  
-   `null`wartości są niedozwolone.  
  
-   Pusty ciąg ("") jest niedozwolony. Parametry powinny być przycinane przed przeprowadzeniem pustego sprawdzania ciągu.  
  
-   `usernames` Parametr nie może zawierać przecinków (,).  
  
-   Długość `paths` parametru nie może być większa niż 256 znaków w przypadku bazy danych SQL.  
  
-   Długość `usernames` parametru nie może być większa niż 256 znaków w przypadku bazy danych SQL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do danych personalizacji, które mają zostać usunięte. Ta wartość może być <see langword="null" /> niepustym ciągiem ("").</param>
        <param name="userInactiveSinceDate">Data oznaczająca czas ostatniego zmiany danych personalizacji przez użytkownika witryny sieci Web.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program usuwa składniki Web Part dane personalizacji z bazowego magazynu danych na podstawie określonych parametrów.</summary>
        <returns>Liczba wierszy usuniętych z bazowego magazynu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjną definicją metody administracyjnej do usuwania danych personalizacji. Należy zauważyć, że ta metoda ma wpływ tylko na dane personalizacji użytkownika i nie udostępnia danych.  
  
 Implementacje pochodne powinny postępować zgodnie z logiką opisaną poniżej:  
  
-   `path` Parametr nie może zawierać symboli wieloznacznych.  
  
-   Jeśli dostawca udostępnia dane z magazynu danych obsługującego transakcje, ta metoda powinna wykonywać operacje w pojedynczej niepodzielnej transakcji.  
  
-   Jeśli parametr nie jest`null`, wówczas tylko rekordy personalizacji poszczególnych użytkowników skojarzone z programem `path` zostaną usunięte. `path`  
  
-   Tylko rekordy personalizacji poszczególnych użytkowników skojarzone z użytkownikami, które są uważane za nieaktywne, od `userInactiveSinceDate` daty wskazanej w parametrze zostaną usunięte. W każdym przypadku rekordy <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> , które są mniejsze lub <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> równe, są usuwane.  
  
-   Jeśli są podane oba parametry, rekordy, które pasują do obu ograniczeń, są usuwane.  
  
-   Parametr może być `null`. `path`  
  
-   `path` Parametr nie może być pustym ciągiem. Należy ją przycinanie przed wykonaniem tego sprawdzenia.  
  
-   Właściwość nie może być `null`. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Zarządzanie danymi personalizacji.</param>
        <param name="path">Ścieżka do informacji o personalizacji, która ma być używana jako klucz magazynu danych.</param>
        <param name="userName">Nazwa użytkownika dla informacji personalizacji, która ma być używana jako klucz.</param>
        <param name="dataBlob">Tablica bajtów danych do zapisania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, program zapisuje pierwotne dane personalizacji do bazowego magazynu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest abstrakcyjną definicją metody używanej do zapisywania nieprzetworzonych danych personalizacji w źródłowym magazynie danych.  
  
 Implementacje pochodne powinny używać `webPartManager`parametrów `path`, i `userName` jako kluczy magazynu. Pochodny dostawca personalizacji musi mieć możliwość rozróżnienia danych personalizacji dla poszczególnych stron. Ponadto dla stanu danej strony dostawca musi mieć możliwość rozróżnienia między <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresem. `dataBlob` `dataBlob` <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Jeśli podano nazwę niebędącą <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> użytkownikiem, parametr jest w zakresie; w przeciwnym razie przyjęto, że parametr jest w zakresie.`null`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> Zawierające dane personalizacji, które mają zostać zapisane.</param>
        <summary>Zapisuje dane personalizacji w magazynie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest głównym punktem wejścia używanym przez <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> klasę do zapisywania danych personalizacji.  
  
 Domyślna implementacja tej metody używa metod wewnętrznej implementacji <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> , aby spakować dane personalizacji do tablicy bajtów. Jeśli wyniki tego pakowania tworzą pustą tablicę bajtową (ponieważ Wyodrębnianie właściwości spowodowało brak danych personalizacji), domyślna implementacja wywołuje <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> metodę. W przeciwnym razie domyślna implementacja wywoła <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="state" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Zapisany obiekt ma inny typ <paramref name="state" /> od obiektu <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> , który został zwrócony przez metodę. <paramref name="state" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="IPersonalizable" FullName="System.Web.UI.WebControls.WebParts.IPersonalizable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c4607d8f3145d7baae6242847fae9c9eaa5ffb0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36585135" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IPersonalizable" />
  <TypeSignature Language="F#" Value="type IPersonalizable = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Definiuje dodatkowe funkcje zarządzania dla aplikacji i wyodrębniania stanu personalizacji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oprócz używania `Personalizable` atrybutu dla właściwości formantu formantu można też wdrożyć <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> dla dodatkowe funkcje zarządzania dla aplikacji i wyodrębniania stanu personalizacji. Na przykład formantów, które muszą zarządzać informacji o stanie prywatnej powinien zawierać implementację tego interfejsu. Formanty, które spersonalizowane dane dotyczące dostępu za pomocą mechanizmów złożonych, takich jak niestandardowe pamięci podręcznej rozwiązań, trwałości danych Komputery mainframe firmy lub usług XML sieci Web, powinny również implementować ten interfejs.  
  
> [!IMPORTANT]
>  Nie należy dodać typy oparte na klas zdefiniowanych w katalogu App_Code i następnie zależą od domyślnego mechanizmu serializacji binarnej. Na podstawie App_Code artefakty nie są spójnie pliku binarnego do serializacji na fakt, że mają nazwy zestawu zmieniony w losowo wybranym momencie w czasie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interfejsu. Przykład obejmuje strony .aspx, która odwołuje się formant składnika Web Part o nazwie `UrlListWebPart`. Następujący kod to plik .aspx, na przykład.  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 Poniższy kod stanowi źródło niestandardowe <xref:System.Web.UI.WebControls.WebParts.WebPart> formantu. Ten plik należy umieścić w katalogu App_Code.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 Ładowanie strony w przeglądarce. Wpisz nazwę, aby reprezentować adresu URL, a następnie dodaj rzeczywisty adres URL rozpoczynający się od `http://`i kliknij przycisk **Dodaj** przycisk, aby dodać adres URL.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zostały wprowadzone zmiany danych niestandardowych, która zarządza formantu.</summary>
        <value>
          <see langword="true" /> Jeśli dane niestandardowe zarządzanych za pomocą <see cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" /> interfejs został zmieniony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zmianie danych zarządzanych przez kontrolkę, jest on uznawany za "zakłóconych". Formant powinien zwrócić `true` Jeśli danych niestandardowych it zarządza za pośrednictwem <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> interfejs został zmieniony. Jeśli formant zwraca `true` z tej właściwości, formantu <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> implementacja metody interfejsu jest wywoływana podczas wyodrębniania wartości właściwości.  
  
> [!NOTE]
>  Ta właściwość jest sprawdzana automatycznie przez infrastrukturę personalizacji fazach ostatnie przetwarzania żądania POST. Jednak dla żądania GET, wartość zwracana z <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> właściwość nie jest zaznaczona. Niektóre inne zdarzenie ma spowodował kontroli wziąć pod uwagę "zakłóconych" dla dowolnego stanu kontroli — nie tylko dane zarządzane przez <xref:System.Web.UI.WebControls.WebParts.IPersonalizable>— do zapisania. Jeśli formant można oznaczyć się jako "brudne" podczas żądania GET lub infrastruktury personalizacji w niektórych warunkach bardzo określonych granic uwzględnia formantu "zakłóconych" podczas żądania GET, następnie <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> zawsze zostanie wywołana.  
  
 Formant może odwoływać się jego skojarzony <xref:System.Web.UI.WebControls.WebParts.WebPartManager> sterowania i sprawdź <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> właściwości w celu określenia bieżącego zakresu. Stan "zakłóconych" Kontrolki niestandardowe dane powinny być odpowiednie dla bieżącego zakresu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> właściwości. Pierwsza część przykładzie jest stronę sieci Web, która obsługuje <xref:System.Web.UI.WebControls.WebParts.WebPart> formantu.  
  
 [!code-aspx-csharp[WebParts_IPersonalizable_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/IPersonalizableCS.aspx#1)]
 [!code-aspx-vb[WebParts_IPersonalizable_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/IPersonalizableVB.aspx#1)]  
  
 Druga część przykładzie jest kod niestandardowy <xref:System.Web.UI.WebControls.WebParts.WebPart> formantu o nazwie `UrlListWebPart`. Ten plik należy umieścić w katalogu App_Code, aby uruchomić przykład. Należy pamiętać, że kod źródłowy implementuje <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> właściwości.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 Ładowanie strony w przeglądarce. Wpisz nazwę, aby reprezentować adresu URL, a następnie dodaj rzeczywisty adres URL rozpoczynający się od `http://`i kliknij przycisk **Dodaj** przycisk, aby dodać adres URL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="iPersonalizable.Load state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> zawiera niestandardowe dane z zakresu został załadowany z odpowiedni magazyn danych.</param>
        <summary>Ładuje dane niestandardowe w formancie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana w formancie, aby zezwolić na ładowanie danych niestandardowych do samej siebie. Może on również zwrócić wartość, która wskazuje, czy stan niestandardowego formantu muszą być zapisane ponownie odpowiedni magazyn danych, niezależnie od tego, czy inne dane personalizacji na stronie uległa zmianie. Formantu można ustawić niestandardowe właściwości i przeprowadzić dodatkową logikę wewnętrznego, na podstawie wartości zawartych w słowniku personalizacji. Ta metoda jest wywoływana przez formant części sieci Web została ustawiona podczas zastosowania danych personalizacji do formantu.  
  
 Należy wziąć pod uwagę zachowanie scalania <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-zakres i <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>-właściwości zawarte w zakresie <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> obiektu. `state` Parametr zawiera scalone reprezentację danych niestandardowych, został załadowany z odpowiedni magazyn danych. W <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres wartości, które zostały wcześniej dodane po w samej strony <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres będzie dostępna. W <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu, jeśli skojarzona wartość <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu personalizacji miał jedną wartość dodane po stronie w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu, a inną wartość po stronie w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu, a następnie będzie infrastruktury personalizacji Uwzględnij tylko <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-zakres wartości (w przeciwieństwie do <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres wartości) w ramach `state` parametru.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia implementację programu <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> w niestandardowej metody <xref:System.Web.UI.WebControls.WebParts.WebPart> formantu. Pełny kod wymagany do uruchomienia tego przykładu, w sekcji przykładu w <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> Przegląd klasy.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="iPersonalizable.Save state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> zawiera niestandardowe dane z zakresu został załadowany z odpowiedni magazyn danych.</param>
        <summary>Zapisuje właściwości niestandardowych i informacje o stanie wewnętrznego w formancie <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolki serwera może przechowywać własne niestandardowe właściwości i stan wewnętrzny informacje <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> określony w `state` parametru. Informacje są przechowywane w postaci serii pary nazwa/wartość. Jest odpowiedzialny za formant do użycia pary nazwa/wartość, które może rozpoznać podczas kolejnych wywołań sterowanie za pośrednictwem <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> metody.  
  
 Formant może odwoływać się jego skojarzony <xref:System.Web.UI.WebControls.WebParts.WebPartManager> sterowania i sprawdź <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope> obiektem, aby określić bieżącego zakresu. Informacje o stanie niestandardowych powinny być odpowiednie dla bieżącego zakresu. Należy pamiętać, że każdy <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> wartość, która jest dodawana do <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> powinna być skojarzona z wartością odpowiedni zakres obiektu, ponieważ infrastruktury personalizacji zależy, to podczas scalania <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>-zakres danych niestandardowych przed przekazaniem go do <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A> metody.  
  
 Używając standardowej implementacji ASP.NET części sieci Web, formanty musi upewnij się, czy obiekty umieszczone w słowniku stanu może być Zserializowany przez platformę ASP.NET <xref:System.Web.UI.ObjectStateFormatter> klasy. W praktyce oznacza to następujące czynności:  
  
-   Typy pierwotne .NET Framework, ciągi i zorientowane na kolekcję typów .NET Framework, takich jak tablic, list tablicy tablic skrótów i słowników hybrydowych, są automatycznie do serializacji.  
  
-   Niestandardowe typy, które dostarczają własne <xref:System.ComponentModel.TypeConverter> klas serializacji do i deserializacji z ciągów są traktowane jako możliwy do serializacji.  
  
-   Niestandardowe typy, które może być serializowany przez <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> klasy są traktowane jako możliwy do serializacji.  
  
> [!IMPORTANT]
>  Nie należy dodać typy oparte na klas zdefiniowanych w katalogu App_Code i następnie zależą od domyślnego mechanizmu serializacji binarnej. Na podstawie App_Code artefakty nie są spójnie pliku binarnego do serializacji na fakt, że mają nazwy zestawu zmieniony w losowo wybranym momencie w czasie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje implementacja <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> w niestandardowej metody <xref:System.Web.UI.WebControls.WebParts.WebPart> formantu. Pełny kod wymagany do uruchomienia tego przykładu, w sekcji przykładu w <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> Przegląd klasy.  
  
 [!code-csharp[WebParts_IPersonalizable_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/CS/urllistwebpart.cs#2)]
 [!code-vb[WebParts_IPersonalizable_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_IPersonalizable_Overview/VB/urllistwebpart.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
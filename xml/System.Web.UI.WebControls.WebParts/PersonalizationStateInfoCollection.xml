<Type Name="PersonalizationStateInfoCollection" FullName="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c2902976b755112a54bbbf9a04484d09032683c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69394939" /></Metadata><TypeSignature Language="C#" Value="public sealed class PersonalizationStateInfoCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PersonalizationStateInfoCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PersonalizationStateInfoCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationStateInfoCollection sealed : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type PersonalizationStateInfoCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera kolekcję <see cref="T:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo" /> obiektów i <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> .</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa zawiera otokę opartą na kolekcji na <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> zestawie wystąpień i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo>. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> Te wystąpienia są pobierane przez sekwencyjne iteracje kolekcji, przez indeks porządkowy lub wartość klucza.  
  
 Wystąpienia są indeksowane przy użyciu kombinacji ścieżki i nazwy użytkownika. Jest to konieczne, <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> ponieważ wystąpienia reprezentujące dane udostępnione są indeksowane według <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> obiektu, a <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienia są indeksowane przy użyciu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> zarówno obiektu, jak i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> obiektu.  
  
 Obiekty informacji są przechowywane w kolekcji w kolejności, w jakiej zostały odebrane od dostawcy. Kolekcja nie próbuje zmienić kolejności wystąpień lub zachować określonej kolejności sortowania w kolekcji.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationStateInfoCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationStateInfoCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pustą kolekcję.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (data As PersonalizationStateInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo -&gt; unit" Usage="personalizationStateInfoCollection.Add data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />
      </Parameters>
      <Docs>
        <param name="data">Wystąpienie <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />pochodne, które ma zostać dodane.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />Dodaje wystąpienie pochodne do końca kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>wystąpienie pochodne do końca kolekcji. Wewnętrznie liczba kolekcji jest zwiększana o jeden. Wszystkie moduły wyliczające aktualnie aktywne względem kolekcji są unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Podjęto próbę dodania obiektu do kolekcji, gdy wystąpienie tego samego stanu udostępnionego lub dla użytkownika już istnieje w kolekcji.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr danych ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="personalizationStateInfoCollection.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści kolekcję wszystkich elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie moduły wyliczające aktualnie aktywne względem kolekcji są unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PersonalizationStateInfo(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] * int -&gt; unit" Usage="personalizationStateInfoCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, do której są kopiowane elementy w kolekcji.</param>
        <param name="index">Lokalizacja, w której ma zostać rozpoczęta operacja kopiowania.</param>
        <summary>Kopiuje elementy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcji <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> do tablicy, zaczynając od określonej pozycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz utworzyć <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> tablicę. Ta metoda po prostu wywołuje <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> metodę i `array` przekazuje parametry i `index` .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w kolekcji.</summary>
        <value>Liczba elementów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w kolekcji może służyć do iteracji w kolekcji, jak pokazano w przykładzie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count%2A> jak używać właściwości.  
  
 [!code-csharp[WebParts_PersAdmin#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_PersAdmin/CS/PersAdmin.ascx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="personalizationStateInfoCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca standardowy moduł wyliczający, który może wykonać iterację kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda również przywraca moduł wyliczający z powrotem do tego położenia. W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.IEnumerator.Current%2A>wartości. Aby uzyskać więcej informacji na temat modułów wyliczających, zobacz <xref:System.Collections.IEnumerator>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Instrukcja języka(`for each` w Visual Basic) ukrywa złożoność modułów wyliczających. C# `foreach` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcji jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do kolekcji jest synchronizowany; w przeciwnym razie. <see langword="false" /> Wartość jest zawsze <see langword="false" /> dla <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> obiektów utworzonych przez zestaw kontrolek składniki Web Part.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Właściwość zwraca obiekt, który może służyć do synchronizowania dostępu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection>do. <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera element z kolekcji na podstawie określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[int] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Porządkowy indeks obiektu do pobrania.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> Pobiera wystąpienie znajdujące się w określonym indeksie porządkowym w kolekcji.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> Wystąpienie zlokalizowane w określonym indeksie porządkowym w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> wystąpienie znajdujące się w określonym indeksie porządkowym w kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[string path, string username] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(path As String, username As String) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[System::String ^, System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(System::String ^ path, System::String ^ username); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka aplikacji obiektu stanu personalizacji do pobrania.</param>
        <param name="username">Nazwa <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> użytkownika obiektu do pobrania.</param>
        <summary>Pobiera element z kolekcji na podstawie określonych parametrów.</summary>
        <value>Element z kolekcji na podstawie określonych parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest domyślnym indeksatorem dla kolekcji. Jeśli podano tylko `path` , właściwość <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> zwraca wystąpienie. Jeśli oba `path` i `username` są podane <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> , właściwość zwraca wystąpienie dla kombinacji `path` i `username`.  
  
 Jeśli `path` (w przypadku, `username` gdy jest ustawiony na `null`) nie istnieje, lub jeśli `username` i `path` nie istnieje, `null` jest zwracana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string path, string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string path, string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (path As String, username As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ path, System::String ^ username);" />
      <MemberSignature Language="F#" Value="member this.Remove : string * string -&gt; unit" Usage="personalizationStateInfoCollection.Remove (path, username)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka aplikacji obiektu stanu personalizacji, który ma zostać usunięty.</param>
        <param name="username">Nazwa <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" />użytkownika obiektu pochodnego, który ma zostać usunięty.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />Usuwa obiekt pochodny z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>wystąpienie pochodne z kolekcji. Wszystkie elementy po usuniętym wystąpieniu są przenoszone w górę w celu założenia wolnej pozycji. Wewnętrznie liczba kolekcji jest zmniejszana o jeden. Wszystkie moduły wyliczające aktualnie aktywne względem kolekcji są unieważnione.  
  
 Jeśli podano tylko `path` , <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpienie dla tej ścieżki zostanie usunięte. Jeśli oba `path` i `username` `path` `username` są podane, wystąpieniedlakombinacjiizostanieusunięte.<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo>  
  
> [!NOTE]
>  Możesz spróbować usunąć nieistniejący element z kolekcji. Ta akcja nie spowoduje zgłoszenia wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />ma wartość null.  
  
—lub— 
oba parametry mają wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="public void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReadOnly();" />
      <MemberSignature Language="F#" Value="member this.SetReadOnly : unit -&gt; unit" Usage="personalizationStateInfoCollection.SetReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza kolekcję jako tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody, które próbują zmodyfikować kolekcję tylko do odczytu, na przykład <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add%2A> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove%2A>, zgłosić <xref:System.NotSupportedException> wyjątek.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly%2A> Metodę można wywołać wiele razy w kolekcji. nie spowoduje to wygenerowanie wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> wystąpienia.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />. Zestaw kontrolny składniki Web Part zwraca odwołanie do obiektu bieżącej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Klasy pochodne mogą udostępniać własne synchronizowane wersje kolekcji przy użyciu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> właściwości. Kod synchronizacji musi wykonywać operacje na <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> kolekcji, nie bezpośrednio w samej kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W celu zapewnienia prawidłowej synchronizacji z innymi wątkami, które mogą jednocześnie modyfikować wystąpienie kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, do której zostaną skopiowane <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> kolekcje obiektów.</param>
        <param name="index">Punkt, w <paramref name="array" /> którym należy rozpocząć <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> kopiowanie obiektów.</param>
        <summary>Implementuje metodę bazową <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda, taka jak <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> Metoda własna <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo%2A> klasy, po prostu wywołuje metodę i przekazuje `array` parametry i `index` .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="PersonalizationStateInfoCollection" FullName="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69ce08073f8abedd7cb297be70f68b3d880135fe" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30688679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PersonalizationStateInfoCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PersonalizationStateInfoCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PersonalizationStateInfoCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationStateInfoCollection sealed : System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia kolekcję <see cref="T:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo" /> i <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> Klasa udostępnia otokę opartego na kolekcji w zestawie <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpień. Wystąpienia te są pobierane przez sekwencyjnie Iterowanie przez kolekcję, indeksem lub wartość klucza.  
  
 Wystąpienia są indeksowane na kombinacji ścieżka i nazwa użytkownika. Jest to konieczne, ponieważ <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpień reprezentujący udostępnionych danych są indeksowane według <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> obiektu, natomiast <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienia są indeksowane według obu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> obiektu i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> obiektu.  
  
 Obiekty informacje znajdują się w kolekcji w kolejności, w jakiej zostały odebrane od dostawcy. Kolekcja nie spróbuj zmienić kolejność wystąpienia lub obsługa porządek sortowania określonych w kolekcji.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationStateInfoCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationStateInfoCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pustej kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (data As PersonalizationStateInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-Pochodnych wystąpienie do dodania.</param>
        <summary>Dodaje <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-pochodnego wystąpienia na końcu kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-pochodnego wystąpienia na końcu kolekcji. Wewnętrznie liczba kolekcji jest zwiększany o jeden. Wszystkie wyliczenia, które są aktualnie aktywne w odniesieniu do kolekcji zostały unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Nastąpiła próba można dodać obiektu do kolekcji, jeśli wystąpienie tego samego udostępnionego lub stanu użytkownika już istnieje w kolekcji.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr danych ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści Kolekcja wszystkich elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie wyliczenia, które są aktualnie aktywne w odniesieniu do kolekcji zostały unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PersonalizationStateInfo(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^&gt; ^ array, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica elementów w kolekcji są kopiowane do.</param>
        <param name="index">Lokalizacja, w którym można uruchomić operacji kopiowania.</param>
        <summary>Kopiuje elementy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcji do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> tablicy, zaczynając od określonej pozycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz utworzyć <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> tablicy. Ta metoda wywołuje po prostu <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> — metoda i przekazuje `array` i `index` parametrów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w kolekcji.</summary>
        <value>Liczba elementów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w kolekcji może służyć do iterowania po kolekcji, jak pokazano w przykładzie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count%2A> właściwości.  
  
 [!code-csharp[WebParts_PersAdmin#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_PersAdmin/CS/PersAdmin.ascx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca standardowy moduł wyliczający może Iterowanie po kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> — Metoda powoduje również moduł wyliczający do tej pozycji. W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>. Aby uzyskać więcej informacji na moduły wyliczające, zobacz <xref:System.Collections.IEnumerator>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcji jest zsynchronizowany (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do kolekcji jest synchronizowane; w przeciwnym razie <see langword="false" />. Wartość jest zawsze <see langword="false" /> dla <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> obiekty utworzone przez zestaw kontroli części sieci Web.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> Właściwość zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera element z kolekcji na podstawie określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[int] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">{Numer porządkowy indeks obiektu do pobrania.</param>
        <summary>Pobiera <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> wystąpienie znajduje się pod określonym indeksem w kolekcji.</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> wystąpienie znajduje się pod określonym indeksem w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> wystąpienie znajduje się pod określonym indeksem w kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.  
  
 \- lub -  
  
 <paramref name="index" /> jest większa niż <see cref="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[string path, string username] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(path As String, username As String) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[System::String ^, System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(System::String ^ path, System::String ^ username); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna aplikacji można pobrać obiektu stanu personalizacji.</param>
        <param name="username">Nazwa użytkownika <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> obiektu do pobrania.</param>
        <summary>Pobiera element z kolekcji na podstawie określonych parametrów.</summary>
        <value>Element z kolekcji na podstawie określonych parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest indeksatora domyślne dla kolekcji. Jeśli tylko `path` podano właściwość zwraca <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpienia. Jeśli oba `path` i `username` podano właściwość zwraca <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienia dla kombinacji `path` i `username`.  
  
 Jeśli `path` (w przypadku którego `username` ma ustawioną wartość `null`) nie istnieje, lub jeśli `username` i `path` nie istnieją, `null` jest zwracany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string path, string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string path, string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (path As String, username As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ path, System::String ^ username);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna aplikacji do usunięcia obiektu stanu personalizacji.</param>
        <param name="username">Nazwa użytkownika <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" />-pochodnych obiektu do usunięcia.</param>
        <summary>Usuwa <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-pochodnych obiekt z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-pochodzące z kolekcji wystąpień. Po wystąpieniu usuniętych elementów są przenieść w górę zajmować wolnych pozycji. Wewnętrznie liczba kolekcji jest zmniejszana o jeden. Wszystkie wyliczenia, które są aktualnie aktywne w odniesieniu do kolekcji zostały unieważnione.  
  
 Jeśli tylko `path` jest dostępne, a następnie <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpienie dla tej ścieżki jest usuwany. Jeśli oba `path` i `username` są udostępniane, a następnie <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienia dla kombinacji `path` i `username` zostaną usunięte.  
  
> [!NOTE]
>  Możesz spróbować usunąć nieistniejącego elementu z kolekcji; Ta akcja nie zgłosi wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ma wartość null.  
  
 \- lub -  
  
 oba parametry mają wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="public void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza kolekcji tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody, które próbuje zmodyfikować kolekcji tylko do odczytu, takich jak <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add%2A> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove%2A>, throw <xref:System.NotSupportedException> wyjątku.  
  
> [!NOTE]
>  Możesz wywołać <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly%2A> metody wiele razy w kolekcji; spowoduje to nie zgłaszał wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> wystąpienia.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />. Zestaw kontroli części sieci Web zwraca odwołanie do bieżącego obiektu kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Klasy pochodne zapewniają własnych zsynchronizowanej wersji przy użyciu kolekcji <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> właściwości. Synchronizowanie kodu musi wykonywać operacje <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie wystąpienie kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, do którego kolekcja <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> obiekty zostaną skopiowane.</param>
        <param name="index">Punkt w <c>tablicy</c> w którym należy rozpocząć kopiowanie <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> obiektów.</param>
        <summary>Implementuje podstawowym <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody, takiej jak <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo%2A> metoda, po prostu wywołuje <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> — metoda i przekazuje `array` i `index` parametrów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
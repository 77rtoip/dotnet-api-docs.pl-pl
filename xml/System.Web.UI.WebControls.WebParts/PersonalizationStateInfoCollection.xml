<Type Name="PersonalizationStateInfoCollection" FullName="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52d81fb64ac9bf9a4ad499543e3634e04680d7d0" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48587388" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PersonalizationStateInfoCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PersonalizationStateInfoCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PersonalizationStateInfoCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationStateInfoCollection sealed : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type PersonalizationStateInfoCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera zbiór <see cref="T:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo" /> i <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> Klasy udostępnia otokę kolekcja oparta na zestawie <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpień. Te wystąpienia są pobierane przez sekwencyjnie Iterowanie przez kolekcję instrukcji, indeksu porządkowe lub według wartości kluczy.  
  
 Wystąpienia są indeksowane na kombinacji ścieżkę i nazwę użytkownika. Jest to konieczne, ponieważ <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpień reprezentujący udostępnionych danych są indeksowane, zgodnie z opisem w <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> obiektu, natomiast <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienia są indeksowane według obu <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> obiektu i <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> obiektu.  
  
 Obiekty informacji są obsługiwane w kolekcji w kolejności, w której zostały odebrane od dostawcy. Kolekcja nie próbuje zmienić kolejność wystąpienia lub zachować porządek sortowania określonych w tej kolekcji.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationStateInfoCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationStateInfoCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pustą kolekcję.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (data As PersonalizationStateInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo -&gt; unit" Usage="personalizationStateInfoCollection.Add data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-Pochodnych wystąpienia mają zostać dodane.</param>
        <summary>Dodaje <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-pochodnego wystąpienia na końcu kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta umożliwia dodanie <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-pochodnego wystąpienia na końcu kolekcji. Wewnętrznie liczba kolekcji jest zwiększany o jeden. Wszystkie moduły wyliczające aktualnie aktywnego względem kolekcji są unieważniane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">Aby dodać obiekt do kolekcji, jeśli wystąpienie tego samego udostępnionego nastąpiła próba lub stanu użytkownika już istnieje w kolekcji.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr danych ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="personalizationStateInfoCollection.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści kolekcję wszystkie elementy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie moduły wyliczające aktualnie aktywnego względem kolekcji są unieważniane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PersonalizationStateInfo(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] * int -&gt; unit" Usage="personalizationStateInfoCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica elementów w kolekcji są kopiowane do.</param>
        <param name="index">Lokalizacja, w którym można uruchomić operacji kopiowania.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcji do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> tablicy, zaczynając od określonej pozycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli chcesz utworzyć <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> tablicy. Ta metoda po prostu wywołuje <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> metody i przekazuje `array` i `index` parametrów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w kolekcji.</summary>
        <value>Liczba elementów w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w kolekcji może służyć do iterowania po kolekcji, jak pokazano w przykładzie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count%2A> właściwości.  
  
 [!code-csharp[WebParts_PersAdmin#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_PersAdmin/CS/PersAdmin.ascx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="personalizationStateInfoCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca standardowy moduł wyliczający stanie Iterowanie po kolekcji. Ta metoda nie może być dziedziczona.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda przełącza moduł wyliczający do tej pozycji. W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>. Aby uzyskać więcej informacji na temat modułów wyliczających, zobacz <xref:System.Collections.IEnumerator>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 `foreach` Instrukcja języka C# (`for each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> kolekcja jest synchronizowana (wątkowo).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do kolekcji jest zsynchronizowana; w przeciwnym razie <see langword="false" />. Wartość jest zawsze <see langword="false" /> dla <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> obiekty utworzone przez zestaw formantów części sieci Web.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> Właściwość zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera element z kolekcji, w oparciu o określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[int] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeksem porządkowym obiektu do pobrania.</param>
        <summary>Pobiera <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> wystąpienie znajduje się w określonym indeksie numer porządkowy w kolekcji.</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> wystąpienie znajduje się w określonym indeksie numer porządkowy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia pobranie <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> wystąpienie znajduje się w określonym indeksie numer porządkowy w kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero.  
  
\- lub — 
 <paramref name="index" /> jest większa niż <see cref="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[string path, string username] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(path As String, username As String) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[System::String ^, System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(System::String ^ path, System::String ^ username); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna aplikacji personalizacji stanu obiektu do pobrania.</param>
        <param name="username">Nazwa użytkownika <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> obiektu do pobrania.</param>
        <summary>Pobiera element z kolekcji, w oparciu o określonych parametrów.</summary>
        <value>Element z kolekcji, w oparciu o określonych parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest indeksator domyślne dla kolekcji. Jeśli tylko `path` zostanie podana, właściwości zwracają <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpienia. Jeśli oba `path` i `username` są udostępniane, właściwość ta zwraca <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienie kombinacji `path` i `username`.  
  
 Jeśli `path` (w przypadku którego `username` jest ustawiona na `null`) nie istnieje, lub, jeśli `username` i `path` nie istnieją, `null` jest zwracana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string path, string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string path, string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (path As String, username As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ path, System::String ^ username);" />
      <MemberSignature Language="F#" Value="member this.Remove : string * string -&gt; unit" Usage="personalizationStateInfoCollection.Remove (path, username)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna aplikacji obiekt stanu personalizacji, który ma zostać usunięty.</param>
        <param name="username">Nazwa użytkownika <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" />-pochodzi obiekt do usunięcia.</param>
        <summary>Usuwa <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-pochodną obiektu kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-pochodną wystąpienie kolekcji. Wszelkie elementy po wystąpieniu usunięto zajmować wolne stanowisko są przenoszone w górę. Wewnętrznie liczba kolekcji jest zmniejszana o jeden. Wszystkie moduły wyliczające aktualnie aktywnego względem kolekcji są unieważniane.  
  
 Jeśli tylko `path` zostanie podany, a następnie <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> wystąpienie dla tej ścieżki zostanie usunięty. Jeśli oba `path` i `username` są dostarczane, a następnie <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> wystąpienie kombinacji `path` i `username` zostanie usunięty.  
  
> [!NOTE]
>  Możesz spróbować usunąć nieistniejącego elementu z kolekcji; Ta akcja nie zgłosi wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kolekcja została oznaczona jako tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ma wartość null.  
  
\- lub — 
oba parametry mają wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="public void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReadOnly();" />
      <MemberSignature Language="F#" Value="member this.SetReadOnly : unit -&gt; unit" Usage="personalizationStateInfoCollection.SetReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oznacza kolekcji jako tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody, które próbuje zmodyfikować kolekcji tylko do odczytu, takich jak <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add%2A> i <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove%2A>, throw <xref:System.NotSupportedException> wyjątku.  
  
> [!NOTE]
>  Możesz wywołać <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly%2A> metody wielokrotnie w kolekcji; spowoduje zgłaszała wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> wystąpienia.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />. Zestaw formantów części sieci Web zwraca odwołanie do bieżącego obiektu kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Klasy pochodne może zapewnić własnych zsynchronizowanej wersji przy użyciu kolekcji <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> właściwości. Synchronizowanie kodu należy wykonywać operacje na <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> kolekcji, a nie bezpośrednio w samej kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności zachowuje właściwe synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie wystąpienie kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, do którego zbiór <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> obiekty zostaną skopiowane.</param>
        <param name="index">Punkt w <c>tablicy</c> od którego należy rozpocząć kopiowanie <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> obiektów.</param>
        <summary>Implementuje podstawowy <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody, takiej jak <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> tej klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo%2A> metoda, po prostu wywołuje <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> metody i przekazuje `array` i `index` parametrów.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
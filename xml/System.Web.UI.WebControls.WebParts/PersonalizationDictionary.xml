<Type Name="PersonalizationDictionary" FullName="System.Web.UI.WebControls.WebParts.PersonalizationDictionary">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8bd5d7b39f10ff2ba6f1a2a5802247f609b9cfde" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36385860" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PersonalizationDictionary : System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PersonalizationDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class PersonalizationDictionary&#xA;Implements IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationDictionary : System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type PersonalizationDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Hermetyzuje podstawowych reguł sprawdzania poprawności wskazujące, czy element danych niestandardowych jest uznawany za personalizable albo <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> lub <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> zakresu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> wystąpienie jest kolekcją <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> obiektów, które składają się z zakresu personalizacji i wartość obiektu. Te wpisy są przypisane klucza w <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> obiektu.  
  
 Dobrym rozwiązaniem jest dodanie wszystkich właściwości do słownika przy użyciu <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> metody, niezależnie od zakresu strony. .NET Framework zapisuje informacje w odpowiedni sposób; na przykład jest zapisywany udostępnionych danych, gdy strona jest w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu. Jednak właściwości udostępnione nie są zapisywane po zapisaniu wartości składników Web Part, strona znajduje się w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu i <xref:System.Web.UI.WebControls.WebParts.WebPart> formant został dodany ze stroną w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.ICollection" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pusty słownik. Słownik traktują wartości klucza jako bez uwzględniania wielkości liter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationDictionary (int initialSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationDictionary(int initialSize);" />
      <MemberSignature Language="F#" Value="new System.Web.UI.WebControls.WebParts.PersonalizationDictionary : int -&gt; System.Web.UI.WebControls.WebParts.PersonalizationDictionary" Usage="new System.Web.UI.WebControls.WebParts.PersonalizationDictionary initialSize" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialSize">Szacowana liczba wpisów, które mają być przechowywane w słowniku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> przy użyciu podanego parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje pusty słownik, oparte na szacowaną liczbę wpisów, które mają być przechowywane w słowniku. Słownik traktują wartości klucza jako bez uwzględniania wielkości liter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (string key, System.Web.UI.WebControls.WebParts.PersonalizationEntry value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string key, class System.Web.UI.WebControls.WebParts.PersonalizationEntry value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Add(System.String,System.Web.UI.WebControls.WebParts.PersonalizationEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As String, value As PersonalizationEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ key, System::Web::UI::WebControls::WebParts::PersonalizationEntry ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : string * System.Web.UI.WebControls.WebParts.PersonalizationEntry -&gt; unit&#xA;override this.Add : string * System.Web.UI.WebControls.WebParts.PersonalizationEntry -&gt; unit" Usage="personalizationDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Web.UI.WebControls.WebParts.PersonalizationEntry" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla elementu informacji o stanie.</param>
        <param name="value">Fragment informacji o stanie mają zostać dodane do słownika personalizacji. Ta wartość może być <see langword="null" />.</param>
        <summary>Dodaje wpisy personalizacji do słownika personalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można wywołać tę metodę, umieść różne informacje niestandardowe stanu do obiektu stanu i określić zakres skojarzony z wartością stanu. Gdy <xref:System.Web.UI.WebControls.WebParts.WebPartManager> znajduje się kontrolka <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu, można dodać nazwę i stan informacje, które jest skojarzony z jedną <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu lub <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu. W <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu, można dodać nazwę i stan informacje skojarzone tylko z <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu.  
  
 Jednak jest dobrym rozwiązaniem, aby dodać wszystkie właściwości do słownika przy użyciu <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A> właściwości z tym <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> lub <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu, niezależnie od zakresu strony.  
  
 .NET Framework zapisze tylko właściwości z <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres, gdy jest to konieczne. Innymi słowy, udostępnione właściwości nie są zapisywane podczas <xref:System.Web.UI.WebControls.WebParts.WebPart> formant, który pierwotnie został dodany w <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakres później są zapisywane w trakcie strony <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu. W scenariuszu przeciwnej Jeśli <xref:System.Web.UI.WebControls.WebParts.WebPart> formant został dodany do strony <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> zakresu i formantu później jest zapisywany w trakcie strony <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> zakresu wartości właściwości niestandardowych udostępnionego są zapisany (wraz z zakresu użytkownika właściwości niestandardowych). Aby uzyskać szczegółowe informacje o danych personalizacji i udostępnionych i zakresu użytkownika właściwości dotyczy zakresu personalizacji strony, zobacz [Przegląd personalizacji części sieci Web](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320) tematu.  
  
 Podobnie jak w przypadku kolekcji, ta metoda zwiększa liczbę kolekcji przez jedną i wszystkie moduły wyliczające aktualnie aktywne w kolekcji należy unieważnione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> jest zduplikowany klucz już w słowniku.  \- lub - <paramref name="key" /> jest pustym ciągiem ("") lub przycinanie <paramref name="key" /> wyników w pustym ciągiem.  \- lub - <paramref name="value" /> nie jest <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.  \- lub - <paramref name="value" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="personalizationDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie informacje o stanie niestandardowych z bieżącego <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wszystkie informacje o stanie niestandardowych z bieżącego <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> obiektu. Wszystkie wyliczenia, które są aktualnie aktywne w odniesieniu do kolekcji należy unieważniona. Aby usunąć wpis personalizacji określonych w słowniku personalizacji, użyj <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Remove%2A> metody.  
  
 Należy pamiętać, że wywołanie tej metody personalizacji pusty słownik nie wygenerował błąd.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::String ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : string -&gt; bool&#xA;override this.Contains : string -&gt; bool" Usage="personalizationDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Wartość klucza.</param>
        <summary>Zwraca wartość wskazującą, czy stan niestandardowych informacji z tym samym kluczem znajduje się w słowniku personalizacji.</summary>
        <returns>
          <see langword="true" /> Jeśli klucz w słowniku personalizacji; pasuje do podanego klucza w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić, czy stan niestandardowych informacji znajduje się w słowniku personalizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> jest to pusty ciąg (""), lub przycinanie <paramref name="key" /> wyników w pustym ciągiem.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (System.Collections.DictionaryEntry[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (array As DictionaryEntry(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="personalizationDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica <see cref="T:System.Collections.DictionaryEntry" /> wystąpienia są kopiowane do.</param>
        <param name="index">Lokalizacja indeksu, od którego należy zacząć kopiowanie.</param>
        <summary>Kopiuje wpisy stanu personalizacji słownika jako <see cref="T:System.Collections.DictionaryEntry" /> wystąpień w określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do utworzenia tablicy <xref:System.Collections.DictionaryEntry> wystąpień na podstawie stanu wpisów w słowniku personalizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  \- lub - <paramref name="array" /> na podstawie jest niewłaściwy rozmiar <paramref name="index" /> parametru.  \- lub - <paramref name="array" /> ma za mało miejsca na przechowywanie wartości zawartych w słowniku personalizacji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wpisów w słowniku.</summary>
        <value>Liczba wpisów w słowniku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, aby pobrać liczbę wpisów w słowniku personalizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="personalizationDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może służyć do iterowania po wpisów w słowniku personalizacji.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> Słownika personalizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie można zmodyfikować kolekcji źródłowej. Aby uzyskać więcej informacji na moduły wyliczające, zobacz <xref:System.Collections.IEnumerator> interfejsu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy słownik personalizacji o stałym rozmiarze.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `false` ponieważ słowniki personalizacji nie są o stałym rozmiarze.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy słownik personalizacji jest tylko do odczytu.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `false` ponieważ słowniki personalizacji nie są tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy słownik personalizacji jest zsynchronizowany.</summary>
        <value>
          <see langword="false" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawsze zwraca `false` ponieważ słowniki personalizacji nie są zsynchronizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationEntry this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationEntry Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As String) As PersonalizationEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::PersonalizationEntry ^ default[System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationEntry ^ get(System::String ^ key); void set(System::String ^ key, System::Web::UI::WebControls::WebParts::PersonalizationEntry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.UI.WebControls.WebParts.PersonalizationEntry with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu, który można pobrać lub zmienione.</param>
        <summary>Pobiera lub ustawia wpis w słowniku personalizacji.</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> reprezentujących informacje niestandardowe personalizacji określone przez <paramref name="key" /> parametru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość działa z <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> obiekt reprezentujący informacje niestandardowe personalizacji, identyfikowany przez `key` parametru. Jeśli nie ma żadnej wartości dla `key`, `null` jest zwracany.  
  
 Jeśli `key` jeszcze nie istnieje, następnie `key` (i jej powiązaną wartość) zostaną dodane do słownika.  
  
 Należy zauważyć, że można dodać wartości null do słownika i indeksatora mogą służyć do aktualizowania wartości personalizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> jest to pusty ciąg (""), lub przycinanie <paramref name="key" /> wyników w pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do <see cref="T:System.Collections.ICollection" /> obiekt zawierający klucze słownika personalizacji.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierająca klucze słownika personalizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia uzyskanie kluczy dla słownika personalizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::String ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : string -&gt; unit&#xA;override this.Remove : string -&gt; unit" Usage="personalizationDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wpisu do usunięcia.</param>
        <summary>Usuwa wpis stanu niestandardowych, na podstawie podanego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wewnętrznie po usunięciu wpisu niestandardowych stanu liczba słownika personalizacji jest zmniejszana o jeden. Wszystkie moduły wyliczające aktywne za pomocą słownika powinien unieważniona.  
  
 Nie występuje błąd przy próbie usunięcia nieistniejącej klucza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> jest to pusty ciąg (""), lub przycinanie <paramref name="key" /> wyników w pustym ciągiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do słownika personalizacji.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do słownika personalizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla kolekcji, w których Magazyn nie jest publicznie dostępna oczekiwano implementacja jest aby powrócić do bieżącego wystąpienia. Należy pamiętać, że wskaźnik do bieżącego wystąpienia nie może być wystarczający do kolekcji, które otaczają innych kolekcji; te powinny zwrócić odpowiednia Kolekcja <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.SyncRoot%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> z <see cref="T:System.Collections.DictionaryEntry" /> elementów ma zostać skopiowany do <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />.</param>
        <param name="index">Punkt początkowy w <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> w celu wstawienia <c>tablicy</c>.</param>
        <summary>Implementuje <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> metodę <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.CopyTo%2A> Metoda sprawdza, czy `array` jest tablicą <xref:System.Collections.DictionaryEntry> elementy, a następnie wywołuje <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.CopyTo%2A> metoda przekazywania do niej `array` i `index`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> nie jest tablicą <see cref="T:System.Collections.DictionaryEntry" /> elementów.</exception>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.String" /> Ma być używana jako klucz elementu w słowniku personalizacji.</param>
        <param name="value">
          <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> Do dodania do słownika personalizacji.</param>
        <summary>Implementuje <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" /> metodę <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Add%2A> Metoda sprawdza kilka szczegóły, aby zapewnić poprawność `value` i `key` przed podjęciem próby dodania ich do słownika personalizacji. Jeśli testy zostały wykonane pomyślnie, wywołuje metodę <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Add%2A> metoda przekazywania do niej `key` i `value` parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> nie jest <see cref="T:System.String" /> obiektu.  \- lub - <paramref name="value" /> nie jest <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> obiektu.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Add(System.String,System.Web.UI.WebControls.WebParts.PersonalizationEntry)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A <see cref="T:System.String" /> obiektu, który identyfikuje określonego <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> można sprawdzić, czy w słowniku personalizacji.</param>
        <summary>Implementuje <see cref="M:System.Collections.IDictionary.Contains(System.Object)" /> metodę <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="key" /> istnieje w słowniku personalizacji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Contains%2A> Metody kontroli `key` zapewnienie jest prawidłowym obiektem do sprawdzania słownika personalizacji, a jeśli tak, przekazuje go do <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Contains%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> nie jest <see cref="T:System.String" />.</exception>
        <altmember cref="M:System.Collections.IDictionary.Contains(System.Object)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Contains(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A <see cref="T:System.String" /> , które identyfikują danego <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> obiektu w słowniku personalizacji.</param>
        <summary>Pobiera lub ustawia <see cref="P:System.Collections.IDictionary.Item(System.Object)" /> wartości właściwości dla <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> obiektu, którego wartość odpowiada <paramref name="key" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Item%2A> Najpierw upewnia się, że `key` jest <xref:System.String> obiektu, i jeśli tak, wywołuje <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Item%2A> właściwości do zwrócenia <xref:System.Web.UI.WebControls.WebParts.PersonalizationEntry> którego klucz jest równe `key` w słowniku bieżącej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> nie jest <see cref="T:System.String" /> obiektu.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Item(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">A <see cref="T:System.String" /> , które identyfikują danego <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationEntry" /> obiekt ma zostać usunięty ze słownika personalizacji.</param>
        <summary>Implementuje <see cref="M:System.Collections.IDictionary.Remove(System.Object)" /> metodę <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Remove%2A> Kontroli — metoda czy `key` jest <xref:System.String> obiektu, a jeśli tak, wywołuje <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Remove%2A> jest metoda `key` do niego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> nie jest <see cref="T:System.String" />.</exception>
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Remove(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="M:System.Collections.IEnumerable.GetEnumerator" /> metodę <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" /> klasy.</summary>
        <returns>Wystąpienie <see cref="T:System.Collections.IEnumerator" /> do sortowania elementów w słowniku personalizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.GetEnumerator%2A> Bezpośrednio wywołuje metodę <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> własne klasy <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Web.UI.WebControls.WebParts.PersonalizationDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do <see cref="T:System.Collections.ICollection" /> obiekt zawierający wartości w słowniku personalizacji.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> Zawierająca wartości słownika personalizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby uzyskać wartości ze słownika personalizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
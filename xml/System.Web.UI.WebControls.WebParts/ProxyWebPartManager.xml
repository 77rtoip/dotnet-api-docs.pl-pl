<Type Name="ProxyWebPartManager" FullName="System.Web.UI.WebControls.WebParts.ProxyWebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6bdb65d8082839992e9c9f14aafe65d91a1b2156" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69394815" /></Metadata><TypeSignature Language="C#" Value="public class ProxyWebPartManager : System.Web.UI.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProxyWebPartManager extends System.Web.UI.Control" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ProxyWebPartManager&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProxyWebPartManager : System::Web::UI::Control" />
  <TypeSignature Language="F#" Value="type ProxyWebPartManager = class&#xA;    inherit Control" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.ProxyWebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.ProxyWebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia deweloperom deklarowanie połączeń statycznych na stronie zawartości, gdy <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> formant został zadeklarowany na stronie wzorcowej skojarzonej ze stroną zawartości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka istnieje dla konkretnego scenariusza deklarowania połączeń statycznych na stronach zawartości, <xref:System.Web.UI.WebControls.WebParts.WebPartManager> gdy kontrolka została już zadeklarowana na stronie wzorcowej. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager>  
  
 Zgodnie z projektem Strona sieci Web, która używa kontrolek składniki Web Part, musi zawierać jedną (i <xref:System.Web.UI.WebControls.WebParts.WebPartManager> tylko jedną) kontrolkę, która zarządza wszystkimi kontrolkami składniki Web Part na stronie. Gdy aplikacja składniki Web Part korzysta ze stron wzorcowych, często należy umieścić <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formant na stronie wzorcowej, ponieważ wszystkie strony zawartości są scalone ze stroną wzorcową w czasie wykonywania, a pojedynczy <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formant będzie zarządzać wszystkimi kontrolkami składniki Web Part ze wszystkich stron zawartości. Jednak gdy deweloperzy chcą zadeklarować połączenia statyczne na stronach zawartości takiej aplikacji, może wydawać się, że nastąpiło ograniczenie. Statyczne połączenie składniki Web Part może być deklarowane tylko przez dodanie `<asp:webpartconnection>` elementu jako element podrzędny `<staticconnections>` elementu, który sam musi `<asp:webpartmanager>` być elementem podrzędnym elementu. Ale ponieważ <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolka została już zadeklarowana na stronie wzorcowej i jest jedną z dozwolonych <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolek, deweloperzy nie <xref:System.Web.UI.WebControls.WebParts.WebPartManager> mogą zadeklarować dodatkowych kontrolek na stronach zawartości w celu dodania połączeń statycznych.  
  
 Kontrolka w tym scenariuszu wykonuje <xref:System.Web.UI.WebControls.WebParts.WebPartManager>miejsce. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> Deweloperzy deklarują `<asp:proxywebpartmanager>` element zamiast `<asp:webpartmanager>` elementu na stronach zawartości, a następnie mogą deklarować połączenia statyczne jako elementy podrzędne. W czasie wykonywania połączenia w <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> formancie są po prostu dodawane <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> do kolekcji <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolki i traktowane jak inne połączenia.  
  
 Ponieważ kontrolka jest używana tylko w tym konkretnym scenariuszu programistycznym, ma bardziej ograniczoną funkcjonalność <xref:System.Web.UI.WebControls.WebParts.WebPartManager> niż Klasa. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> W rzeczywistości, chociaż <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> formant działa jako serwer proxy, aby zawierał statyczne połączenia <xref:System.Web.UI.WebControls.WebParts.WebPartManager> dla formantu na stronach zawartości, nie dziedziczy <xref:System.Web.UI.WebControls.WebParts.WebPartManager> po formancie. Dziedziczy bezpośrednio z <xref:System.Web.UI.Control> klasy i zastępuje tylko kilka podstawowych elementów członkowskich. Właściwości <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible%2A>, i<xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID%2A> są zastępowane i przypisane wartości uniemożliwiające ich użycie. Inne dziedziczone właściwości są zastępowane w celu dostosowania ich zachowania w czasie projektowania, ale w przeciwnym razie mają takie samo zachowanie jak właściwości podstawowe. Należą do <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Controls%2A> nich właściwości <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.ClientID%2A> i. Na <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> koniec Klasa ma jedną niedziedziczoną właściwość. Właściwość zwraca własną kolekcję połączeń statycznych <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection> (obiekt). <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A>  
  
 Podobnie jak w przypadku metod <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> Klasa ta zastępuje tylko kilka metod, głównie w celu ograniczenia ich użycia. Dziedziczona <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus%2A> Metoda jest niezdatna do użytku przez zgłaszanie wyjątku w przypadku wywołania. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection%2A> Metoda zawsze zwraca pustą kolekcję kontrolek, która ma wpływ na to, że nie może zawierać kolekcji kontrolek. Na <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit%2A> koniec metoda wywołuje metodę podstawową, a następnie przypisuje kolekcję połączeń przywoływanych <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> przez właściwość <xref:System.Web.UI.WebControls.WebParts.WebPartManager> do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> właściwości formantu. Ma to wpływ na zestawianie wszystkich połączeń statycznych zadeklarowanych na wszystkich stronach zawartości i wykonywanie ich części kolekcji Connections obsługiwanej przez <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formant na stronie wzorcowej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> jak używać klasy do deklarowania połączeń statycznych na stronach zawartości w aplikacji, która używa stron wzorcowych. Przykład ma pięć części:  
  
-   Kontrolka użytkownika, która umożliwia zmianę trybu wyświetlania składniki Web Part na stronie.  
  
-   Kod źródłowy dla interfejsu i dwóch <xref:System.Web.UI.WebControls.WebParts.WebPart> kontrolek działających jako dostawca i odbiorca połączenia.  
  
-   Główna strona sieci Web, która hostuje kontrolkę użytkownika, strony zawartości i <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolkę dla aplikacji.  
  
-   Strona internetowa zawartości, która hostuje <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> kontrolkę, dwie kontrolki niestandardowe <xref:System.Web.UI.WebControls.WebParts.WebPart> i połączenie statyczne w celu połączenia dwóch kontrolek.  
  
-   Wyjaśnienie, jak uruchomić stronę przykładową.  
  
 Pierwszym elementem tego przykładu kodu jest kontrolka użytkownika, która umożliwia użytkownikom zmianę trybów wyświetlania na stronie sieci Web. Zapisz następujący kod źródłowy w pliku. ascx, nadając mu nazwę pliku, która jest przypisana do `Src` atrybutu `Register` dyrektywy dla tej kontrolki użytkownika, która znajduje się w górnej części strony głównej hostingu. Aby uzyskać szczegółowe informacje na temat trybów wyświetlania i Opis kodu źródłowego w tej kontrolce, [zobacz Przewodnik: Zmienianie trybów wyświetlania na stronie](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)składniki Web Part.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/DisplayModeMenuVB.ascx#6)]  
  
 Drugą częścią przykładu kodu jest kod źródłowy interfejsu i kontrolek. Plik źródłowy zawiera prosty interfejs o nazwie `IZipCode`. Istnieje również <xref:System.Web.UI.WebControls.WebParts.WebPart> Klasa o nazwie `ZipCodeWebPart` implementująca interfejs i działająca jako formant dostawcy. Jego `ProvideIZipCode` Metoda jest metodą wywołania zwrotnego implementującą tylko element członkowski interfejsu. Metoda po prostu zwraca wystąpienie interfejsu. Należy zauważyć, że metoda jest oznaczona `ConnectionProvider` atrybutem w metadanych. Jest to mechanizm identyfikacji metody jako metody wywołania zwrotnego dla punktu połączenia dostawcy. Druga <xref:System.Web.UI.WebControls.WebParts.WebPart> Klasa ma nazwę `WeatherWebPart`i działa jako odbiorca połączenia. Ta klasa ma metodę o nazwie `GetZipCode` , która pobiera wystąpienie `IZipCode` interfejsu z kontrolki dostawcy. Należy zauważyć, że ta metoda jest oznaczona jako metoda punktu połączenia konsumenta z `ConnectionConsumer` atrybutem w metadanych.  
  
 Aby przykład kodu był uruchamiany, należy skompilować ten kod źródłowy. Można ją skompilować jawnie i umieścić zestaw w folderze bin witryny sieci Web lub w globalnej pamięci podręcznej zestawów. Alternatywnie można umieścić kod źródłowy w folderze App_Code witryny, w którym będzie on dynamicznie kompilowany w czasie wykonywania. Ten przykład kodu używa kompilacji dynamicznej. Aby zapoznać się z przewodnikiem, który ilustruje sposób [kompilowania, zobacz Przewodnik: Opracowywanie i używanie niestandardowej kontrolki](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)serwera sieci Web.  
  
 [!code-csharp[WebParts_ProxyWebPartManager_Overview#4](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/ZipCodeComponent.cs#4)]
 [!code-vb[WebParts_ProxyWebPartManager_Overview#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/ZipCodeComponent.vb#4)]  
  
 Trzecią częścią przykładu kodu jest strona wzorcowa. Należy użyć następującego kodu źródłowego i zapisać go w pliku, nadając mu nazwę MasterPageCS. Master lub MasterPageVB. Master (w zależności od używanego języka). Należy zauważyć, że strona wzorcowa `Register` zawiera dyrektywę służącą do zarejestrowania kontrolki użytkownika i odwołuje się do samej kontrolki użytkownika w treści strony. Strona wzorcowa również deklaruje pojedynczy `<asp:webpartmanager>` element używany na tej stronie i wszystkie powiązane strony zawartości. Na koniec Strona wzorcowa ma `<asp: contentplaceholder>` element, który deklaruje punkt na stronie, w której jest wstawiana strona zawartości.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/MasterPageCS.master#1)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/MasterPageVB.master#1)]  
  
 Czwartą częścią przykładu kodu jest strona zawartości. Należy skopiować następujący kod źródłowy i zapisać go w pliku z rozszerzeniem. aspx. Należy zauważyć, `Page` że jego dyrektywa `MasterFile` zawiera atrybut, aby odwołać się do strony głównej. Ponadto ta strona zawiera dyrektywę służącą `Register` do zarejestrowania pliku w folderze App_Code, który zawiera dynamicznie skompilowane kontrolki niestandardowe <xref:System.Web.UI.WebControls.WebParts.WebPart> , które uczestniczą w połączeniu. Wewnątrz tagów strony istnieje `<asp:proxywebpartmanager>` element z elementem podrzędnym `<staticconnections>` , który z kolei ma element podrzędny `<asp:webpartconnection>` , aby zadeklarować szczegóły połączenia. `<asp:content>` W tagach na stronie `Button1_Click` Metoda dodaje kod, który uzyskuje dostęp do głównego <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formantu na stronie wzorcowej i <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> kontrolki na stronie zawartość, i zapisuje niektóre szczegóły na stronie. `<script>`  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/contentPage1CS.aspx#2)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/contentPage1VB.aspx#2)]  
  
 Po załadowaniu strony w przeglądarce kliknij przycisk **Informacje o elemencie WebPartManager** i zapoznaj się z informacjami na temat <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolki na <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> stronie wzorcowej i kontrolki na stronie zawartość. Na przykład Zwróć uwagę, że obie te wartości mają tę samą liczbę w odpowiednich właściwościach, które śledzą <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> połączenia statyczne (Właściwość). Należy również pamiętać, że <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Chociaż formant <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> ma właściwość <xref:System.Web.UI.WebControls.WebParts.WebPart> , która śledzi liczbę formantów, które zarządza, <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> formant nie ma takiej właściwości, ponieważ jedynym celem jest zawieranie połączeń statycznych.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">Kontrolki składniki Web Part ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProxyWebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProxyWebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public override string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator formantu dla znacznika HTML, który jest generowany przez ASP.NET.</summary>
        <value>Identyfikator kontrolki dla znacznika HTML, który jest generowany przez ASP.NET.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Control.ClientID" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.ControlCollection" /> Pobiera obiekt reprezentujący kontrolki podrzędne dla określonej kontrolki serwera w hierarchii interfejsu użytkownika.</summary>
        <value>Kolekcja formantów podrzędnych dla określonej kontrolki serwerowej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="proxyWebPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zastępuje właściwość podstawową, aby zapobiec wyświetlaniu <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" /> formantów przez formant.</summary>
        <returns>Zawsze zwraca wartość <see cref="T:System.Web.UI.EmptyControlCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zastępuje metodę bazową, aby <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> zapobiec wyświetlaniu i zwracaniu kolekcji formantów przez formant. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection%2A> Jedynym celem jest włączenie połączeń statycznych, które mają być deklarowane na stronach zawartości w aplikacji, która używa stron wzorcowych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje właściwość podstawową, aby uniemożliwić korzystanie z motywów.</summary>
        <value>Zawsze zwraca <see langword="false" />, aby uniemożliwić korzystanie z motywów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zastępuje właściwość podstawową, aby uniemożliwić używanie motywów <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> z kontrolką. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming%2A> Ma to zapobiec konfliktom z wszelkimi motywami używanymi z <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolką na stronie wzorcowej (jego <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A?displayProperty=nameWithType> Właściwość zawsze zwraca wartość `true`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący próbuje przypisać wartość do tej właściwości.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="proxyWebPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zastępuje metodę podstawową, aby zapobiec wywołaniu metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus%2A> Metoda przesłania metodę bazową i zgłasza wyjątek, jeśli jakikolwiek obiekt wywołujący próbuje wywołać metodę. Wynika to z faktu <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> , że dziedziczona Metoda jest zaprojektowana dla kontrolek z interfejsem użytkownika <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> , ale formant nie ma interfejsu użytkownika i w związku z tym nie ma potrzeby ustawiania fokusu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący próbuje wywołać tę metodę.</exception>
        <altmember cref="M:System.Web.UI.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="proxyWebPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> Podnosi zdarzenie i inicjuje formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wywołuje metodę podstawową, a następnie wykonuje zadania w celu <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> zainicjowania formantu. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit%2A> Ważnym zadaniem tej metody jest przypisanie kolekcji połączeń przywoływanych przez <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> Właściwość <xref:System.Web.UI.WebControls.WebParts.WebPartManager> do <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> kolekcji kontrolek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Formant ze skojarzonej strony wzorcowej to <see langword="null" />. <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /></exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje właściwość podstawową, aby zapobiec przypisaniu wartości.</summary>
        <value>Zawsze zwraca pusty ciąg ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zastępuje właściwość podstawową, aby zapobiec przypisaniu do niej wartości, która ma wpływ na uniemożliwianie używania karnacji <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> z kontrolką. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID%2A> Dzieje się tak, ponieważ kontrolka nigdy nie ujawnia interfejsu użytkownika na stronie. Takie samo zachowanie jest implementowane przez <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formant dla jego <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący próbuje przypisać wartość do tej właściwości.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As ProxyWebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::ProxyWebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::ProxyWebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję połączeń statycznych zadeklarowanych w obrębie <see langword="&lt;asp:proxywebpartmanager&gt;" /> elementu na stronie zawartości.</summary>
        <value>A <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection" /> , który zawiera wszystkie <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> obiekty statyczne zadeklarowane <see langword="&lt;asp:proxywebpartmanager&gt;" /> w obrębie elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość odwołuje się do <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> kolekcji obiektów zadeklarowanych w `<asp:proxywebpartmanager>` elemencie. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> Połączenia zawarte w tej kolekcji są dodawane do statycznych połączeń <xref:System.Web.UI.WebControls.WebParts.WebPartManager> formantów (do których odwołuje się jego <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> kolekcja) i traktowane dokładnie jak <xref:System.Web.UI.WebControls.WebParts.WebPartManager> inne połączenia skojarzone z kontrolką.  
  
 Element deklaratywny, który odnosi się <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> do właściwości, `<staticconnections>` jest elementem. W aplikacji `<staticconnections>` korzystającej ze stron wzorcowych element jest dodawany jako element podrzędny `<asp:proxywebpartmanager>` elementu na stronie `<asp:webpartconnection>` zawartości, a element z `<staticconnections>` kolei zostaje dodany jako element podrzędny elementu. Do `<asp:webpartconnection>` jednego`<staticconnections>` elementu można dodać wiele elementów, a wiele stron zawartości może deklarować połączenia statyczne jako część aplikacji stron wzorcowych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> właściwości <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> klasy. Ten przykład kodu przedstawia tylko odpowiednią część kodu ze strony zawartości, która deklaruje <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> formant i połączenie statyczne. Aby uzyskać informacje na temat innych stron wymaganych do uruchomienia przykładu kodu, a opis sposobu ich konfigurowania, zobacz sekcję przykład w <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> temacie Omówienie klasy.  
  
 Poniższy kod jest stroną zawartości, która deklaruje `<staticconnections>` element jako element podrzędny `<asp:proxywebpartmanager>` elementu. Należy również zauważyć, `Button1_Click` że metoda sprawdza liczbę <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> właściwości <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> kontrolki i zapisuje ją na stronie.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/contentPage1CS.aspx#2)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/contentPage1VB.aspx#2)]  
  
 Po załadowaniu strony w przeglądarce kliknij przycisk **Informacje o elemencie WebPartManager** i zapoznaj się z informacjami na temat <xref:System.Web.UI.WebControls.WebParts.WebPartManager> kontrolki na <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> stronie wzorcowej i kontrolki na stronie zawartość. Na przykład Zwróć uwagę, że obie te wartości mają tę samą liczbę w odpowiednich właściwościach, które śledzą <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> połączenia statyczne (Właściwość).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zastępuje właściwość podstawową, aby zapobiec przypisaniu wartości.</summary>
        <value>Zawsze zwraca <see langword="false" />, aby zapobiec widoczności formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość przesłania Właściwość podstawową, aby <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> zapobiec widoczności kontrolki. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible%2A> Kontrolka, taka <xref:System.Web.UI.WebControls.WebParts.WebPartManager> jak kontrolka, nie ma interfejsu użytkownika i nigdy nie jest wyświetlana użytkownikowi. <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący próbuje przypisać wartość do tej właściwości.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
        <altmember cref="P:System.Web.UI.Control.Visible" />
      </Docs>
    </Member>
  </Members>
</Type>
